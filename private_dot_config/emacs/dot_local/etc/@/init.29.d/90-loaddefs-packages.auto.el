(autoload 'straight-remove-unused-repos "straight" "Remove unused repositories from the repos and build directories.\nA repo is considered \"unused\" if it was not explicitly requested via\n`straight-use-package' during the current Emacs session.\nIf FORCE is non-nil do not prompt before deleting repos.\n\n(fn &optional FORCE)" t)(autoload 'straight-get-recipe "straight" "Interactively select a recipe from one of the recipe repositories.\nAll recipe repositories in `straight-recipe-repositories' will\nfirst be cloned. After the recipe is selected, it will be copied\nto the kill ring. With a prefix argument, first prompt for a\nrecipe repository to search. Only that repository will be\ncloned.\n\nFrom Lisp code, SOURCES should be a subset of the symbols in\n`straight-recipe-repositories'. Only those recipe repositories\nare cloned and searched. If it is nil or omitted, then the value\nof `straight-recipe-repositories' is used. If SOURCES is the\nsymbol `interactive', then the user is prompted to select a\nrecipe repository, and a list containing that recipe repository\nis used for the value of SOURCES. ACTION may be `copy' (copy\nrecipe to the kill ring), `insert' (insert at point), or nil (no\naction, just return it).\n\nOptional arg FILTER must be a unary function.\nIt takes a package name as its sole argument.\nIf it returns nil the candidate is excluded.\n\n(fn &optional SOURCES ACTION FILTER)" t)(autoload 'straight-visit-package-website "straight" "Visit the package RECIPE's website.\n\n(fn RECIPE)" t)(autoload 'straight-visit-package "straight" "Open PACKAGE's local repository directory.\nWhen BUILD is non-nil visit PACKAGE's build directory.\n\n(fn PACKAGE &optional BUILD)" t)(autoload 'straight-use-package "straight" "Register, clone, build, and activate a package and its dependencies.\nThis is the main entry point to the functionality of straight.el.\n\nMELPA-STYLE-RECIPE is either a symbol naming a package, or a list\nwhose car is a symbol naming a package and whose cdr is a\nproperty list containing e.g. `:type', `:local-repo', `:files',\nand VC backend specific keywords.\n\nFirst, the package recipe is registered with straight.el. If\nNO-CLONE is a function, then it is called with two arguments: the\npackage name as a string, and a boolean value indicating whether\nthe local repository for the package is available. In that case,\nthe return value of the function is used as the value of NO-CLONE\ninstead. In any case, if NO-CLONE is non-nil, then processing\nstops here.\n\nOtherwise, the repository is cloned, if it is missing. If\nNO-BUILD is a function, then it is called with one argument: the\npackage name as a string. In that case, the return value of the\nfunction is used as the value of NO-BUILD instead. In any case,\nif NO-BUILD is non-nil, then processing halts here. Otherwise,\nthe package is built and activated. Note that if the package\nrecipe has a nil `:build' entry, then NO-BUILD is ignored\nand processing always stops before building and activation\noccurs.\n\nCAUSE is a string explaining the reason why\n`straight-use-package' has been called. It is for internal use\nonly, and is used to construct progress messages. INTERACTIVE is\nnon-nil if the function has been called interactively. It is for\ninternal use only, and is used to determine whether to show a\nhint about how to install the package permanently.\n\nReturn non-nil when package is initially installed, nil otherwise.\n\n(fn MELPA-STYLE-RECIPE &optional NO-CLONE NO-BUILD CAUSE INTERACTIVE)" t)(autoload 'straight-register-package "straight" "Register a package without cloning, building, or activating it.\nThis function is equivalent to calling `straight-use-package'\nwith a non-nil argument for NO-CLONE. It is provided for\nconvenience. MELPA-STYLE-RECIPE is as for\n`straight-use-package'.\n\n(fn MELPA-STYLE-RECIPE)")(autoload 'straight-use-package-no-build "straight" "Register and clone a package without building it.\nThis function is equivalent to calling `straight-use-package'\nwith nil for NO-CLONE but a non-nil argument for NO-BUILD. It is\nprovided for convenience. MELPA-STYLE-RECIPE is as for\n`straight-use-package'.\n\n(fn MELPA-STYLE-RECIPE)")(autoload 'straight-use-package-lazy "straight" "Register, build, and activate a package if it is already cloned.\nThis function is equivalent to calling `straight-use-package'\nwith symbol `lazy' for NO-CLONE. It is provided for convenience.\nMELPA-STYLE-RECIPE is as for `straight-use-package'.\n\n(fn MELPA-STYLE-RECIPE)")(autoload 'straight-use-recipes "straight" "Register a recipe repository using MELPA-STYLE-RECIPE.\nThis registers the recipe and builds it if it is already cloned.\nNote that you probably want the recipe for a recipe repository to\ninclude a nil `:build' property, to unconditionally\ninhibit the build phase.\n\nThis function also adds the recipe repository to\n`straight-recipe-repositories', at the end of the list.\n\n(fn MELPA-STYLE-RECIPE)")(autoload 'straight-override-recipe "straight" "Register MELPA-STYLE-RECIPE as a recipe override.\nThis puts it in `straight-recipe-overrides', depending on the\nvalue of `straight-current-profile'.\n\n(fn MELPA-STYLE-RECIPE)")(autoload 'straight-check-package "straight" "Rebuild a PACKAGE if it has been modified.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. See also `straight-rebuild-package' and\n`straight-check-all'.\n\n(fn PACKAGE)" t)(autoload 'straight-check-all "straight" "Rebuild any packages that have been modified.\nSee also `straight-rebuild-all' and `straight-check-package'.\nThis function should not be called during init." t)(autoload 'straight-rebuild-package "straight" "Rebuild a PACKAGE.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument RECURSIVE, rebuild\nall dependencies as well. See also `straight-check-package' and\n`straight-rebuild-all'.\n\n(fn PACKAGE &optional RECURSIVE)" t)(autoload 'straight-rebuild-all "straight" "Rebuild all packages.\nSee also `straight-check-all' and `straight-rebuild-package'." t)(autoload 'straight-prune-build-cache "straight" "Prune the build cache.\nThis means that only packages that were built in the last init\nrun and subsequent interactive session will remain; other\npackages will have their build mtime information and any cached\nautoloads discarded.")(autoload 'straight-prune-build-directory "straight" "Prune the build directory.\nThis means that only packages that were built in the last init\nrun and subsequent interactive session will remain; other\npackages will have their build directories deleted.")(autoload 'straight-prune-build "straight" "Prune the build cache and build directory.\nThis means that only packages that were built in the last init\nrun and subsequent interactive session will remain; other\npackages will have their build mtime information discarded and\ntheir build directories deleted." t)(autoload 'straight-normalize-package "straight" "Normalize a PACKAGE's local repository to its recipe's configuration.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'.\n\n(fn PACKAGE)" t)(autoload 'straight-normalize-all "straight" "Normalize all packages. See `straight-normalize-package'.\nReturn a list of recipes for packages that were not successfully\nnormalized. If multiple packages come from the same local\nrepository, only one is normalized.\n\nPREDICATE, if provided, filters the packages that are normalized.\nIt is called with the package name as a string, and should return\nnon-nil if the package should actually be normalized.\n\n(fn &optional PREDICATE)" t)(autoload 'straight-fetch-package "straight" "Try to fetch a PACKAGE from the primary remote.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\nfetch not just from primary remote but also from upstream (for\nforked packages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-fetch-package-and-deps "straight" "Try to fetch a PACKAGE and its (transitive) dependencies.\nPACKAGE, its dependencies, their dependencies, etc. are fetched\nfrom their primary remotes.\n\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\nfetch not just from primary remote but also from upstream (for\nforked packages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-fetch-all "straight" "Try to fetch all packages from their primary remotes.\nWith prefix argument FROM-UPSTREAM, fetch not just from primary\nremotes but also from upstreams (for forked packages).\n\nReturn a list of recipes for packages that were not successfully\nfetched. If multiple packages come from the same local\nrepository, only one is fetched.\n\nPREDICATE, if provided, filters the packages that are fetched. It\nis called with the package name as a string, and should return\nnon-nil if the package should actually be fetched.\n\n(fn &optional FROM-UPSTREAM PREDICATE)" t)(autoload 'straight-merge-package "straight" "Try to merge a PACKAGE from the primary remote.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\nmerge not just from primary remote but also from upstream (for\nforked packages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-merge-package-and-deps "straight" "Try to merge a PACKAGE and its (transitive) dependencies.\nPACKAGE, its dependencies, their dependencies, etc. are merged\nfrom their primary remotes.\n\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\nmerge not just from primary remote but also from upstream (for\nforked packages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-merge-all "straight" "Try to merge all packages from their primary remotes.\nWith prefix argument FROM-UPSTREAM, merge not just from primary\nremotes but also from upstreams (for forked packages).\n\nReturn a list of recipes for packages that were not successfully\nmerged. If multiple packages come from the same local\nrepository, only one is merged.\n\nPREDICATE, if provided, filters the packages that are merged. It\nis called with the package name as a string, and should return\nnon-nil if the package should actually be merged.\n\n(fn &optional FROM-UPSTREAM PREDICATE)" t)(autoload 'straight-pull-package "straight" "Try to pull a PACKAGE from the primary remote.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM, pull\nnot just from primary remote but also from upstream (for forked\npackages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-pull-package-and-deps "straight" "Try to pull a PACKAGE and its (transitive) dependencies.\nPACKAGE, its dependencies, their dependencies, etc. are pulled\nfrom their primary remotes.\n\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\npull not just from primary remote but also from upstream (for\nforked packages).\n\n(fn PACKAGE &optional FROM-UPSTREAM)" t)(autoload 'straight-pull-all "straight" "Try to pull all packages from their primary remotes.\nWith prefix argument FROM-UPSTREAM, pull not just from primary\nremotes but also from upstreams (for forked packages).\n\nReturn a list of recipes for packages that were not successfully\npulled. If multiple packages come from the same local repository,\nonly one is pulled.\n\nPREDICATE, if provided, filters the packages that are pulled. It\nis called with the package name as a string, and should return\nnon-nil if the package should actually be pulled.\n\n(fn &optional FROM-UPSTREAM PREDICATE)" t)(autoload 'straight-push-package "straight" "Push a PACKAGE to its primary remote, if necessary.\nPACKAGE is a string naming a package. Interactively, select\nPACKAGE from the known packages in the current Emacs session\nusing `completing-read'.\n\n(fn PACKAGE)" t)(autoload 'straight-push-all "straight" "Try to push all packages to their primary remotes.\n\nReturn a list of recipes for packages that were not successfully\npushed. If multiple packages come from the same local repository,\nonly one is pushed.\n\nPREDICATE, if provided, filters the packages that are normalized.\nIt is called with the package name as a string, and should return\nnon-nil if the package should actually be normalized.\n\n(fn &optional PREDICATE)" t)(autoload 'straight-freeze-versions "straight" "Write version lockfiles for currently activated packages.\nThis implies first pushing all packages that have unpushed local\nchanges. If the package management system has been used since the\nlast time the init-file was reloaded, offer to fix the situation\nby reloading the init-file again. If FORCE is\nnon-nil (interactively, if a prefix argument is provided), skip\nall checks and write the lockfile anyway.\n\nCurrently, writing version lockfiles requires cloning all lazily\ninstalled packages. Hopefully, this inconvenient requirement will\nbe removed in the future.\n\nMultiple lockfiles may be written (one for each profile),\naccording to the value of `straight-profiles'.\n\n(fn &optional FORCE)" t)(autoload 'straight-thaw-versions "straight" "Read version lockfiles and restore package versions to those listed." t)(autoload 'straight-bug-report "straight" "Test straight.el in a clean environment.\nARGS may be any of the following keywords and their respective values:\n  - :pre-bootstrap (Form)...\n      Forms evaluated before bootstrapping straight.el\n      e.g. (setq straight-repository-branch \"develop\")\n      Note this example is already in the default bootstrapping code.\n\n  - :post-bootstrap (Form)...\n      Forms evaluated in the testing environment after boostrapping.\n      e.g. (straight-use-package \\='(example :type git :host github))\n\n  - :interactive Boolean\n      If nil, the subprocess will immediately exit after the test.\n      Output will be printed to `straight-bug-report--process-buffer'\n      Otherwise, the subprocess will be interactive.\n\n  - :preserve Boolean\n      If non-nil, the test directory is left in the directory stored in the\n      variable `temporary-file-directory'. Otherwise, it is\n      immediately removed after the test is run.\n\n  - :executable String\n      Indicate the Emacs executable to launch.\n      Defaults to the path of the current Emacs executable.\n\n  - :raw Boolean\n      If non-nil, the raw process output is sent to\n      `straight-bug-report--process-buffer'. Otherwise, it is\n      formatted as markdown for submitting as an issue.\n\n  - :user-dir String\n      If non-nil, the test is run with `user-emacs-directory' set to STRING.\n      Otherwise, a temporary directory is created and used.\n      Unless absolute, paths are expanded relative to the variable\n      `temporary-file-directory'.\n\nARGS are accessible within the :pre/:post-bootsrap phases via the\nlocally bound plist, straight-bug-report-args.\n\n(fn &rest ARGS)" nil t)(function-put 'straight-bug-report 'lisp-indent-function 0)(autoload 'straight-dependencies "straight" "Return a list of PACKAGE's dependencies.\n\n(fn &optional PACKAGE)" t)(autoload 'straight-dependents "straight" "Return a list of PACKAGE's dependents.\n\n(fn &optional PACKAGE)" t)(defvar straight-x-pinned-packages nil "List of pinned packages.")(autoload 'link-hint-define-type "link-hint" "Add a new type of link called NAME to link-hint.el.\nPROPERTIES should be property value pairs to add to the symbol plist of\nlink-hint-NAME.\n\n(fn NAME &rest PROPERTIES)")(function-put 'link-hint-define-type 'lisp-indent-function 'defun)(autoload 'link-hint-open-link "link-hint" "Use avy to open a visible link." t)(autoload 'link-hint-copy-link "link-hint" "Copy a visible link of a supported type to the kill ring with avy.\n`select-enable-clipboard' and `select-enable-primary' can be set to non-nil\nvalues to copy the link to the clipboard and/or primary as well." t)(autoload 'link-hint-open-multiple-links "link-hint" "Use avy to open multiple visible links at once." t)(autoload 'link-hint-copy-multiple-links "link-hint" "Use avy to copy multiple visible links at once to the kill ring." t)(autoload 'link-hint-open-all-links "link-hint" "Open all visible links." t)(autoload 'link-hint-copy-all-links "link-hint" "Copy all visible links." t)(autoload 'link-hint-open-link-at-point "link-hint" "Open the link with the highest priority at the point." t)(autoload 'link-hint-copy-link-at-point "link-hint" "Copy the link with the highest priority at the point." t)(autoload 'avy-process "avy" "Select one of CANDIDATES using `avy-read'.\nUse OVERLAY-FN to visualize the decision overlay.\nCLEANUP-FN should take no arguments and remove the effects of\nmultiple OVERLAY-FN invocations.\n\n(fn CANDIDATES &optional OVERLAY-FN CLEANUP-FN)")(autoload 'avy-goto-char "avy" "Jump to the currently visible CHAR.\nThe window scope is determined by `avy-all-windows' (ARG negates it).\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-char-in-line "avy" "Jump to the currently visible CHAR in the current line.\n\n(fn CHAR)" t)(autoload 'avy-goto-char-2 "avy" "Jump to the currently visible CHAR1 followed by CHAR2.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\nBEG and END narrow the scope where candidates are searched.\n\n(fn CHAR1 CHAR2 &optional ARG BEG END)" t)(autoload 'avy-goto-char-2-above "avy" "Jump to the currently visible CHAR1 followed by CHAR2.\nThis is a scoped version of `avy-goto-char-2', where the scope is\nthe visible part of the current buffer up to point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR1 CHAR2 &optional ARG)" t)(autoload 'avy-goto-char-2-below "avy" "Jump to the currently visible CHAR1 followed by CHAR2.\nThis is a scoped version of `avy-goto-char-2', where the scope is\nthe visible part of the current buffer following point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR1 CHAR2 &optional ARG)" t)(autoload 'avy-isearch "avy" "Jump to one of the current isearch candidates." t)(autoload 'avy-goto-word-0 "avy" "Jump to a word start.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\nBEG and END narrow the scope where candidates are searched.\n\n(fn ARG &optional BEG END)" t)(autoload 'avy-goto-whitespace-end "avy" "Jump to the end of a whitespace sequence.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\nBEG and END narrow the scope where candidates are searched.\n\n(fn ARG &optional BEG END)" t)(autoload 'avy-goto-word-1 "avy" "Jump to the currently visible CHAR at a word start.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\nBEG and END narrow the scope where candidates are searched.\nWhen SYMBOL is non-nil, jump to symbol start instead of word start.\n\n(fn CHAR &optional ARG BEG END SYMBOL)" t)(autoload 'avy-goto-word-1-above "avy" "Jump to the currently visible CHAR at a word start.\nThis is a scoped version of `avy-goto-word-1', where the scope is\nthe visible part of the current buffer up to point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-word-1-below "avy" "Jump to the currently visible CHAR at a word start.\nThis is a scoped version of `avy-goto-word-1', where the scope is\nthe visible part of the current buffer following point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-symbol-1 "avy" "Jump to the currently visible CHAR at a symbol start.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-symbol-1-above "avy" "Jump to the currently visible CHAR at a symbol start.\nThis is a scoped version of `avy-goto-symbol-1', where the scope is\nthe visible part of the current buffer up to point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-symbol-1-below "avy" "Jump to the currently visible CHAR at a symbol start.\nThis is a scoped version of `avy-goto-symbol-1', where the scope is\nthe visible part of the current buffer following point.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-subword-0 "avy" "Jump to a word or subword start.\nThe window scope is determined by `avy-all-windows' (ARG negates it).\n\nWhen PREDICATE is non-nil it's a function of zero parameters that\nshould return true.\n\nBEG and END narrow the scope where candidates are searched.\n\n(fn &optional ARG PREDICATE BEG END)" t)(autoload 'avy-goto-subword-1 "avy" "Jump to the currently visible CHAR at a subword start.\nThe window scope is determined by `avy-all-windows' (ARG negates it).\nThe case of CHAR is ignored.\n\n(fn CHAR &optional ARG)" t)(autoload 'avy-goto-word-or-subword-1 "avy" "Forward to `avy-goto-subword-1' or `avy-goto-word-1'.\nWhich one depends on variable `subword-mode'." t)(autoload 'avy-goto-line "avy" "Jump to a line start in current buffer.\n\nWhen ARG is 1, jump to lines currently visible, with the option\nto cancel to `goto-line' by entering a number.\n\nWhen ARG is 4, negate the window scope determined by\n`avy-all-windows'.\n\nOtherwise, forward to `goto-line' with ARG.\n\n(fn &optional ARG)" t)(autoload 'avy-goto-line-above "avy" "Goto visible line above the cursor.\nOFFSET changes the distance between the closest key to the cursor and\nthe cursor\nWhen BOTTOM-UP is non-nil, display avy candidates from top to bottom\n\n(fn &optional OFFSET BOTTOM-UP)" t)(autoload 'avy-goto-line-below "avy" "Goto visible line below the cursor.\nOFFSET changes the distance between the closest key to the cursor and\nthe cursor\nWhen BOTTOM-UP is non-nil, display avy candidates from top to bottom\n\n(fn &optional OFFSET BOTTOM-UP)" t)(autoload 'avy-goto-end-of-line "avy" "Call `avy-goto-line' and move to the end of the line.\n\n(fn &optional ARG)" t)(autoload 'avy-copy-line "avy" "Copy a selected line above the current line.\nARG lines can be used.\n\n(fn ARG)" t)(autoload 'avy-move-line "avy" "Move a selected line above the current line.\nARG lines can be used.\n\n(fn ARG)" t)(autoload 'avy-copy-region "avy" "Select two lines and copy the text between them to point.\n\nThe window scope is determined by `avy-all-windows' or\n`avy-all-windows-alt' when ARG is non-nil.\n\n(fn ARG)" t)(autoload 'avy-move-region "avy" "Select two lines and move the text between them above the current line." t)(autoload 'avy-kill-region "avy" "Select two lines and kill the region between them.\n\nThe window scope is determined by `avy-all-windows' or\n`avy-all-windows-alt' when ARG is non-nil.\n\n(fn ARG)" t)(autoload 'avy-kill-ring-save-region "avy" "Select two lines and save the region between them to the kill ring.\nThe window scope is determined by `avy-all-windows'.\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\n\n(fn ARG)" t)(autoload 'avy-kill-whole-line "avy" "Select line and kill the whole selected line.\n\nWith a numerical prefix ARG, kill ARG line(s) starting from the\nselected line.  If ARG is negative, kill backward.\n\nIf ARG is zero, kill the selected line but exclude the trailing\nnewline.\n\n\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines\nstarting from the selected line.  \\[universal-argument] -3\n\n\\[avy-kill-whole-line] kill three lines backward including the\nselected line.\n\n(fn ARG)" t)(autoload 'avy-kill-ring-save-whole-line "avy" "Select line and save the whole selected line as if killed, but don\x2019t kill it.\n\nThis command is similar to `avy-kill-whole-line', except that it\nsaves the line(s) as if killed, but does not kill it(them).\n\nWith a numerical prefix ARG, kill ARG line(s) starting from the\nselected line.  If ARG is negative, kill backward.\n\nIf ARG is zero, kill the selected line but exclude the trailing\nnewline.\n\n(fn ARG)" t)(autoload 'avy-setup-default "avy" "Setup the default shortcuts.")(autoload 'avy-goto-char-timer "avy" "Read one or many consecutive chars and jump to the first one.\nThe window scope is determined by `avy-all-windows' (ARG negates it).\n\n(fn &optional ARG)" t)(autoload 'avy-transpose-lines-in-region "avy" "Transpose lines in the active region." t)(defalias 'org-babel-execute-src-block:async 'ob-async-org-babel-execute-src-block)(autoload 'ob-async-org-babel-execute-src-block "ob-async" "Like org-babel-execute-src-block, but run asynchronously.\n\nOriginal docstring for org-babel-execute-src-block:\n\nExecute the current source code block.  Insert the results of\nexecution into the buffer.  Source code execution and the\ncollection and formatting of results can be controlled through a\nvariety of header arguments.\n\nWith prefix argument ARG, force re-execution even if an existing\nresult cached in the buffer would otherwise have been returned.\n\nOptionally supply a value for INFO in the form returned by\n`org-babel-get-src-block-info'.\n\nOptionally supply a value for PARAMS which will be merged with\nthe header arguments specified at the front of the source code\nblock.\n\n(fn &optional ORIG-FUN ARG INFO PARAMS)" t)(autoload 'async-start-process "async" "Start the executable PROGRAM asynchronously named NAME.  See `async-start'.\nPROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the\nprocess object when done.  If FINISH-FUNC is nil, the future\nobject will return the process object when the program is\nfinished.  Set DEFAULT-DIRECTORY to change PROGRAM's current\nworking directory.\n\n(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)")(autoload 'async-start "async" "Execute START-FUNC (often a lambda) in a subordinate Emacs process.\nWhen done, the return value is passed to FINISH-FUNC.  Example:\n\n    (async-start\n       ;; What to do in the child process\n       (lambda ()\n         (message \"This is a test\")\n         (sleep-for 3)\n         222)\n\n       ;; What to do when it finishes\n       (lambda (result)\n         (message \"Async process done, result should be 222: %s\"\n                  result)))\n\nIf you call `async-send' from a child process, the message will\nbe also passed to the FINISH-FUNC.  You can test RESULT to see if\nit is a message by using `async-message-p'.  If nil, it means\nthis is the final result.  Example of the FINISH-FUNC:\n\n    (lambda (result)\n      (if (async-message-p result)\n          (message \"Received a message from child process: %s\" result)\n        (message \"Async process done, result: %s\" result)))\n\nIf FINISH-FUNC is nil or missing, a future is returned that can\nbe inspected using `async-get', blocking until the value is\nready.  Example:\n\n    (let ((proc (async-start\n                   ;; What to do in the child process\n                   (lambda ()\n                     (message \"This is a test\")\n                     (sleep-for 3)\n                     222))))\n\n        (message \"I'm going to do some work here\") ;; ....\n\n        (message \"Waiting on async process, result should be 222: %s\"\n                 (async-get proc)))\n\nIf you don't want to use a callback, and you don't care about any\nreturn value from the child process, pass the `ignore' symbol as\nthe second argument (if you don't, and never call `async-get', it\nwill leave *emacs* process buffers hanging around):\n\n    (async-start\n     (lambda ()\n       (delete-file \"a remote file on a slow link\" nil))\n     \\='ignore)\n\nSpecial case:\nIf the output of START-FUNC is a string with properties\ne.g. (buffer-string) RESULT will be transformed in a list where the\ncar is the string itself (without props) and the cdr the rest of\nproperties, this allows using in FINISH-FUNC the string without\nproperties and then apply the properties in cdr to this string (if\nneeded).\nProperties handling special objects like markers are returned as\nlist to allow restoring them later.\nSee <https://github.com/jwiegley/emacs-async/issues/145> for more infos.\n\nNote: Even when FINISH-FUNC is present, a future is still\nreturned except that it yields no value (since the value is\npassed to FINISH-FUNC).  Call `async-get' on such a future always\nreturns nil.  It can still be useful, however, as an argument to\n`async-ready' or `async-wait'.\n\n(fn START-FUNC &optional FINISH-FUNC)")(autoload 'async-byte-recompile-directory "async-bytecomp" "Compile all *.el files in DIRECTORY asynchronously.\nAll *.elc files are systematically deleted before proceeding.\n\n(fn DIRECTORY &optional QUIET)")(defvar async-bytecomp-package-mode nil "Non-nil if Async-Bytecomp-Package mode is enabled.\nSee the `async-bytecomp-package-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `async-bytecomp-package-mode'.")(autoload 'async-bytecomp-package-mode "async-bytecomp" "Byte compile asynchronously packages installed with package.el.\n\nAsync compilation of packages can be controlled by\n`async-bytecomp-allowed-packages'.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Async-Bytecomp-Package mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='async-bytecomp-package-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'async-byte-compile-file "async-bytecomp" "Byte compile Lisp code FILE asynchronously.\n\nSame as `byte-compile-file' but asynchronous.\n\n(fn FILE)" t)(defvar dired-async-mode nil "Non-nil if Dired-Async mode is enabled.\nSee the `dired-async-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `dired-async-mode'.")(autoload 'dired-async-mode "dired-async" "Do dired actions asynchronously.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Dired-Async mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='dired-async-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dired-async-do-copy "dired-async" "Run \x2018\ dired-do-copy\x2019 asynchronously.\n\n(fn &optional ARG)" t)(autoload 'dired-async-do-symlink "dired-async" "Run \x2018\ dired-do-symlink\x2019 asynchronously.\n\n(fn &optional ARG)" t)(autoload 'dired-async-do-hardlink "dired-async" "Run \x2018\ dired-do-hardlink\x2019 asynchronously.\n\n(fn &optional ARG)" t)(autoload 'dired-async-do-rename "dired-async" "Run \x2018\ dired-do-rename\x2019 asynchronously.\n\n(fn &optional ARG)" t)(autoload 'org-babel-execute-safely-maybe "ob-core" "Maybe `org-babel-execute-maybe'.\nThis function does nothing unless `org-babel-no-eval-on-ctrl-c-ctrl-c'\nis non-nil.")(autoload 'org-babel-execute-maybe "ob-core" "Execute src block or babel call at point." t)(autoload 'org-babel-view-src-block-info "ob-core" "Display information on the current source block.\nThis includes header arguments, language and name, and is largely\na window into the `org-babel-get-src-block-info' function." t)(autoload 'org-babel-expand-src-block-maybe "ob-core" "Conditionally expand a source block.\nDetect if this is context for an org-babel src-block and if so\nthen run `org-babel-expand-src-block'." t)(autoload 'org-babel-load-in-session-maybe "ob-core" "Conditionally load a source block in a session.\nDetect if this is context for an org-babel src-block and if so\nthen run `org-babel-load-in-session'." t)(autoload 'org-babel-pop-to-session-maybe "ob-core" "Conditionally pop to a session.\nDetect if this is context for an org-babel src-block and if so\nthen run `org-babel-switch-to-session'." t)(autoload 'org-babel-execute-src-block "ob-core" "Execute the current source code block and return the result.\nInsert the results of execution into the buffer.  Source code\nexecution and the collection and formatting of results can be\ncontrolled through a variety of header arguments.\n\nWith prefix argument ARG, force re-execution even if an existing\nresult cached in the buffer would otherwise have been returned.\n\nOptionally supply a value for INFO in the form returned by\n`org-babel-get-src-block-info'.\n\nOptionally supply a value for PARAMS which will be merged with\nthe header arguments specified at the front of the source code\nblock.\n\nEXECUTOR-TYPE is the type of the org element responsible for the\nexecution of the source block.  If not provided then informed\nguess will be made.\n\n(fn &optional ARG INFO PARAMS EXECUTOR-TYPE)" t)(autoload 'org-babel-expand-src-block "ob-core" "Expand the current source code block or block specified by INFO.\nINFO is the output of `org-babel-get-src-block-info'.\nPARAMS defines inherited header arguments.\n\nExpand according to the source code block's header\narguments and pop open the results in a preview buffer.\n\n(fn &optional ARG INFO PARAMS)" t)(autoload 'org-babel-check-src-block "ob-core" "Check for misspelled header arguments in the current code block." t)(autoload 'org-babel-insert-header-arg "ob-core" "Insert a header argument and its value.\nHEADER-ARG and VALUE, when provided, are the header argument name and\nits value.  When HEADER-ARG or VALUE are nil, offer interactive\ncompletion from lists of common args and values.\n\n(fn &optional HEADER-ARG VALUE)" t)(autoload 'org-babel-load-in-session "ob-core" "Load the body of the current source-code block.\nWhen optional argument INFO is non-nil, use source block defined in\nINFO, as returned by `org-babel-get-src-block-info'.\n\nEvaluate the header arguments for the source block before\nentering the session.  After loading the body this pops open the\nsession.\n\n(fn &optional ARG INFO)" t)(autoload 'org-babel-initiate-session "ob-core" "Initiate session for current code block or the block defined by INFO.\nIf called with a prefix argument ARG, then resolve any variable\nreferences in the header arguments and assign these variables in\nthe session.  Copy the body of the code block to the kill ring.\n\n(fn &optional ARG INFO)" t)(autoload 'org-babel-switch-to-session "ob-core" "Switch to the session of the current code block or block defined by INFO.\nUses `org-babel-initiate-session' to start the session.  If called\nwith a prefix argument ARG, then this is passed on to\n`org-babel-initiate-session'.\n\n(fn &optional ARG INFO)" t)(autoload 'org-babel-switch-to-session-with-code "ob-core" "Switch to code buffer and display session.\nPrefix argument ARG is passed to `org-babel-switch-to-session'.\n\n(fn &optional ARG INFO)" t)(autoload 'org-babel-do-in-edit-buffer "ob-core" "Evaluate BODY in edit buffer if there is a code block at point.\nReturn t if a code block was found at point, nil otherwise.\n\n(fn &rest BODY)" nil t)(autoload 'org-babel-open-src-block-result "ob-core" "Open results of source block at point.\n\nIf `point' is on a source block then open the results of the source\ncode block, otherwise return nil.  With optional prefix argument\nRE-RUN the source-code block is evaluated even if results already\nexist.\n\n(fn &optional RE-RUN)" t)(autoload 'org-babel-map-src-blocks "ob-core" "Evaluate BODY forms on each source-block in FILE.\nIf FILE is nil evaluate BODY forms on source blocks in current\nbuffer.  During evaluation of BODY the following local variables\nare set relative to the currently matched code block.\n\nfull-block ------- string holding the entirety of the code block\nbeg-block -------- point at the beginning of the code block\nend-block -------- point at the end of the matched code block\nlang ------------- string holding the language of the code block\nbeg-lang --------- point at the beginning of the lang\nend-lang --------- point at the end of the lang\nswitches --------- string holding the switches\nbeg-switches ----- point at the beginning of the switches\nend-switches ----- point at the end of the switches\nheader-args ------ string holding the header-args\nbeg-header-args -- point at the beginning of the header-args\nend-header-args -- point at the end of the header-args\nbody ------------- string holding the body of the code block\nbeg-body --------- point at the beginning of the body\nend-body --------- point at the end of the body\n\n(fn FILE &rest BODY)" nil t)(function-put 'org-babel-map-src-blocks 'lisp-indent-function 1)(autoload 'org-babel-map-inline-src-blocks "ob-core" "Evaluate BODY forms on each inline source block in FILE.\nIf FILE is nil evaluate BODY forms on source blocks in current\nbuffer.\n\n(fn FILE &rest BODY)" nil t)(function-put 'org-babel-map-inline-src-blocks 'lisp-indent-function 1)(autoload 'org-babel-map-call-lines "ob-core" "Evaluate BODY forms on each call line in FILE.\nIf FILE is nil evaluate BODY forms on source blocks in current\nbuffer.\n\n(fn FILE &rest BODY)" nil t)(function-put 'org-babel-map-call-lines 'lisp-indent-function 1)(autoload 'org-babel-map-executables "ob-core" "Evaluate BODY forms on each active Babel code in FILE.\nIf FILE is nil evaluate BODY forms on source blocks in current\nbuffer.\n\n(fn FILE &rest BODY)" nil t)(function-put 'org-babel-map-executables 'lisp-indent-function 1)(autoload 'org-babel-execute-buffer "ob-core" "Execute source code blocks in a buffer.\nPrefix argument ARG is passed to `org-babel-execute-src-block'.\nCall `org-babel-execute-src-block' on every source block in\nthe current buffer.\n\n(fn &optional ARG)" t)(autoload 'org-babel-execute-subtree "ob-core" "Execute source code blocks in a subtree.\nCall `org-babel-execute-src-block' on every source block in\nthe current subtree, passing over the prefix argument ARG.\n\n(fn &optional ARG)" t)(autoload 'org-babel-sha1-hash "ob-core" "Generate a sha1 hash based on the value of INFO.\nCONTEXT specifies the context of evaluation.  It can be `:eval',\n`:export', `:tangle'.  A nil value means `:eval'.\n\n(fn &optional INFO CONTEXT)" t)(autoload 'org-babel-hide-result-toggle-maybe "ob-core" "Toggle visibility of result at point." t)(autoload 'org-babel-goto-src-block-head "ob-core" "Go to the beginning of the current code block." t)(autoload 'org-babel-goto-named-src-block "ob-core" "Go to a source-code block with NAME.\n\n(fn NAME)" t)(autoload 'org-babel-goto-named-result "ob-core" "Go to a result with NAME.\n\n(fn NAME)" t)(autoload 'org-babel-next-src-block "ob-core" "Jump to the next source block.\nWith optional prefix argument ARG, jump forward ARG many source blocks.\n\n(fn &optional ARG)" t)(autoload 'org-babel-previous-src-block "ob-core" "Jump to the previous source block.\nWith optional prefix argument ARG, jump backward ARG many source blocks.\n\n(fn &optional ARG)" t)(autoload 'org-babel-mark-block "ob-core" "Mark current source block." t)(autoload 'org-babel-lob-execute-maybe "ob-lob" "Execute a Library of Babel source block, if appropriate.\nDetect if this is context for a Library Of Babel source block and\nif so then run the appropriate source block from the Library." t)(autoload 'org-babel-lob-get-info "ob-lob" "Return internal representation for Library of Babel function call.\n\nConsider DATUM, when provided, or element at point otherwise.\n\nWhen optional argument NO-EVAL is non-nil, Babel does not resolve\nremote variable references; a process which could likely result\nin the execution of other code blocks, and do not evaluate Lisp\nvalues in parameters.\n\nReturn nil when not on an appropriate location.  Otherwise return\na list compatible with `org-babel-get-src-block-info', which\nsee.\n\n(fn &optional DATUM NO-EVAL)")(autoload 'org-babel-tangle-file "ob-tangle" "Extract the bodies of source code blocks in FILE.\nSource code blocks are extracted with `org-babel-tangle'.\n\nOptional argument TARGET-FILE can be used to specify a default\nexport file for all source blocks.\n\nOptional argument LANG-RE can be used to limit the exported\nsource code blocks by languages matching a regular expression.\n\nReturn list of the tangled file names.\n\n(fn FILE &optional TARGET-FILE LANG-RE)" t)(autoload 'org-babel-tangle "ob-tangle" "Write code blocks to source-specific files.\nExtract the bodies of all source code blocks from the current\nfile into their own source-specific files.  Return the list of files.\nWith one universal prefix argument, only tangle the block at point.\nWhen two universal prefix arguments, only tangle blocks for the\ntangle file of the block at point.\nOptional argument TARGET-FILE can be used to specify a default\nexport file for all source blocks.  Optional argument LANG-RE can\nbe used to limit the exported source code blocks by languages\nmatching a regular expression.\n\n(fn &optional ARG TARGET-FILE LANG-RE)" t)(autoload 'org-cite-insert "oc" "Insert a citation at point.\nInsertion is done according to the processor set in `org-cite-insert-processor'.\nARG is the prefix argument received when calling interactively the function.\n\n(fn ARG)" t)(autoload 'org-next-link "ol" "Move forward to the next link.\nIf the link is in hidden text, expose it.  When SEARCH-BACKWARD\nis non-nil, move backward.\n\n(fn &optional SEARCH-BACKWARD)" t)(autoload 'org-previous-link "ol" "Move backward to the previous link.\nIf the link is in hidden text, expose it." t)(autoload 'org-toggle-link-display "ol" "Toggle the literal or descriptive display of links in current buffer." t)(autoload 'org-store-link "ol" "Store a link to the current location.\n\\<org-mode-map>\nThis link is added to `org-stored-links' and can later be inserted\ninto an Org buffer with `org-insert-link' (`\\[org-insert-link]').\nWhen optional argument INTERACTIVE? is nil, the link is not stored in\n`org-stored-links', but returned as a string.\n\nFor some link types, a `\\[universal-argument]' prefix ARG is interpreted.  A single\n`\\[universal-argument]' negates `org-link-context-for-files' for file links or\n`org-gnus-prefer-web-links' for links to Usenet articles.\n\nA `\\[universal-argument] \\[universal-argument]' prefix ARG forces skipping storing functions that are not\npart of Org core.\n\nA `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix ARG forces storing a link for each line in the\nactive region.\n\nAssume the function is called interactively if INTERACTIVE? is\nnon-nil.\n\nIn Org buffers, an additional \"human-readable\" simple file link\nis stored as an alternative to persistent org-id or other links,\nif at a heading with a CUSTOM_ID property or an element with a\nNAME.\n\n(fn ARG &optional INTERACTIVE?)" t)(autoload 'org-insert-link "ol" "Insert a link.  At the prompt, enter the link.\n\nCompletion can be used to insert any of the link protocol prefixes in use.\n\nThe history can be used to select a link previously stored with\n`org-store-link'.  When the empty string is entered (i.e. if you just\npress `RET' at the prompt), the link defaults to the most recently\nstored link.  As `SPC' triggers completion in the minibuffer, you need to\nuse `M-SPC' or `C-q SPC' to force the insertion of a space character.\nCompletion candidates include link descriptions.\n\nIf there is a link under cursor then edit it.\n\nYou will also be prompted for a description, and if one is given, it will\nbe displayed in the buffer instead of the link.\n\nIf there is already a link at point, this command will allow you to edit\nlink and description parts.\n\nWith a `\\[universal-argument]' prefix, prompts for a file to link to.  The file name can be\nselected using completion.  The path to the file will be relative to the\ncurrent directory if the file is in the current directory or a subdirectory.\nOtherwise, the link will be the absolute path as completed in the minibuffer\n(i.e. normally ~/path/to/file).  You can configure this behavior using the\noption `org-link-file-path-type'.\n\nWith a `\\[universal-argument] \\[universal-argument]' prefix, enforce an absolute path even if the file is in\nthe current directory or below.\n\nA `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix negates `org-link-keep-stored-after-insertion'.\n\nIf the LINK-LOCATION parameter is non-nil, this value will be used as\nthe link location instead of reading one interactively.\n\nIf the DESCRIPTION parameter is non-nil, this value will be used\nas the default description.  If not, and the chosen link type has\na non-nil `:insert-description' parameter, that is used to\ngenerate a description as described in `org-link-parameters'\ndocstring.  Otherwise, if `org-link-make-description-function' is\nnon-nil, this function will be called with the link target, and\nthe result will be the default link description.  When called\nnon-interactively, don't allow editing the default description.\n\n(fn &optional COMPLETE-FILE LINK-LOCATION DESCRIPTION)" t)(autoload 'org-insert-all-links "ol" "Insert all links in `org-stored-links'.\nWhen a universal prefix, do not delete the links from `org-stored-links'.\nWhen `ARG' is a number, insert the last N link(s).\n`PRE' and `POST' are optional arguments to define a string to\nprepend or to append.\n\n(fn ARG &optional PRE POST)" t)(autoload 'org-insert-last-stored-link "ol" "Insert the last link stored in `org-stored-links'.\n\n(fn ARG)" t)(autoload 'org-insert-link-global "ol" "Insert a link like Org mode does.\nThis command can be called in any mode to insert a link in Org syntax." t)(autoload 'org-update-radio-target-regexp "ol" "Find all radio targets in this file and update the regular expression.\nAlso refresh fontification if needed." t)(autoload 'org-bbdb-anniversaries "ol-bbdb" "Extract anniversaries from BBDB for display in the agenda.\nWhen called programmatically, this function expects the `date'\nvariable to be globally bound.")(autoload 'org-irc-store-link "ol-irc" "Dispatch to the appropriate function to store a link to an IRC session.\n\n(fn &optional INTERACTIVE?)")(autoload 'org-babel-do-load-languages "org" "Load the languages defined in `org-babel-load-languages'.\n\n(fn SYM VALUE)")(autoload 'org-babel-load-file "org" "Load Emacs Lisp source code blocks in the Org FILE.\nThis function exports the source code using `org-babel-tangle'\nand then loads the resulting file using `load-file'.  With\noptional prefix argument COMPILE, the tangled Emacs Lisp file is\nbyte-compiled before it is loaded.\n\n(fn FILE &optional COMPILE)" t)(autoload 'org-version "org" "Show the Org version.\nInteractively, or when MESSAGE is non-nil, show it in echo area.\nWith prefix argument, or when HERE is non-nil, insert it at point.\nIn non-interactive uses, a reduced version string is output unless\nFULL is given.\n\n(fn &optional HERE FULL MESSAGE)" t)(autoload 'org-load-modules-maybe "org" "Load all extensions listed in `org-modules'.\n\n(fn &optional FORCE)")(autoload 'org-clock-persistence-insinuate "org" "Set up hooks for clock persistence.")(autoload 'org-mode "org" "Outline-based notes management and organizer, alias\n\"Carsten's outline-mode for keeping track of everything.\"\n\nOrg mode develops organizational tasks around a NOTES file which\ncontains information about projects as plain text.  Org mode is\nimplemented on top of Outline mode, which is ideal to keep the content\nof large files well structured.  It supports ToDo items, deadlines and\ntime stamps, which magically appear in the diary listing of the Emacs\ncalendar.  Tables are easily created with a built-in table editor.\nPlain text URL-like links connect to websites, emails (VM), Usenet\nmessages (Gnus), BBDB entries, and any files related to the project.\nFor printing and sharing of notes, an Org file (or a part of it)\ncan be exported as a structured ASCII or HTML file.\n\nThe following commands are available:\n\n\\{org-mode-map}\n\n(fn)" t)(autoload 'org-run-like-in-org-mode "org" "Run a command, pretending that the current buffer is in Org mode.\nThis will temporarily bind local variables that are typically bound in\nOrg mode to the values they have in Org mode, and then interactively\ncall CMD.\n\n(fn CMD)")(autoload 'org-open-file "org" "Open the file at PATH.\nFirst, this expands any special file name abbreviations.  Then the\nconfiguration variable `org-file-apps' is checked if it contains an\nentry for this file type, and if yes, the corresponding command is launched.\n\nIf no application is found, Emacs simply visits the file.\n\nWith optional prefix argument IN-EMACS, Emacs will visit the file.\nWith a double \\[universal-argument] \\[universal-argument] prefix arg, Org tries to avoid opening in Emacs\nand to use an external application to visit the file.\n\nOptional LINE specifies a line to go to, optional SEARCH a string\nto search for.  If LINE or SEARCH is given, the file will be\nopened in Emacs, unless an entry from `org-file-apps' that makes\nuse of groups in a regexp matches.\n\nIf you want to change the way frames are used when following a\nlink, please customize `org-link-frame-setup'.\n\nIf the file does not exist, throw an error.\n\n(fn PATH &optional IN-EMACS LINE SEARCH)")(autoload 'org-open-at-point-global "org" "Follow a link or a timestamp like Org mode does.\nAlso follow links and emails as seen by `thing-at-point'.\nThis command can be called in any mode to follow an external\nlink or a timestamp that has Org mode syntax.  Its behavior\nis undefined when called on internal links like fuzzy links.\nRaise a user error when there is nothing to follow." t)(autoload 'org-offer-links-in-entry "org" "Offer links in the current entry and return the selected link.\nIf there is only one link, return it.\nIf NTH is an integer, return the NTH link found.\nIf ZERO is a string, check also this string for a link, and if\nthere is one, return it.\n\n(fn BUFFER MARKER &optional NTH ZERO)")(autoload 'org-switchb "org" "Switch between Org buffers.\n\nWith `\\[universal-argument]' prefix, restrict available buffers to files.\n\nWith `\\[universal-argument] \\[universal-argument]' prefix, restrict available buffers to agenda files.\n\n(fn &optional ARG)" t)(autoload 'org-cycle-agenda-files "org" "Cycle through the files in `org-agenda-files'.\nIf the current buffer visits an agenda file, find the next one in the list.\nIf the current buffer does not, find the first agenda file." t)(autoload 'org-submit-bug-report "org" "Submit a bug report on Org via mail.\n\nDon't hesitate to report any problems or inaccurate documentation.\n\nIf you don't have setup sending mail from (X)Emacs, please copy the\noutput buffer into your mail program, as it gives us important\ninformation about your Org version and configuration." t)(autoload 'org-reload "org" "Reload all Org Lisp files.\nWith prefix arg UNCOMPILED, load the uncompiled versions.\n\n(fn &optional UNCOMPILED)" t)(autoload 'org-customize "org" "Call the customize function with org as argument." t)(autoload 'org-toggle-sticky-agenda "org-agenda" "Toggle `org-agenda-sticky'.\n\n(fn &optional ARG)" t)(autoload 'org-agenda "org-agenda" "Dispatch agenda commands to collect entries to the agenda buffer.\nPrompts for a command to execute.  Any prefix arg will be passed\non to the selected command.  The default selections are:\n\na     Call `org-agenda-list' to display the agenda for current day or week.\nt     Call `org-todo-list' to display the global todo list.\nT     Call `org-todo-list' to display the global todo list, select only\n      entries with a specific TODO keyword (the user gets a prompt).\nm     Call `org-tags-view' to display headlines with tags matching\n      a condition  (the user is prompted for the condition).\nM     Like `m', but select only TODO entries, no ordinary headlines.\ne     Export views to associated files.\ns     Search entries for keywords.\nS     Search entries for keywords, only with TODO keywords.\n/     Multi occur across all agenda files and also files listed\n      in `org-agenda-text-search-extra-files'.\n<     Restrict agenda commands to buffer, subtree, or region.\n      Press several times to get the desired effect.\n>     Remove a previous restriction.\n#     List \"stuck\" projects.\n!     Configure what \"stuck\" means.\nC     Configure custom agenda commands.\n\nMore commands can be added by configuring the variable\n`org-agenda-custom-commands'.  In particular, specific tags and TODO keyword\nsearches can be pre-defined in this way.\n\nIf the current buffer is in Org mode and visiting a file, you can also\nfirst press `<' once to indicate that the agenda should be temporarily\n(until the next use of `\\[org-agenda]') restricted to the current file.\nPressing `<' twice means to restrict to the current subtree or region\n(if active).\n\n(fn &optional ARG KEYS RESTRICTION)" t)(autoload 'org-batch-agenda "org-agenda" "Run an agenda command in batch mode and send the result to STDOUT.\nIf CMD-KEY is a string of length 1, it is used as a key in\n`org-agenda-custom-commands' and triggers this command.  If it is a\nlonger string it is used as a tags/todo match string.\nParameters are alternating variable names and values that will be bound\nbefore running the agenda command.\n\n(fn CMD-KEY &rest PARAMETERS)" nil t)(autoload 'org-batch-agenda-csv "org-agenda" "Run an agenda command in batch mode and send the result to STDOUT.\nIf CMD-KEY is a string of length 1, it is used as a key in\n`org-agenda-custom-commands' and triggers this command.  If it is a\nlonger string it is used as a tags/todo match string.\nParameters are alternating variable names and values that will be bound\nbefore running the agenda command.\n\nThe output gives a line for each selected agenda item.  Each\nitem is a list of comma-separated values, like this:\n\ncategory,head,type,todo,tags,date,time,extra,priority-l,priority-n\n\ncategory     The category of the item\nhead         The headline, without TODO kwd, TAGS and PRIORITY\ntype         The type of the agenda entry, can be\n                todo               selected in TODO match\n                tagsmatch          selected in tags match\n                diary              imported from diary\n                deadline           a deadline on given date\n                scheduled          scheduled on given date\n                timestamp          entry has timestamp on given date\n                closed             entry was closed on given date\n                upcoming-deadline  warning about deadline\n                past-scheduled     forwarded scheduled item\n                block              entry has date block including g. date\ntodo         The todo keyword, if any\ntags         All tags including inherited ones, separated by colons\ndate         The relevant date, like 2007-2-14\ntime         The time, like 15:00-16:50\nextra        String with extra planning info\npriority-l   The priority letter if any was given\npriority-n   The computed numerical priority\nagenda-day   The day in the agenda where this is listed\n\n(fn CMD-KEY &rest PARAMETERS)" nil t)(autoload 'org-store-agenda-views "org-agenda" "Store agenda views.\n\n(fn &rest PARAMETERS)" t)(autoload 'org-batch-store-agenda-views "org-agenda" "Run all custom agenda commands that have a file argument.\n\n(fn &rest PARAMETERS)" nil t)(autoload 'org-agenda-list "org-agenda" "Produce a daily/weekly view from all files in variable `org-agenda-files'.\nThe view will be for the current day or week, but from the overview buffer\nyou will be able to go to other days/weeks.\n\nWith a numeric prefix argument in an interactive call, the agenda will\nspan ARG days.  Lisp programs should instead specify SPAN to change\nthe number of days.  SPAN defaults to `org-agenda-span'.\n\nSTART-DAY defaults to TODAY, or to the most recent match for the weekday\ngiven in `org-agenda-start-on-weekday'.\n\nWhen WITH-HOUR is non-nil, only include scheduled and deadline\nitems if they have an hour specification like [h]h:mm.\n\n(fn &optional ARG START-DAY SPAN WITH-HOUR)" t)(autoload 'org-search-view "org-agenda" "Show all entries that contain a phrase or words or regular expressions.\n\nWith optional prefix argument TODO-ONLY, only consider entries that are\nTODO entries.  The argument STRING can be used to pass a default search\nstring into this function.  If EDIT-AT is non-nil, it means that the\nuser should get a chance to edit this string, with cursor at position\nEDIT-AT.\n\nThe search string can be viewed either as a phrase that should be found as\nis, or it can be broken into a number of snippets, each of which must match\nin a Boolean way to select an entry.  The default depends on the variable\n`org-agenda-search-view-always-boolean'.\nEven if this is turned off (the default) you can always switch to\nBoolean search dynamically by preceding the first word with  \"+\" or \"-\".\n\nThe default is a direct search of the whole phrase, where each space in\nthe search string can expand to an arbitrary amount of whitespace,\nincluding newlines.\n\nIf using a Boolean search, the search string is split on whitespace and\neach snippet is searched separately, with logical AND to select an entry.\nWords prefixed with a minus must *not* occur in the entry.  Words without\na prefix or prefixed with a plus must occur in the entry.  Matching is\ncase-insensitive.  Words are enclosed by word delimiters (i.e. they must\nmatch whole words, not parts of a word) if\n`org-agenda-search-view-force-full-words' is set (default is nil).\n\nBoolean search snippets enclosed by curly braces are interpreted as\nregular expressions that must or (when preceded with \"-\") must not\nmatch in the entry.  Snippets enclosed into double quotes will be taken\nas a whole, to include whitespace.\n\n- If the search string starts with an asterisk, search only in headlines.\n- If (possibly after the leading star) the search string starts with an\n  exclamation mark, this also means to look at TODO entries only, an effect\n  that can also be achieved with a prefix argument.\n- If (possibly after star and exclamation mark) the search string starts\n  with a colon, this will mean that the (non-regexp) snippets of the\n  Boolean search must match as full words.\n\nThis command searches the agenda files, and in addition the files\nlisted in `org-agenda-text-search-extra-files' unless a restriction lock\nis active.\n\n(fn &optional TODO-ONLY STRING EDIT-AT)" t)(autoload 'org-todo-list "org-agenda" "Show all (not done) TODO entries from all agenda files in a single list.\nThe prefix arg can be used to select a specific TODO keyword and limit\nthe list to these.  When using `\\[universal-argument]', you will be prompted\nfor a keyword.  A numeric prefix directly selects the Nth keyword in\n`org-todo-keywords-1'.\n\n(fn &optional ARG)" t)(autoload 'org-tags-view "org-agenda" "Show all headlines for all `org-agenda-files' matching a TAGS criterion.\nThe prefix arg TODO-ONLY limits the search to TODO entries.\n\n(fn &optional TODO-ONLY MATCH)" t)(autoload 'org-agenda-list-stuck-projects "org-agenda" "Create agenda view for projects that are stuck.\nStuck projects are project that have no next actions.  For the definitions\nof what a project is and how to check if it stuck, customize the variable\n`org-stuck-projects'.\n\n(fn &rest IGNORE)" t)(autoload 'org-diary "org-agenda" "Return diary information from org files.\nThis function can be used in a \"sexp\" diary entry in the Emacs calendar.\nIt accesses org files and extracts information from those files to be\nlisted in the diary.  The function accepts arguments specifying what\nitems should be listed.  For a list of arguments allowed here, see the\nvariable `org-agenda-entry-types'.\n\nThe call in the diary file should look like this:\n\n   &%%(org-diary) ~/path/to/some/orgfile.org\n\nUse a separate line for each org file to check.  Or, if you omit the file name,\nall files listed in `org-agenda-files' will be checked automatically:\n\n   &%%(org-diary)\n\nIf you don't give any arguments (as in the example above), the default value\nof `org-agenda-entry-types' is used: (:deadline :scheduled :timestamp :sexp).\nSo the example above may also be written as\n\n   &%%(org-diary :deadline :timestamp :sexp :scheduled)\n\nThe function expects the lisp variables `entry' and `date' to be provided\nby the caller, because this is how the calendar works.  Don't use this\nfunction from a program - use `org-agenda-get-day-entries' instead.\n\n(fn &rest ARGS)")(autoload 'org-agenda-check-for-timestamp-as-reason-to-ignore-todo-item "org-agenda" "Do we have a reason to ignore this TODO entry because it has a time stamp?\n\n(fn &optional END)")(autoload 'org-agenda-set-restriction-lock "org-agenda" "Set restriction lock for agenda to current subtree or file.\nWhen in a restricted subtree, remove it.\n\nThe restriction will span over the entire file if TYPE is `file',\nor if TYPE is (4), or if the cursor is before the first headline\nin the file.  Otherwise, only apply the restriction to the current\nsubtree.\n\n(fn &optional TYPE)" t)(autoload 'org-calendar-goto-agenda "org-agenda" "Compute the Org agenda for the calendar date displayed at the cursor.\nThis is a command that has to be installed in `calendar-mode-map'." t)(autoload 'org-agenda-to-appt "org-agenda" "Activate appointments found in `org-agenda-files'.\n\nWith a `\\[universal-argument]' prefix, refresh the list of appointments.\n\nIf FILTER is t, interactively prompt the user for a regular\nexpression, and filter out entries that don't match it.\n\nIf FILTER is a string, use this string as a regular expression\nfor filtering entries out.\n\nIf FILTER is a function, filter out entries against which\ncalling the function returns nil.  This function takes one\nargument: an entry from `org-agenda-get-day-entries'.\n\nFILTER can also be an alist with the car of each cell being\neither `headline' or `category'.  For example:\n\n   ((headline \"IMPORTANT\")\n    (category \"Work\"))\n\nwill only add headlines containing IMPORTANT or headlines\nbelonging to the \"Work\" category.\n\nARGS are symbols indicating what kind of entries to consider.\nBy default `org-agenda-to-appt' will use :deadline*, :scheduled*\n(i.e., deadlines and scheduled items with a hh:mm specification)\nand :timestamp entries.  See the docstring of `org-diary' for\ndetails and examples.\n\nIf an entry has a APPT_WARNTIME property, its value will be used\nto override `appt-message-warning-time'.\n\n(fn &optional REFRESH FILTER &rest ARGS)" t)(autoload 'org-add-archive-files "org-archive" "Splice the archive FILES into the list of files.\nThis implies visiting all these files and finding out what the\narchive file is.\n\n(fn FILES)")(autoload 'org-archive-subtree "org-archive" "Move the current subtree to the archive.\nThe archive can be a certain top-level heading in the current\nfile, or in a different file.  The tree will be moved to that\nlocation, the subtree heading be marked DONE, and the current\ntime will be added.\n\nWhen called with a single prefix argument FIND-DONE, find whole\ntrees without any open TODO items and archive them (after getting\nconfirmation from the user).  When called with a double prefix\nargument, find whole trees with timestamps before today and\narchive them (after getting confirmation from the user).  If the\ncursor is not at a headline when these commands are called, try\nall level 1 trees.  If the cursor is on a headline, only try the\ndirect children of this heading.\n\n(fn &optional FIND-DONE)" t)(autoload 'org-archive-to-archive-sibling "org-archive" "Archive the current heading by moving it under the archive sibling.\n\nThe archive sibling is a sibling of the heading with the heading name\n`org-archive-sibling-heading' and an `org-archive-tag' tag.  If this\nsibling does not exist, it will be created at the end of the subtree.\n\nArchiving time is retained in the ARCHIVE_TIME node property." t)(autoload 'org-toggle-archive-tag "org-archive" "Toggle the archive tag for the current headline.\nWith prefix argument FIND-DONE, check all children of current headline\nand offer tagging the children that do not contain any open TODO\nitems.\n\n(fn &optional FIND-DONE)" t)(autoload 'org-archive-subtree-default "org-archive" "Archive the current subtree with the default command.\nThis command is set with the variable `org-archive-default-command'." t)(autoload 'org-archive-subtree-default-with-confirmation "org-archive" "Archive the current subtree with the default command.\nThis command is set with the variable `org-archive-default-command'." t)(autoload 'org-attach "org-attach" "The dispatcher for attachment commands.\nShows a list of commands and prompts for another key to execute a command." t)(autoload 'org-attach-dir "org-attach" "Return the directory associated with the current outline node.\nFirst check for DIR property, then ID property.\n`org-attach-use-inheritance' determines whether inherited\nproperties also will be considered.\n\nIf an ID property is found the default mechanism using that ID\nwill be invoked to access the directory for the current entry.\nNote that this method returns the directory as declared by ID or\nDIR even if the directory doesn't exist in the filesystem.\n\nIf CREATE-IF-NOT-EXISTS-P is non-nil, `org-attach-dir-get-create'\nis run.  If NO-FS-CHECK is non-nil, the function returns the path\nto the attachment even if it has not yet been initialized in the\nfilesystem.\n\nIf no attachment directory can be derived, return nil.\n\n(fn &optional CREATE-IF-NOT-EXISTS-P NO-FS-CHECK)")(autoload 'org-attach-dired-to-subtree "org-attach" "Attach FILES marked or current file in `dired' to subtree in other window.\nTakes the method given in `org-attach-method' for the attach action.\nPrecondition: Point must be in a `dired' buffer.\nIdea taken from `gnus-dired-attach'.\n\n(fn FILES)" t)(autoload 'org-capture-string "org-capture" "Capture STRING with the template selected by KEYS.\n\n(fn STRING &optional KEYS)" t)(autoload 'org-capture "org-capture" "Capture something.\n\\<org-capture-mode-map>\nThis will let you select a template from `org-capture-templates', and\nthen file the newly captured information.  The text is immediately\ninserted at the target location, and an indirect buffer is shown where\nyou can edit it.  Pressing `\\[org-capture-finalize]' brings you back to the previous\nstate of Emacs, so that you can continue your work.\n\nWhen called interactively with a `\\[universal-argument]' prefix argument GOTO, don't\ncapture anything, just go to the file/headline where the selected\ntemplate stores its notes.\n\nWith a `\\[universal-argument] \\[universal-argument]' prefix argument, go to the last note stored.\n\nWhen called with a `C-0' (zero) prefix, insert a template at point.\n\nWhen called with a `C-1' (one) prefix, force prompting for a date when\na datetree entry is made.\n\nELisp programs can set KEYS to a string associated with a template\nin `org-capture-templates'.  In this case, interactive selection\nwill be bypassed.\n\nIf `org-capture-use-agenda-date' is non-nil, capturing from the\nagenda will use the date at point as the default date.  Then, a\n`C-1' prefix will tell the capture process to use the HH:MM time\nof the day at point (if any) or the current HH:MM time.\n\n(fn &optional GOTO KEYS)" t)(autoload 'org-capture-import-remember-templates "org-capture" "Set `org-capture-templates' to be similar to `org-remember-templates'." t)(autoload 'org-clock-modify-effort-estimate "org-clock" "Add to or set the effort estimate of the item currently being clocked.\nVALUE can be a number of minutes, or a string with format hh:mm or mm.\nWhen the string starts with a + or a - sign, the current value of the effort\nproperty will be changed by that amount.  If the effort value is expressed\nas an unit defined in `org-duration-units' (e.g. \"3h\"), the modified\nvalue will be converted to a hh:mm duration.\n\nThis command will update the \"Effort\" property of the currently\nclocked item, and the value displayed in the mode line.\n\n(fn &optional VALUE)" t)(autoload 'org-resolve-clocks "org-clock" "Resolve all currently open Org clocks.\nIf `only-dangling-p' is non-nil, only ask to resolve dangling\n(i.e., not currently open and valid) clocks.\n\n(fn &optional ONLY-DANGLING-P PROMPT-FN LAST-VALID)" t)(autoload 'org-clock-in "org-clock" "Start the clock on the current item.\n\nIf necessary, clock-out of the currently active clock.\n\nWith a `\\[universal-argument]' prefix argument SELECT, offer a list of recently clocked\ntasks to clock into.\n\nWhen SELECT is `\\[universal-argument] \\[universal-argument]', clock into the current task and mark it as\nthe default task, a special task that will always be offered in the\nclocking selection, associated with the letter `d'.\n\nWhen SELECT is `\\[universal-argument] \\[universal-argument] \\[universal-argument]', clock in by using the last clock-out\ntime as the start time.  See `org-clock-continuously' to make this\nthe default behavior.\n\n(fn &optional SELECT START-TIME)" t)(autoload 'org-clock-toggle-auto-clockout "org-clock" nil t)(autoload 'org-clock-in-last "org-clock" "Clock in the last closed clocked item.\nWhen already clocking in, send a warning.\nWith a universal prefix argument, select the task you want to\nclock in from the last clocked in tasks.\nWith two universal prefix arguments, start clocking using the\nlast clock-out time, if any.\nWith three universal prefix arguments, interactively prompt\nfor a todo state to switch to, overriding the existing value\n`org-clock-in-switch-to-state'.\n\n(fn &optional ARG)" t)(autoload 'org-clock-out "org-clock" "Stop the currently running clock.\nThrow an error if there is no running clock and FAIL-QUIETLY is nil.\nWith a universal prefix, prompt for a state to switch the clocked out task\nto, overriding the existing value of `org-clock-out-switch-to-state'.\n\n(fn &optional SWITCH-TO-STATE FAIL-QUIETLY AT-TIME)" t)(autoload 'org-clock-cancel "org-clock" "Cancel the running clock by removing the start timestamp." t)(autoload 'org-clock-goto "org-clock" "Go to the currently clocked-in entry, or to the most recently clocked one.\nWith prefix arg SELECT, offer recently clocked tasks for selection.\n\n(fn &optional SELECT)" t)(autoload 'org-clock-sum-today "org-clock" "Sum the times for each subtree for today.\n\n(fn &optional HEADLINE-FILTER)")(autoload 'org-clock-sum "org-clock" "Sum the times for each subtree.\nPuts the resulting times in minutes as a text property on each headline.\nTSTART and TEND can mark a time range to be considered.\nHEADLINE-FILTER is a zero-arg function that, if specified, is called for\neach headline in the time range with point at the headline.  Headlines for\nwhich HEADLINE-FILTER returns nil are excluded from the clock summation.\nPROPNAME lets you set a custom text property instead of :org-clock-minutes.\n\n(fn &optional TSTART TEND HEADLINE-FILTER PROPNAME)")(autoload 'org-clock-display "org-clock" "Show subtree times in the entire buffer.\n\nBy default, show the total time for the range defined in\n`org-clock-display-default-range'.  With `\\[universal-argument]' prefix, show\nthe total time for today instead.\n\nWith `\\[universal-argument] \\[universal-argument]' prefix, use a custom range, entered at prompt.\n\nWith `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix, display the total time in the\necho area.\n\nUse `\\[org-clock-remove-overlays]' to remove the subtree times.\n\n(fn &optional ARG)" t)(autoload 'org-clock-remove-overlays "org-clock" "Remove the occur highlights from the buffer.\nIf NOREMOVE is nil, remove this function from the\n`before-change-functions' in the current buffer.\n\n(fn &optional BEG END NOREMOVE)" t)(autoload 'org-clock-out-if-current "org-clock" "Clock out if the current entry contains the running clock.\nThis is used to stop the clock after a TODO entry is marked DONE,\nand is only done if the variable `org-clock-out-when-done' is not nil.")(autoload 'org-clock-get-clocktable "org-clock" "Get a formatted clocktable with parameters according to PROPS.\nThe table is created in a temporary buffer, fully formatted and\nfontified, and then returned.\n\n(fn &rest PROPS)")(autoload 'org-clock-report "org-clock" "Update or create a table containing a report about clocked time.\n\nIf point is inside an existing clocktable block, update it.\nOtherwise, insert a new one.\n\nThe new table inherits its properties from the variable\n`org-clock-clocktable-default-properties'.\n\nThe scope of the clocktable, when not specified in the previous\nvariable, is `subtree' of the current heading when the function is\ncalled from inside heading, and `file' elsewhere (before the first\nheading).\n\nWhen called with a prefix argument, move to the first clock table\nin the buffer and update it.\n\n(fn &optional ARG)" t)(eval-after-load 'org '(progn (org-dynamic-block-define "clocktable" #'org-clock-report)))(autoload 'org-clocktable-shift "org-clock" "Try to shift the :block date of the clocktable at point.\nPoint must be in the #+BEGIN: line of a clocktable, or this function\nwill throw an error.\nDIR is a direction, a symbol `left', `right', `up', or `down'.\nBoth `left' and `down' shift the block toward the past, `up' and `right'\npush it toward the future.\nN is the number of shift steps to take.  The size of the step depends on\nthe currently selected interval size.\n\n(fn DIR N)")(autoload 'org-dblock-write:clocktable "org-clock" "Write the standard clocktable.\n\n(fn PARAMS)")(autoload 'org-clock-update-time-maybe "org-clock" "If this is a CLOCK line, update it and return t.\nOtherwise, return nil." t)(autoload 'org-columns-remove-overlays "org-colview" "Remove all currently active column overlays." t)(autoload 'org-columns-get-format-and-top-level "org-colview")(autoload 'org-columns "org-colview" "Turn on column view on an Org mode file.\n\nColumn view applies to the whole buffer if point is before the first\nheadline.  Otherwise, it applies to the first ancestor setting\n\"COLUMNS\" property.  If there is none, it defaults to the current\nheadline.  With a `\\[universal-argument]' prefix argument, GLOBAL,\nturn on column view for the whole buffer unconditionally.\n\nWhen COLUMNS-FMT-STRING is non-nil, use it as the column format.\n\n(fn &optional GLOBAL COLUMNS-FMT-STRING)" t)(autoload 'org-columns-compute "org-colview" "Summarize the values of PROPERTY hierarchically.\nAlso update existing values for PROPERTY according to the first\ncolumn specification.\n\n(fn PROPERTY)" t)(autoload 'org-dblock-write:columnview "org-colview" "Write the column view table.\n\nPARAMS is a property list of parameters:\n\n`:id' (mandatory)\n\n    The ID property of the entry where the columns view should be\n    built.  When the symbol `local', call locally.  When `global'\n    call column view with the cursor at the beginning of the\n    buffer (usually this means that the whole buffer switches to\n    column view).  When \"file:path/to/file.org\", invoke column\n    view at the start of that file.  Otherwise, the ID is located\n    using `org-id-find'.\n\n`:exclude-tags'\n\n    List of tags to exclude from column view table.\n\n`:format'\n\n    When non-nil, specify the column view format to use.\n\n`:hlines'\n\n    When non-nil, insert a hline before each item.  When\n    a number, insert a hline before each level inferior or equal\n    to that number.\n\n`:indent'\n\n    When non-nil, indent each ITEM field according to its level.\n\n`:match'\n\n    When set to a string, use this as a tags/property match filter.\n\n`:maxlevel'\n\n    When set to a number, don't capture headlines below this level.\n\n`:skip-empty-rows'\n\n    When non-nil, skip rows where all specifiers other than ITEM\n    are empty.\n\n`:vlines'\n\n    When non-nil, make each column a column group to enforce\n    vertical lines.\n\n`:link'\n\n    Link the item headlines in the table to their origins.\n\n`:formatter'\n\n    A function to format the data and insert it into the\n    buffer.  Overrides the default formatting function set in\n    `org-columns-dblock-formatter'.\n\n(fn PARAMS)")(autoload 'org-columns-insert-dblock "org-colview" "Create a dynamic block capturing a column view table." t)(eval-after-load 'org '(progn (org-dynamic-block-define "columnview" #'org-columns-insert-dblock)))(autoload 'org-agenda-columns "org-colview" "Turn on or update column view in the agenda." t)(autoload 'org-list-of-strings-p "org-compat" "Return t if OBJECT is nil or a list of strings.\n\n(fn OBJECT)")(function-put 'org-list-of-strings-p 'pure 't)(function-put 'org-list-of-strings-p 'side-effect-free 'error-free)(autoload 'org-check-version "org-compat" "Try very hard to provide sensible version strings." nil t)(autoload 'org-encrypt-entry "org-crypt" "Encrypt the content of the current headline." t)(autoload 'org-decrypt-entry "org-crypt" "Decrypt the content of the current headline." t)(autoload 'org-encrypt-entries "org-crypt" "Encrypt all top-level entries in the current buffer." t)(autoload 'org-decrypt-entries "org-crypt" "Decrypt all entries in the current buffer." t)(autoload 'org-crypt-use-before-save-magic "org-crypt" "Add a hook to automatically encrypt entries before a file is saved to disk.")(autoload 'org-cycle "org-cycle" "TAB-action and visibility cycling for Org mode.\n\nThis is the command invoked in Org mode by the `TAB' key.  Its main\npurpose is outline visibility cycling, but it also invokes other actions\nin special contexts.\n\nWhen this function is called with a `\\[universal-argument]' prefix, rotate the entire\nbuffer through 3 states (global cycling)\n  1. OVERVIEW: Show only top-level headlines.\n  2. CONTENTS: Show all headlines of all levels, but no body text.\n  3. SHOW ALL: Show everything.\n\nWith a `\\[universal-argument] \\[universal-argument]' prefix argument, switch to the startup visibility,\ndetermined by the variable `org-startup-folded', and by any VISIBILITY\nproperties in the buffer.\n\nWith a `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix argument, show the entire buffer, including\nany drawers.\n\nWhen inside a table, re-align the table and move to the next field.\n\nWhen point is at the beginning of a headline, rotate the subtree started\nby this line through 3 different states (local cycling)\n  1. FOLDED:   Only the main headline is shown.\n  2. CHILDREN: The main headline and the direct children are shown.\n               From this state, you can move to one of the children\n               and zoom in further.\n  3. SUBTREE:  Show the entire subtree, including body text.\nIf there is no subtree, switch directly from CHILDREN to FOLDED.\n\nWhen point is at the beginning of an empty headline and the variable\n`org-cycle-level-after-item/entry-creation' is set, cycle the level\nof the headline by demoting and promoting it to likely levels.  This\nspeeds up creation document structure by pressing `TAB' once or several\ntimes right after creating a new headline.\n\nWhen there is a numeric prefix, go up to a heading with level ARG, do\na `show-subtree' and return to the previous cursor position.  If ARG\nis negative, go up that many levels.\n\nWhen point is not at the beginning of a headline, execute the global\nbinding for `TAB', which is re-indenting the line.  See the option\n`org-cycle-emulate-tab' for details.\n\nAs a special case, if point is at the very beginning of the buffer, if\nthere is no headline there, and if the variable `org-cycle-global-at-bob'\nis non-nil, this function acts as if called with prefix argument (`\\[universal-argument] TAB',\nsame as `S-TAB') also when called without prefix argument.\n\n(fn &optional ARG)" t)(autoload 'org-cycle-global "org-cycle" "Cycle the global visibility.  For details see `org-cycle'.\nWith `\\[universal-argument]' prefix ARG, switch to startup visibility.\nWith a numeric prefix, show all headlines up to that level.\n\n(fn &optional ARG)" t)(autoload 'org-datetree-find-date-create "org-datetree" "Find or create a day entry for date D.\nIf KEEP-RESTRICTION is non-nil, do not widen the buffer.\nWhen it is nil, the buffer will be widened to make sure an existing date\ntree can be found.  If it is the symbol `subtree-at-point', then the tree\nwill be built under the headline at point.\n\n(fn D &optional KEEP-RESTRICTION)")(autoload 'org-datetree-find-month-create "org-datetree" "Find or create a month entry for date D.\nCompared to `org-datetree-find-date-create' this function creates\nentries grouped by month instead of days.\nIf KEEP-RESTRICTION is non-nil, do not widen the buffer.\nWhen it is nil, the buffer will be widened to make sure an existing date\ntree can be found.  If it is the symbol `subtree-at-point', then the tree\nwill be built under the headline at point.\n\n(fn D &optional KEEP-RESTRICTION)")(autoload 'org-datetree-find-iso-week-create "org-datetree" "Find or create an ISO week entry for date D.\nCompared to `org-datetree-find-date-create' this function creates\nentries ordered by week instead of months.\nWhen it is nil, the buffer will be widened to make sure an existing date\ntree can be found.  If it is the symbol `subtree-at-point', then the tree\nwill be built under the headline at point.\n\n(fn D &optional KEEP-RESTRICTION)")(autoload 'org-duration-set-regexps "org-duration" "Set duration related regexps." t)(autoload 'org-duration-p "org-duration" "Non-nil when string S is a time duration.\n\n(fn S)")(autoload 'org-duration-to-minutes "org-duration" "Return number of minutes of DURATION string.\n\nWhen optional argument CANONICAL is non-nil, ignore\n`org-duration-units' and use standard time units value.\n\nA bare number is translated into minutes.  The empty string is\ntranslated into 0.0.\n\nReturn value as a float.  Raise an error if duration format is\nnot recognized.\n\n(fn DURATION &optional CANONICAL)")(autoload 'org-duration-from-minutes "org-duration" "Return duration string for a given number of MINUTES.\n\nFormat duration according to `org-duration-format' or FMT, when\nnon-nil.\n\nWhen optional argument CANONICAL is non-nil, ignore\n`org-duration-units' and use standard time units value.\n\nRaise an error if expected format is unknown.\n\n(fn MINUTES &optional FMT CANONICAL)")(autoload 'org-duration-h:mm-only-p "org-duration" "Non-nil when every duration in TIMES has \"H:MM\" or \"H:MM:SS\" format.\n\nTIMES is a list of duration strings.\n\nReturn nil if any duration is expressed with units, as defined in\n`org-duration-units'.  Otherwise, if any duration is expressed\nwith \"H:MM:SS\" format, return `h:mm:ss'.  Otherwise, return\n`h:mm'.\n\n(fn TIMES)")(autoload 'org-element-update-syntax "org-element" "Update parser internals." t)(autoload 'org-element-interpret-data "org-element" "Interpret DATA as Org syntax.\nDATA is a parse tree, an element, an object or a secondary string\nto interpret.  Return Org syntax as a string.\n\n(fn DATA)")(defvar org-element-use-cache t "Non-nil when Org parser should cache its results.")(autoload 'org-element-cache-reset "org-element" "Reset cache in current buffer.\nWhen optional argument ALL is non-nil, reset cache in all Org\nbuffers.\nWhen optional argument NO-PERSISTENCE is non-nil, do not try to update\nthe cache persistence in the buffer.\n\n(fn &optional ALL NO-PERSISTENCE)" t)(autoload 'org-element-cache-store-key "org-element" "Store KEY with VALUE associated with EPOM - point, marker, or element.\nThe key can be retrieved as long as the element (provided or at point)\ncontents is not modified.\nIf optional argument ROBUST is non-nil, the key will be retained even\nwhen the contents (children) of current element are modified.  Only\nnon-robust element modifications (affecting the element properties\nother then begin/end boundaries) will invalidate the key then.\n\n(fn EPOM KEY VALUE &optional ROBUST)")(autoload 'org-element-cache-get-key "org-element" "Get KEY associated with EPOM - point, marker, or element.\nReturn DEFAULT when KEY is not associated with EPOM.\nThe key can be retrieved as long as the element (provided or at point)\ncontents is not modified.\n\n(fn EPOM KEY &optional DEFAULT)")(autoload 'org-element-cache-refresh "org-element" "Refresh cache at position POS.\n\n(fn POS)")(autoload 'org-element-cache-map "org-element" "Map all elements in current buffer with FUNC according to GRANULARITY.\nCollect non-nil return values into result list.\n\nFUNC should accept a single argument - the element.\n\nFUNC can modify the buffer, but doing so may reduce performance.  If\nbuffer is modified, the mapping will continue from an element starting\nafter the last mapped element.  If the last mapped element is deleted,\nthe subsequent element will be skipped as it cannot be distinguished\ndeterministically from a changed element.  If FUNC is expected to\ndelete the element, it should directly set the value of\n`org-element-cache-map-continue-from' to force `org-element-cache-map'\ncontinue from the right point in buffer.\n\nIf some elements are not yet in cache, they will be added.\n\nGRANULARITY can be `headline', `headline+inlinetask'\n`greater-element', or `element'.  The default is\n`headline+inlinetask'.  `object' granularity is not supported.\n\nRESTRICT-ELEMENTS is a list of element types to be mapped over.\n\nNEXT-RE is a regexp used to search next candidate match when FUNC\nreturns non-nil and to search the first candidate match.  FAIL-RE is a\nregexp used to search next candidate match when FUNC returns nil.  The\nmapping will continue starting from headline at the RE match.\n\nFROM-POS and TO-POS are buffer positions.  When non-nil, they bound the\nmapped elements to elements starting at of after FROM-POS but before\nTO-POS.\n\nAFTER-ELEMENT, when non-nil, bounds the mapping to all the elements\nafter AFTER-ELEMENT (i.e. if AFTER-ELEMENT is a headline section, we\nmap all the elements starting from first element inside section, but\nnot including the section).\n\nLIMIT-COUNT limits mapping to that many first matches where FUNC\nreturns non-nil.\n\nNARROW controls whether current buffer narrowing should be preserved.\n\nThis function does a subset of what `org-element-map' does, but with\nmuch better performance.  Cached elements are supplied as the single\nargument of FUNC.  Changes to elements made in FUNC will also alter\nthe cache.\n\n(fn FUNC &key (GRANULARITY \\='headline+inlinetask) RESTRICT-ELEMENTS NEXT-RE FAIL-RE FROM-POS (TO-POS (point-max-marker)) AFTER-ELEMENT LIMIT-COUNT NARROW)")(autoload 'org-element-at-point "org-element" "Determine closest element around point or EPOM.\n\nWhen EPOM is an element, return it immediately.\nOtherwise, determine element at EPOM marker or position.\n\nOnly check cached element when CACHED-ONLY is non-nil and return nil\nunconditionally when element at EPOM is not in cache.\n\nReturn value is a list like (TYPE PROPS) where TYPE is the type\nof the element and PROPS a plist of properties associated to the\nelement.\n\nPossible types are defined in `org-element-all-elements'.\nProperties depend on element or object type, but always include\n`:begin', `:end', and `:post-blank' properties.\n\nAs a special case, if point is at the very beginning of the first\nitem in a list or sub-list, returned element will be that list\ninstead of the item.  Likewise, if point is at the beginning of\nthe first row of a table, returned element will be the table\ninstead of the first row.\n\nWhen point is at the end of the buffer, return the innermost\nelement ending there.\n\nThis function may modify the match data.\n\n(fn &optional EPOM CACHED-ONLY)")(defsubst org-element-at-point-no-context (&optional pom) "Quickly find element at point or POM.\n\nIt is a faster version of `org-element-at-point' that is not\nguaranteed to return cached element.  `:parent' element may be\ndeferred and slow to retrieve." (or (org-element-at-point pom 'cached-only) (org-element-with-disabled-cache (org-element-at-point pom))))(autoload 'org-element-context "org-element" "Return smallest element or object around point.\n\nReturn value is a list like (TYPE PROPS) where TYPE is the type\nof the element or object and PROPS a plist of properties\nassociated to it.\n\nPossible types are defined in `org-element-all-elements' and\n`org-element-all-objects'.  Properties depend on element or\nobject type, but always include `:begin', `:end', `:parent' and\n`:post-blank'.\n\nAs a special case, if point is right after an object and not at\nthe beginning of any other object, return that object.\n\nOptional argument ELEMENT, when non-nil, is the closest element\ncontaining point, as returned by `org-element-at-point'.\nProviding it allows for quicker computation.\n\nThis function may modify match data.\n\n(fn &optional ELEMENT)")(autoload 'org-feed-update-all "org-feed" "Get inbox items from all feeds in `org-feed-alist'." t)(autoload 'org-feed-update "org-feed" "Get inbox items from FEED.\nFEED can be a string with an association in `org-feed-alist', or\nit can be a list structured like an entry in `org-feed-alist'.\n\n(fn FEED &optional RETRIEVE-ONLY)" t)(autoload 'org-feed-goto-inbox "org-feed" "Go to the inbox that captures the feed named FEED.\n\n(fn FEED)" t)(autoload 'org-feed-show-raw-feed "org-feed" "Show the raw feed buffer of a feed.\n\n(fn FEED)" t)(autoload 'org-footnote-action "org-footnote" "Do the right thing for footnotes.\n\nWhen at a footnote reference, jump to the definition.\n\nWhen at a definition, jump to the references if they exist, offer\nto create them otherwise.\n\nWhen neither at definition or reference, create a new footnote,\ninteractively if possible.\n\nWith prefix arg SPECIAL, or when no footnote can be created,\noffer additional commands in a menu.\n\n(fn &optional SPECIAL)" t)(autoload 'org-goto-location "org-goto" "Let the user select a location in current buffer.\nThis function uses a recursive edit.  It returns the selected\nposition or nil.\n\n(fn &optional BUF HELP)")(autoload 'org-goto "org-goto" "Look up a different location in the current file, keeping current visibility.\n\nWhen you want look-up or go to a different location in a\ndocument, the fastest way is often to fold the entire buffer and\nthen dive into the tree.  This method has the disadvantage, that\nthe previous location will be folded, which may not be what you\nwant.\n\nThis command works around this by showing a copy of the current\nbuffer in an indirect buffer, in overview mode.  You can dive\ninto the tree in that copy, use `org-occur' and incremental search\nto find a location.  When pressing RET or `Q', the command\nreturns to the original buffer in which the visibility is still\nunchanged.  After RET it will also jump to the location selected\nin the indirect buffer and expose the headline hierarchy above.\n\nWith a prefix argument, use the alternative interface: e.g., if\n`org-goto-interface' is `outline' use `outline-path-completion'.\n\n(fn &optional ALTERNATIVE-INTERFACE)" t)(autoload 'org-id-get-create "org-id" "Create an ID for the current entry and return it.\nIf the entry already has an ID, just return it.\nWith optional argument FORCE, force the creation of a new ID.\n\n(fn &optional FORCE)" t)(autoload 'org-id-copy "org-id" "Copy the ID of the entry at point to the kill ring.\nCreate an ID if necessary." t)(autoload 'org-id-get "org-id" "Get the ID of the entry at EPOM.\n\nEPOM is an element, marker, or buffer position.  If EPOM is nil,\nrefer to the entry at point.\n\nIf INHERIT is non-nil, ID properties inherited from parent\nentries are considered.  Otherwise, only ID properties on the\nentry itself are considered.\n\nWhen CREATE is nil, return the ID of the entry if found,\notherwise nil.  When CREATE is non-nil, create an ID if none has\nbeen found, and return the new ID.  PREFIX will be passed through\nto `org-id-new'.\n\n(fn &optional EPOM CREATE PREFIX INHERIT)")(autoload 'org-id-get-with-outline-path-completion "org-id" "Use `outline-path-completion' to retrieve the ID of an entry.\nTARGETS may be a setting for `org-refile-targets' to define\neligible headlines.  When omitted, all headlines in the current\nfile are eligible.  This function returns the ID of the entry.\nIf necessary, the ID is created.\n\n(fn &optional TARGETS)")(autoload 'org-id-get-with-outline-drilling "org-id" "Use an outline-cycling interface to retrieve the ID of an entry.\nThis only finds entries in the current buffer, using `org-goto-location'.\nIt returns the ID of the entry.  If necessary, the ID is created.")(autoload 'org-id-goto "org-id" "Switch to the buffer containing the entry with id ID.\nMove the cursor to that entry in that buffer.\n\n(fn ID)" t)(autoload 'org-id-find "org-id" "Return the location of the entry with the id ID.\nThe return value is a cons cell (file-name . position), or nil\nif there is no entry with that ID.\nWith optional argument MARKERP, return the position as a new marker.\n\n(fn ID &optional MARKERP)")(autoload 'org-id-new "org-id" "Create a new globally unique ID.\n\nAn ID consists of two parts separated by a colon:\n- a prefix\n- a unique part that will be created according to `org-id-method'.\n\nPREFIX can specify the prefix, the default is given by the variable\n`org-id-prefix'.  However, if PREFIX is the symbol `none', don't use any\nprefix even if `org-id-prefix' specifies one.\n\nSo a typical ID could look like \"Org:4nd91V40HI\".\n\n(fn &optional PREFIX)")(autoload 'org-id-update-id-locations "org-id" "Scan relevant files for IDs.\nStore the relation between files and corresponding IDs.\nThis will scan all agenda files, all associated archives, all open Org\nfiles, and all files currently mentioned in `org-id-locations'.\nWhen FILES is given, scan also these files.\nIf SILENT is non-nil, messages are suppressed.\n\n(fn &optional FILES SILENT)" t)(autoload 'org-id-find-id-file "org-id" "Query the id database for the file in which ID is located.\n\n(fn ID)")(autoload 'org-id-store-link "org-id" "Store a link to the current entry, using its ID.\n\nThe link description is based on the heading, or if before the\nfirst heading, the title keyword if available, or else the\nfilename.\n\nWhen `org-link-context-for-files' and `org-id-link-use-context'\nare non-nil, add a search string to the link.  The link\ndescription is then based on the search string target.\n\nWhen in addition `org-id-link-consider-parent-id' is non-nil, the\nID can be inherited from a parent entry, with the search string\nused to still link to the current location." t)(autoload 'org-id-store-link-maybe "org-id" "Store a link to the current entry using its ID if enabled.\n\nThe value of `org-id-link-to-org-use-id' determines whether an ID\nlink should be stored, using `org-id-store-link'.\n\nAssume the function is called interactively if INTERACTIVE? is\nnon-nil.\n\n(fn &optional INTERACTIVE?)")(autoload 'org-indent-mode "org-indent" "When active, indent text according to outline structure.\n\nInternally this works by adding `line-prefix' and `wrap-prefix'\nproperties, after each buffer modification, on the modified zone.\n\nThe process is synchronous.  Though, initial indentation of\nbuffer, which can take a few seconds on large buffers, is done\nduring idle time.\n\nThis is a minor mode.  If called interactively, toggle the\n`Org-Indent mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `org-indent-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'org-babel-describe-bindings "org-keys" "Describe all keybindings behind `org-babel-key-prefix'." t)(autoload 'org-lint-add-checker "org-lint" "Add a new checker for linter.\n\nNAME is a unique check identifier, as a non-nil symbol.  SUMMARY\nis a short description of the check, as a string.\n\nThe check is done calling the function FUN with one mandatory\nargument, the parse tree describing the current Org buffer.  Such\nfunction calls are wrapped within a `save-excursion' and point is\nalways at `point-min'.  Its return value has to be an\nalist (POSITION MESSAGE) where POSITION refer to the buffer\nposition of the error, as an integer, and MESSAGE is a one-line\nstring describing the error.\n\nOptional argument PROPS provides additional information about the\nchecker.  Currently, two properties are supported:\n\n  `:categories'\n\n     Categories relative to the check, as a list of symbol.  They\n     are used for filtering when calling `org-lint'.  Checkers\n     not explicitly associated to a category are collected in the\n     `default' one.\n\n  `:trust'\n\n    The trust level one can have in the check.  It is either\n    `low' or `high', depending on the heuristics implemented and\n    the nature of the check.  This has an indicative value only\n    and is displayed along reports.\n\n(fn NAME SUMMARY FUN &rest PROPS)")(function-put 'org-lint-add-checker 'lisp-indent-function 1)(autoload 'org-lint "org-lint" "Check current Org buffer for syntax mistakes.\n\nBy default, run all checkers.  With a `\\[universal-argument]' prefix ARG, select one\ncategory of checkers only.  With a `\\[universal-argument] \\[universal-argument]' prefix, run one precise\nchecker by its name.\n\nARG can also be a list of checker names, as symbols, to run.\n\n(fn &optional ARG)" t)(autoload 'org-list-checkbox-radio-mode "org-list" "When turned on, use list checkboxes as radio buttons.\n\nThis is a minor mode.  If called interactively, toggle the\n`Org-List-Checkbox-Radio mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `org-list-checkbox-radio-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'org-load-noerror-mustsuffix "org-macs" "Load FILE with optional arguments NOERROR and MUSTSUFFIX.\n\n(fn FILE)" nil t)(autoload 'org-element-with-disabled-cache "org-macs" "Run BODY without active org-element-cache.\n\n(fn &rest BODY)" nil t)(function-put 'org-element-with-disabled-cache 'lisp-indent-function 0)(autoload 'org-mobile-push "org-mobile" "Push the current state of Org affairs to the target directory.\nThis will create the index file, copy all agenda files there, and also\ncreate all custom agenda views, for upload to the mobile phone." t)(autoload 'org-mobile-pull "org-mobile" "Pull the contents of `org-mobile-capture-file' and integrate them.\nApply all flagged actions, flag entries to be flagged and then call an\nagenda view showing the flagged items." t)(defvar org-num-face nil "Face to use for numbering.\nWhen nil, use the same face as the headline.  This value is\nignored if `org-num-format-function' specifies a face for its\noutput.")(put 'org-num-face 'safe-local-variable (lambda (val) (or (null val) (facep val))))(defvar org-num-max-level nil "Level below which headlines are not numbered.\nWhen set to nil, all headlines are numbered.")(put 'org-num-max-level 'safe-local-variable (lambda (val) (or (null val) (wholenump val))))(defvar org-num-skip-commented nil "Non-nil means commented sub-trees are not numbered.")(put 'org-num-skip-commented 'safe-local-variable #'booleanp)(defvar org-num-skip-footnotes nil "Non-nil means footnotes sections are not numbered.")(put 'org-num-skip-footnotes 'safe-local-variable #'booleanp)(defvar org-num-skip-tags nil "List of tags preventing the numbering of sub-trees.\n\nFor example, add \"ARCHIVE\" to this list to avoid numbering\narchived sub-trees.\n\nTag in this list prevent numbering the whole sub-tree,\nirrespective to `org-use-tag-inheritance', or other means to\ncontrol tag inheritance.")(put 'org-num-skip-tags 'safe-local-variable #'org-list-of-strings-p)(defvar org-num-skip-unnumbered nil "Non-nil means numbering obeys to UNNUMBERED property.")(put 'org-num-skip-unnumbered 'safe-local-variable #'booleanp)(autoload 'org-num-default-format "org-num" "Default numbering display function.\nNUMBERING is a list of numbers.\n\n(fn NUMBERING)")(autoload 'org-num-mode "org-num" "Dynamic numbering of headlines in an Org buffer.\n\nThis is a minor mode.  If called interactively, toggle the\n`Org-Num mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `org-num-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'org-plot/gnuplot "org-plot" "Plot table using gnuplot.  Gnuplot options can be specified with PARAMS.\nIf not given options will be taken from the +PLOT\nline directly before or after the table.\n\n(fn &optional PARAMS)" t)(autoload 'org-refile-copy "org-refile" "Like `org-refile', but preserve the refiled subtree." t)(autoload 'org-refile-reverse "org-refile" "Refile while temporarily toggling `org-reverse-note-order'.\nSo if `org-refile' would append the entry as the last entry under\nthe target heading, `org-refile-reverse' will prepend it as the\nfirst entry, and vice-versa.\n\n(fn &optional ARG DEFAULT-BUFFER RFLOC MSG)" t)(autoload 'org-refile "org-refile" "Move the entry or entries at point to another heading.\n\nThe list of target headings is compiled using the information in\n`org-refile-targets', which see.\n\nAt the target location, the entry is filed as a subitem of the\ntarget heading.  Depending on `org-reverse-note-order', the new\nsubitem will either be the first or the last subitem.\n\nIf there is an active region, all entries in that region will be\nrefiled.  However, the region must fulfill the requirement that\nthe first heading sets the top-level of the moved text.\n\nWith a `\\[universal-argument]' ARG, the command will only visit the target location\nand not actually move anything.\n\nWith a prefix `\\[universal-argument] \\[universal-argument]', go to the location where the last\nrefiling operation has put the subtree.\n\nWith a numeric prefix argument of `2', refile to the running clock.\n\nWith a numeric prefix argument of `3', emulate `org-refile-keep'\nbeing set to t and copy to the target location, don't move it.\nBeware that keeping refiled entries may result in duplicated ID\nproperties.\n\nRFLOC can be a refile location obtained in a different way.  It\nshould be a list with the following 4 elements:\n\n1. Name - an identifier for the refile location, typically the\nheadline text\n2. File - the file the refile location is in\n3. nil - used for generating refile location candidates, not\nneeded when passing RFLOC\n4. Position - the position in the specified file of the\nheadline to refile under\n\nMSG is a string to replace \"Refile\" in the default prompt with\nanother verb.  E.g. `org-refile-copy' sets this parameter to \"Copy\".\n\nSee also `org-refile-use-outline-path'.\n\nIf you are using target caching (see `org-refile-use-cache'), you\nhave to clear the target cache in order to find new targets.\nThis can be done with a `0' prefix (\\`C-0 C-c C-w') or a triple\nprefix argument (\\`C-u C-u C-u C-c C-w').\n\n(fn &optional ARG DEFAULT-BUFFER RFLOC MSG)" t)(autoload 'org-table-header-line-mode "org-table" "Display the first row of the table at point in the header line.\n\nThis is a minor mode.  If called interactively, toggle the\n`Org-Table-Header-Line mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `org-table-header-line-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'org-table-create-with-table.el "org-table" "Use the table.el package to insert a new table.\nIf there is already a table at point, convert between Org tables\nand table.el tables." t)(autoload 'org-table-create-or-convert-from-region "org-table" "Convert region to table, or create an empty table.\nIf there is an active region, convert it to a table, using the function\n`org-table-convert-region'.  See the documentation of that function\nto learn how the prefix argument is interpreted to determine the field\nseparator.\nIf there is no such region, create an empty table with `org-table-create'.\n\n(fn ARG)" t)(autoload 'org-table-create "org-table" "Query for a size and insert a table skeleton.\nSIZE is a string Columns x Rows like for example \"3x2\".\n\n(fn &optional SIZE)" t)(autoload 'org-table-convert-region "org-table" "Convert region to a table.\n\nThe region goes from BEG0 to END0, but these borders will be moved\nslightly, to make sure a beginning of line in the first line is\nincluded.\n\nThrow an error when the region has more than\n`org-table-convert-region-max-lines' lines.\n\nSEPARATOR specifies the field separator in the lines.  It can have the\nfollowing values:\n\n(4)     Use the comma as a field separator\n(16)    Use a TAB as field separator\n(64)    Prompt for a regular expression as field separator\ninteger  When a number, use that many spaces, or a TAB, as field separator\nregexp   When a regular expression, use it to match the separator\nnil      When nil, the command tries to be smart and figure out the\n         separator in the following way:\n         - when each line contains a TAB, assume TAB-separated material\n         - when each line contains a comma, assume CSV material\n         - else, assume one or more SPACE characters as separator.\n`babel-auto'\n       Use the same rules as nil, but do not try any separator when\n       the region contains a single line and has no commas or tabs.\n\n(fn BEG0 END0 &optional SEPARATOR)" t)(autoload 'org-table-import "org-table" "Import FILE as a table.\n\nThe command tries to be smart and figure out the separator in the\nfollowing way:\n\n- when each line contains a TAB, assume TAB-separated material;\n- when each line contains a comma, assume CSV material;\n- else, assume one or more SPACE characters as separator.\n\nWhen non-nil, SEPARATOR specifies the field separator in the\nlines.  It can have the following values:\n\n- (4)     Use the comma as a field separator.\n- (16)    Use a TAB as field separator.\n- (64)    Prompt for a regular expression as field separator.\n- integer When a number, use that many spaces, or a TAB, as field separator.\n- regexp  When a regular expression, use it to match the separator.\n\n(fn FILE SEPARATOR)" t)(autoload 'org-table-begin "org-table" "Find the beginning of the table and return its position.\nWith a non-nil optional argument TABLE-TYPE, return the beginning\nof a table.el-type table.  This function assumes point is on\na table.\n\n(fn &optional TABLE-TYPE)")(autoload 'org-table-end "org-table" "Find the end of the table and return its position.\nWith a non-nil optional argument TABLE-TYPE, return the end of\na table.el-type table.  This function assumes point is on\na table.\n\n(fn &optional TABLE-TYPE)")(autoload 'org-table-next-field "org-table" "Go to the next field in the current table, creating new lines as needed.\nBefore doing so, re-align the table if necessary." t)(autoload 'org-table-previous-field "org-table" "Go to the previous field in the table.\nBefore doing so, re-align the table if necessary." t)(autoload 'org-table-next-row "org-table" "Go to the next row (same column) in the current table.\nWhen next row is an hline or outside the table, create a new empty\nrow.  Before doing so, re-align the table if necessary." t)(autoload 'org-table-blank-field "org-table" "Blank the current table field or active region." t)(autoload 'org-table-field-info "org-table" "Show info about the current field, and highlight any reference at point.\n\n(fn ARG)" t)(autoload 'org-table-goto-column "org-table" "Move the cursor to the Nth column in the current table line.\nWith optional argument ON-DELIM, stop with point before the left delimiter\nof the field.\nIf there are less than N fields, just go to after the last delimiter.\nHowever, when FORCE is non-nil, create new columns if necessary.\n\n(fn N &optional ON-DELIM FORCE)" t)(autoload 'org-table-insert-column "org-table" "Insert a new column into the table." t)(autoload 'org-table-move-cell-up "org-table" "Move a single cell up in a table.\nSwap with anything in target cell." t)(autoload 'org-table-move-cell-down "org-table" "Move a single cell down in a table.\nSwap with anything in target cell." t)(autoload 'org-table-move-cell-left "org-table" "Move a single cell left in a table.\nSwap with anything in target cell." t)(autoload 'org-table-move-cell-right "org-table" "Move a single cell right in a table.\nSwap with anything in target cell." t)(autoload 'org-table-delete-column "org-table" "Delete a column from the table." t)(autoload 'org-table-move-column-right "org-table" "Move column to the right." t)(autoload 'org-table-move-column-left "org-table" "Move column to the left." t)(autoload 'org-table-move-column "org-table" "Move the current column to the right.  With arg LEFT, move to the left.\n\n(fn &optional LEFT)" t)(autoload 'org-table-move-row-down "org-table" "Move table row down." t)(autoload 'org-table-move-row-up "org-table" "Move table row up." t)(autoload 'org-table-move-row "org-table" "Move the current table line down.  With arg UP, move it up.\n\n(fn &optional UP)" t)(autoload 'org-table-insert-row "org-table" "Insert a new row above the current line into the table.\nWith prefix ARG, insert below the current line.\n\n(fn &optional ARG)" t)(autoload 'org-table-insert-hline "org-table" "Insert a horizontal-line below the current line into the table.\nWith prefix ABOVE, insert above the current line.\n\n(fn &optional ABOVE)" t)(autoload 'org-table-hline-and-move "org-table" "Insert a hline and move to the row below that line.\n\n(fn &optional SAME-COLUMN)" t)(autoload 'org-table-kill-row "org-table" "Delete the current row or horizontal line from the table." t)(autoload 'org-table-cut-region "org-table" "Copy region in table to the clipboard and blank all relevant fields.\nIf there is no active region, use just the field at point.\n\n(fn BEG END)" t)(autoload 'org-table-copy-down "org-table" "Copy the value of the current field one row below.\n\nIf the field at the cursor is empty, copy the content of the\nnearest non-empty field above.  With argument N, use the Nth\nnon-empty field.\n\nIf the current field is not empty, it is copied down to the next\nrow, and the cursor is moved with it.  Therefore, repeating this\ncommand causes the column to be filled row-by-row.\n\nIf the variable `org-table-copy-increment' is non-nil and the\nfield is a number, a timestamp, or is either prefixed or suffixed\nwith a number, it will be incremented while copying.  By default,\nincrement by the difference between the value in the current\nfield and the one in the field above, if any.  To increment using\na fixed integer, set `org-table-copy-increment' to a number.  In\nthe case of a timestamp, increment by days.\n\nHowever, when N is 0, do not increment the field at all.\n\n(fn N)" t)(autoload 'org-table-copy-region "org-table" "Copy rectangular region in table to clipboard.\nA special clipboard is used which can only be accessed with\n`org-table-paste-rectangle'.  Return the region copied, as a list\nof lists of fields.\n\n(fn BEG END &optional CUT)" t)(autoload 'org-table-paste-rectangle "org-table" "Paste a rectangular region into a table.\nThe upper right corner ends up in the current field.  All involved fields\nwill be overwritten.  If the rectangle does not fit into the present table,\nthe table is enlarged as needed.  The process ignores horizontal separator\nlines." t)(autoload 'org-table-edit-field "org-table" "Edit table field in a different window.\nThis is mainly useful for fields that contain hidden parts.\n\nWhen called with a `\\[universal-argument]' prefix, just make the full field\nvisible so that it can be edited in place.\n\nWhen called with a `\\[universal-argument] \\[universal-argument]' prefix, toggle `org-table-follow-field-mode'.\n\n(fn ARG)" t)(autoload 'org-table-get-stored-formulas "org-table" "Return an alist with the stored formulas directly after current table.\nBy default, only return active formulas, i.e., formulas located\non the first line after the table.  However, if optional argument\nLOCATION is a buffer position, consider the formulas there.\n\n(fn &optional NOERROR LOCATION)")(autoload 'org-table-maybe-eval-formula "org-table" "Check if the current field starts with \"=\" or \":=\".\nIf yes, store the formula and apply it.")(autoload 'org-table-rotate-recalc-marks "org-table" "Rotate the recalculation mark in the first column.\nIf in any row, the first field is not consistent with a mark,\ninsert a new column for the markers.\nWhen there is an active region, change all the lines in the region,\nafter prompting for the marking character.\nAfter each change, a message will be displayed indicating the meaning\nof the new mark.\n\n(fn &optional NEWCHAR)" t)(autoload 'org-table-maybe-recalculate-line "org-table" "Recompute the current line if marked for it, and if we haven't just done it." t)(autoload 'org-table-eval-formula "org-table" "Replace the table field value at the cursor by the result of a calculation.\n\nIn a table, this command replaces the value in the current field with the\nresult of a formula.  It also installs the formula as the \"current\" column\nformula, by storing it in a special line below the table.  When called\nwith a `\\[universal-argument]' prefix the formula is installed as a field formula.\n\nWhen called with a `\\[universal-argument] \\[universal-argument]' prefix, insert the active equation for the field\nback into the current field, so that it can be edited there.  This is useful\nin order to use \\<org-table-fedit-map>`\\[org-table-show-reference]' to check the referenced fields.\n\nWhen called, the command first prompts for a formula, which is read in\nthe minibuffer.  Previously entered formulas are available through the\nhistory list, and the last used formula is offered as a default.\nThese stored formulas are adapted correctly when moving, inserting, or\ndeleting columns with the corresponding commands.\n\nThe formula can be any algebraic expression understood by the Calc package.\nFor details, see the Org mode manual.\n\nThis function can also be called from Lisp programs and offers\nadditional arguments: EQUATION can be the formula to apply.  If this\nargument is given, the user will not be prompted.\n\nSUPPRESS-ALIGN is used to speed-up recursive calls by by-passing\nunnecessary aligns.\n\nSUPPRESS-CONST suppresses the interpretation of constants in the\nformula, assuming that this has been done already outside the\nfunction.\n\nSUPPRESS-STORE means the formula should not be stored, either\nbecause it is already stored, or because it is a modified\nequation that should not overwrite the stored one.\n\nSUPPRESS-ANALYSIS prevents analyzing the table and checking\nlocation of point.\n\n(fn &optional ARG EQUATION SUPPRESS-ALIGN SUPPRESS-CONST SUPPRESS-STORE SUPPRESS-ANALYSIS)" t)(autoload 'org-table-recalculate "org-table" "Recalculate the current table line by applying all stored formulas.\n\nWith prefix arg ALL, do this for all lines in the table.\n\nWhen called with a `\\[universal-argument] \\[universal-argument]' prefix, or if ALL is the symbol `iterate',\nrecompute the table until it no longer changes.\n\nIf NOALIGN is not nil, do not re-align the table after the computations\nare done.  This is typically used internally to save time, if it is\nknown that the table will be realigned a little later anyway.\n\n(fn &optional ALL NOALIGN)" t)(autoload 'org-table-iterate "org-table" "Recalculate the table until it does not change anymore.\nThe maximum number of iterations is 10, but you can choose a different value\nwith the prefix ARG.\n\n(fn &optional ARG)" t)(autoload 'org-table-recalculate-buffer-tables "org-table" "Recalculate all tables in the current buffer." t)(autoload 'org-table-iterate-buffer-tables "org-table" "Iterate all tables in the buffer, to converge inter-table dependencies." t)(autoload 'org-table-edit-formulas "org-table" "Edit the formulas of the current table in a separate buffer." t)(autoload 'org-table-toggle-coordinate-overlays "org-table" "Toggle the display of Row/Column numbers in tables." t)(autoload 'org-table-toggle-formula-debugger "org-table" "Toggle the formula debugger in tables." t)(autoload 'org-table-toggle-column-width "org-table" "Shrink or expand current column in an Org table.\n\nIf a width cookie specifies a width W for the column, the first\nW visible characters are displayed.  Otherwise, the column is\nshrunk to a single character.\n\nWhen point is before the first column or after the last one, ask\nfor the columns to shrink or expand, as a list of ranges.\nA column range can be one of the following patterns:\n\n  N    column N only\n  N-M  every column between N and M (both inclusive)\n  N-   every column between N (inclusive) and the last column\n  -M   every column between the first one and M (inclusive)\n  -    every column\n\nWhen optional argument ARG is a string, use it as white space\nseparated list of column ranges.\n\nWhen called with `\\[universal-argument]' prefix, call `org-table-shrink', i.e.,\nshrink columns with a width cookie and expand the others.\n\nWhen called with `\\[universal-argument] \\[universal-argument]' prefix, expand all columns.\n\n(fn &optional ARG)" t)(autoload 'org-table-shrink "org-table" "Shrink all columns with a width cookie in the table at point.\n\nColumns without a width cookie are expanded.\n\nOptional arguments BEGIN and END, when non-nil, specify the\nbeginning and end position of the current table.\n\n(fn &optional BEGIN END)" t)(autoload 'org-table-expand "org-table" "Expand all columns in the table at point.\nOptional arguments BEGIN and END, when non-nil, specify the\nbeginning and end position of the current table.\n\n(fn &optional BEGIN END)" t)(autoload 'org-table-map-tables "org-table" "Apply function F to the start of all tables in the buffer.\n\n(fn F &optional QUIETLY)")(autoload 'org-table-export "org-table" "Export table to a file, with configurable format.\nSuch a file can be imported into usual spreadsheet programs.\n\nFILE can be the output file name.  If not given, it will be taken\nfrom a TABLE_EXPORT_FILE property in the current entry or higher\nup in the hierarchy, or the user will be prompted for a file\nname.  FORMAT can be an export format, of the same kind as it\nused when `-mode' sends a table in a different format.\n\nThe command suggests a format depending on TABLE_EXPORT_FORMAT,\nwhether it is set locally or up in the hierarchy, then on the\nextension of the given file name, and finally on the variable\n`org-table-export-default-format'.\n\n(fn &optional FILE FORMAT)" t)(autoload 'org-table--align-field "org-table" "Format FIELD according to column WIDTH and alignment ALIGN.\nFIELD is a string.  WIDTH is a number.  ALIGN is either \"c\",\n\"l\" or\"r\".\n\n(fn FIELD WIDTH ALIGN)")(autoload 'org-table-justify-field-maybe "org-table" "Justify the current field, text to left, number to right.\nOptional argument NEW may specify text to replace the current field content.\n\n(fn &optional NEW)")(autoload 'org-table-sort-lines "org-table" "Sort table lines according to the column at point.\n\nThe position of point indicates the column to be used for\nsorting, and the range of lines is the range between the nearest\nhorizontal separator lines, or the entire table of no such lines\nexist.  If point is before the first column, you will be prompted\nfor the sorting column.  If there is an active region, the mark\nspecifies the first line and the sorting column, while point\nshould be in the last line to be included into the sorting.\n\nThe command then prompts for the sorting type which can be\nalphabetically, numerically, or by time (as given in a time stamp\nin the field, or as a HH:MM value).  Sorting in reverse order is\nalso possible.\n\nWith prefix argument WITH-CASE, alphabetic sorting will be case-sensitive\nif the locale allows for it.\n\nIf SORTING-TYPE is specified when this function is called from a Lisp\nprogram, no prompting will take place.  SORTING-TYPE must be a character,\nany of (?a ?A ?n ?N ?t ?T ?f ?F) where the capital letters indicate that\nsorting should be done in reverse order.\n\nIf the SORTING-TYPE is ?f or ?F, then GETKEY-FUNC specifies\na function to be called to extract the key.  It must return a value\nthat is compatible with COMPARE-FUNC, the function used to compare\nentries.\n\nA non-nil value for INTERACTIVE? is used to signal that this\nfunction is being called interactively.\n\n(fn &optional WITH-CASE SORTING-TYPE GETKEY-FUNC COMPARE-FUNC INTERACTIVE?)" t)(autoload 'org-table-wrap-region "org-table" "Wrap several fields in a column like a paragraph.\nThis is useful if you'd like to spread the contents of a field over several\nlines, in order to keep the table compact.\n\nIf there is an active region, and both point and mark are in the same column,\nthe text in the column is wrapped to minimum width for the given number of\nlines.  Generally, this makes the table more compact.  A prefix ARG may be\nused to change the number of desired lines.  For example, `C-2 \\[org-table-wrap-region]'\nformats the selected text to two lines.  If the region was longer than two\nlines, the remaining lines remain empty.  A negative prefix argument reduces\nthe current number of lines by that amount.  The wrapped text is pasted back\ninto the table.  If you formatted it to more lines than it was before, fields\nfurther down in the table get overwritten - so you might need to make space in\nthe table first.\n\nIf there is no region, the current field is split at the cursor position and\nthe text fragment to the right of the cursor is prepended to the field one\nline down.\n\nIf there is no region, but you specify a prefix ARG, the current field gets\nblank, and the content is appended to the field above.\n\n(fn ARG)" t)(autoload 'org-table-sum "org-table" "Sum numbers in region of current table column.\nThe result will be displayed in the echo area, and will be available\nas kill to be inserted with \\[yank].\n\nIf there is an active region, it is interpreted as a rectangle and all\nnumbers in that rectangle will be summed.  If there is no active\nregion and point is located in a table column, sum all numbers in that\ncolumn.\n\nIf at least one number looks like a time HH:MM or HH:MM:SS, all other\nnumbers are assumed to be times as well (in decimal hours) and the\nnumbers are added as such.\n\nIf NLAST is a number, only the NLAST fields will actually be summed.\n\n(fn &optional BEG END NLAST)" t)(autoload 'org-table-analyze "org-table" "Analyze table at point and store results.\n\nThis function sets up the following dynamically scoped variables:\n\n `org-table-column-name-regexp',\n `org-table-column-names',\n `org-table-current-begin-pos',\n `org-table-current-line-types',\n `org-table-current-ncol',\n `org-table-dlines',\n `org-table-hlines',\n `org-table-local-parameters',\n `org-table-named-field-locations'.")(autoload 'turn-on-orgtbl "org-table" "Unconditionally turn on `orgtbl-mode'.")(autoload 'orgtbl-mode "org-table" "The Org mode table editor as a minor mode for use in other modes.\n\nThis is a minor mode.  If called interactively, toggle the\n`OrgTbl mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `orgtbl-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar orgtbl-exp-regexp "^\\([-+]?[0-9][0-9.]*\\)[eE]\\([-+]?[0-9]+\\)$" "Regular expression matching exponentials as produced by calc.")(autoload 'org-table-to-lisp "org-table" "Convert the table at point to a Lisp structure.\n\nThe structure will be a list.  Each item is either the symbol `hline'\nfor a horizontal separator line, or a list of field values as strings.\nThe table is taken from the parameter TXT, or from the buffer at point.\n\n(fn &optional TXT)")(autoload 'orgtbl-to-generic "org-table" "Convert the `orgtbl-mode' TABLE to some other format.\n\nThis generic routine can be used for many standard cases.\n\nTABLE is a list, each entry either the symbol `hline' for\na horizontal separator line, or a list of fields for that\nline.  PARAMS is a property list of parameters that can\ninfluence the conversion.\n\nValid parameters are:\n\n:backend, :raw\n\n  Export backend used as a basis to transcode elements of the\n  table, when no specific parameter applies to it.  It is also\n  used to translate cells contents.  You can prevent this by\n  setting :raw property to a non-nil value.\n\n:splice\n\n  When non-nil, only convert rows, not the table itself.  This is\n  equivalent to setting to the empty string both :tstart\n  and :tend, which see.\n\n:skip\n\n  When set to an integer N, skip the first N lines of the table.\n  Horizontal separation lines do count for this parameter!\n\n:skipcols\n\n  List of columns that should be skipped.  If the table has\n  a column with calculation marks, that column is automatically\n  discarded beforehand.\n\n:hline\n\n  String to be inserted on horizontal separation lines.  May be\n  nil to ignore these lines altogether.\n\n:sep\n\n  Separator between two fields, as a string.\n\nEach in the following group may be either a string or a function\nof no arguments returning a string:\n\n:tstart, :tend\n\n  Strings to start and end the table.  Ignored when :splice is t.\n\n:lstart, :lend\n\n  Strings to start and end a new table line.\n\n:llstart, :llend\n\n  Strings to start and end the last table line.  Default,\n  respectively, to :lstart and :lend.\n\nEach in the following group may be a string or a function of one\nargument (either the cells in the current row, as a list of\nstrings, or the current cell) returning a string:\n\n:lfmt\n\n  Format string for an entire row, with enough %s to capture all\n  fields.  When non-nil, :lstart, :lend, and :sep are ignored.\n\n:llfmt\n\n  Format for the entire last line, defaults to :lfmt.\n\n:fmt\n\n  A format to be used to wrap the field, should contain %s for\n  the original field value.  For example, to wrap everything in\n  dollars, you could use :fmt \"$%s$\".  This may also be\n  a property list with column numbers and format strings, or\n  functions, e.g.,\n\n    (:fmt (2 \"$%s$\" 4 (lambda (c) (format \"$%s$\" c))))\n\n  The format is ignored for empty fields.  Use :raw t with non-nil\n  :backend option to force formatting empty fields.\n\n:hlstart :hllstart :hlend :hllend :hsep :hlfmt :hllfmt :hfmt\n\n Same as above, specific for the header lines in the table.\n All lines before the first hline are treated as header.  If\n any of these is not present, the data line value is used.\n\nThis may be either a string or a function of two arguments:\n\n:efmt\n\n  Use this format to print numbers with exponential.  The format\n  should have %s twice for inserting mantissa and exponent, for\n  example \"%s\\\\times10^{%s}\".  This may also be a property\n  list with column numbers and format strings or functions.\n  :fmt will still be applied after :efmt.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-tsv "org-table" "Convert the `orgtbl-mode' TABLE to TAB separated material.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-csv "org-table" "Convert the `orgtbl-mode' TABLE to CSV material.\nThis does take care of the proper quoting of fields with comma or quotes.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-latex "org-table" "Convert the `orgtbl-mode' TABLE to LaTeX.\n\nTABLE is a list, each entry either the symbol `hline' for\na horizontal separator line, or a list of fields for that line.\nPARAMS is a property list of parameters that can influence the\nconversion.  All parameters from `orgtbl-to-generic' are\nsupported.  It is also possible to use the following ones:\n\n:booktabs\n\n  When non-nil, use formal \"booktabs\" style.\n\n:environment\n\n  Specify environment to use, as a string.  If you use\n  \"longtable\", you may also want to specify :language property,\n  as a string, to get proper continuation strings.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-html "org-table" "Convert the `orgtbl-mode' TABLE to HTML.\n\nTABLE is a list, each entry either the symbol `hline' for\na horizontal separator line, or a list of fields for that line.\nPARAMS is a property list of parameters that can influence the\nconversion.  All parameters from `orgtbl-to-generic' are\nsupported.  It is also possible to use the following one:\n\n:attributes\n\n  Attributes and values, as a plist, which will be used in\n  <table> tag.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-texinfo "org-table" "Convert the `orgtbl-mode' TABLE to Texinfo.\n\nTABLE is a list, each entry either the symbol `hline' for\na horizontal separator line, or a list of fields for that line.\nPARAMS is a property list of parameters that can influence the\nconversion.  All parameters from `orgtbl-to-generic' are\nsupported.  It is also possible to use the following one:\n\n:columns\n\n  Column widths, as a string.  When providing column fractions,\n  \"@columnfractions\" command can be omitted.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-to-orgtbl "org-table" "Convert the `orgtbl-mode' TABLE into another `orgtbl-mode' table.\n\nTABLE is a list, each entry either the symbol `hline' for\na horizontal separator line, or a list of fields for that line.\nPARAMS is a property list of parameters that can influence the\nconversion.  All parameters from `orgtbl-to-generic' are\nsupported.\n\nUseful when slicing one table into many.  The :hline, :sep,\n:lstart, and :lend provide orgtbl framing.  :tstart and :tend can\nbe set to provide ORGTBL directives for the generated table.\n\n(fn TABLE PARAMS)")(autoload 'orgtbl-ascii-plot "org-table" "Draw an ASCII bar plot in a column.\n\nWith cursor in a column containing numerical values, this function\nwill draw a plot in a new column.\n\nASK, if given, is a numeric prefix to override the default 12\ncharacters width of the plot.  ASK may also be the `\\[universal-argument]' prefix,\nwhich will prompt for the width.\n\n(fn &optional ASK)" t)(autoload 'org-timer-start "org-timer" "Set the starting time for the relative timer to now.\nWhen called with prefix argument OFFSET, prompt the user for an offset time,\nwith the default taken from a timer stamp at point, if any.\nIf OFFSET is a string or an integer, it is directly taken to be the offset\nwithout user interaction.\nWhen called with a double prefix arg, all timer strings in the active\nregion will be shifted by a specific amount.  You will be prompted for\nthe amount, with the default to make the first timer string in\nthe region 0:00:00.\n\n(fn &optional OFFSET)" t)(autoload 'org-timer-pause-or-continue "org-timer" "Pause or continue the relative or countdown timer.\nWith prefix arg STOP, stop it entirely.\n\n(fn &optional STOP)" t)(autoload 'org-timer-stop "org-timer" "Stop the relative or countdown timer." t)(autoload 'org-timer "org-timer" "Insert a H:MM:SS string from the timer into the buffer.\nThe first time this command is used, the timer is started.\n\nWhen used with a `\\[universal-argument]' prefix RESTART, force\nrestarting the timer.\n\nWhen used with a `\\[universal-argument] \\[universal-argument]' prefix\nRESTART, change all the timer strings in the region by a fixed amount.\nThis can be used to re-calibrate a timer that was not started at the\ncorrect moment.\n\nIf NO-INSERT is non-nil, return the string instead of inserting it in\nthe buffer.\n\n(fn &optional RESTART NO-INSERT)" t)(autoload 'org-timer-change-times-in-region "org-timer" "Change all h:mm:ss time in region BEG..END by a DELTA.\n\n(fn BEG END DELTA)" t)(autoload 'org-timer-item "org-timer" "Insert a description-type item with the current timer value.\nPrefix argument ARG is passed to `org-timer'.\n\n(fn &optional ARG)" t)(autoload 'org-timer-set-timer "org-timer" "Prompt for a duration in minutes or hh:mm:ss and set a timer.\n\nIf `org-timer-default-timer' is not \"0\", suggest this value as\nthe default duration for the timer.  If a timer is already set,\nprompt the user if she wants to replace it.\n\nCalled with a numeric prefix argument OPT, use this numeric value as\nthe duration of the timer in minutes.\n\nCalled with a \\[universal-argument] prefix argument OPT, use\n`org-timer-default-timer' without prompting the user for a duration.\n\nWith two \\[universal-argument] prefix arguments OPT, use\n`org-timer-default-timer' without prompting the user for a duration\nand automatically replace any running timer.\n\nBy default, the timer duration will be set to the number of\nminutes in the Effort property, if any.  You can ignore this by\nusing three \\[universal-argument] prefix arguments.\n\n(fn &optional OPT)" t)(autoload 'org-export-get-backend "ox" "Return export backend named after NAME.\nNAME is a symbol.  Return nil if no such backend is found.\n\n(fn NAME)")(autoload 'org-export-derived-backend-p "ox" "Non-nil if BACKEND is derived from one of BACKENDS.\nBACKEND is an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.  BACKENDS is constituted of symbols.\n\n(fn BACKEND &rest BACKENDS)")(autoload 'org-export-get-environment "ox" "Collect export options from the current buffer.\n\nOptional argument BACKEND is an export backend, as returned by\n`org-export-create-backend'.\n\nWhen optional argument SUBTREEP is non-nil, assume the export is\ndone against the current sub-tree.\n\nThird optional argument EXT-PLIST is a property list with\nexternal parameters overriding Org default settings, but still\ninferior to file-local settings.\n\n(fn &optional BACKEND SUBTREEP EXT-PLIST)")(autoload 'org-export-data "ox" "Convert DATA into current backend format.\n\nDATA is a parse tree, an element or an object or a secondary\nstring.  INFO is a plist holding export options.\n\nThe `:filter-parse-tree' filters are not applied.\n\nReturn a string.\n\n(fn DATA INFO)")(autoload 'org-export-as "ox" "Transcode current Org buffer into BACKEND code.\n\nSee info node `(org)Advanced Export Configuration' for the details of\nthe transcoding process.\n\nBACKEND is either an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.\n\nIf narrowing is active in the current buffer, only transcode its\nnarrowed part.\n\nIf a region is active, transcode that region.\n\nWhen optional argument SUBTREEP is non-nil, transcode the\nsub-tree at point, extracting information from the headline\nproperties first.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only return body\ncode, without surrounding template.\n\nOptional argument EXT-PLIST, when provided, is a property list\nwith external parameters overriding Org default settings, but\nstill inferior to file-local settings.\n\nReturn code as a string.\n\n(fn BACKEND &optional SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)")(autoload 'org-export-string-as "ox" "Transcode STRING into BACKEND code.\n\nBACKEND is either an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.\n\nWhen optional argument BODY-ONLY is non-nil, only return body\ncode, without preamble nor postamble.\n\nOptional argument EXT-PLIST, when provided, is a property list\nwith external parameters overriding Org default settings, but\nstill inferior to file-local settings.\n\nReturn code as a string.\n\n(fn STRING BACKEND &optional BODY-ONLY EXT-PLIST)")(autoload 'org-export-replace-region-by "ox" "Replace the active region by its export to BACKEND.\nBACKEND is either an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.\n\n(fn BACKEND)")(autoload 'org-export-insert-default-template "ox" "Insert all export keywords with default values at beginning of line.\n\nBACKEND is a symbol referring to the name of a registered export\nbackend, for which specific export options should be added to\nthe template, or `default' for default template.  When it is nil,\nthe user will be prompted for a category.\n\nIf SUBTREEP is non-nil, export configuration will be set up\nlocally for the subtree through node properties.\n\n(fn &optional BACKEND SUBTREEP)" t)(autoload 'org-export-raw-string "ox" "Return a raw object containing string S.\nA raw string is exported as-is, with no additional processing\nfrom the export backend.\n\n(fn S)")(autoload 'org-export-to-buffer "ox" "Call `org-export-as' with output to a specified buffer.\n\nBACKEND is either an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.\n\nBUFFER is the name of the output buffer.  If it already exists,\nit will be erased first, otherwise, it will be created.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should then be accessible\nthrough the `org-export-stack' interface.  When ASYNC is nil, the\nbuffer is displayed if `org-export-show-temporary-export-buffer'\nis non-nil.\n\nOptional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and\nEXT-PLIST are similar to those used in `org-export-as', which\nsee.\n\nOptional argument POST-PROCESS is a function which should accept\nno argument.  It is always called within the current process,\nfrom BUFFER, with point at its beginning.  Export backends can\nuse it to set a major mode there, e.g.,\n\n  (defun org-latex-export-as-latex\n    (&optional async subtreep visible-only body-only ext-plist)\n    (interactive)\n    (org-export-to-buffer \\='latex \"*Org LATEX Export*\"\n      async subtreep visible-only body-only ext-plist\n      (major-mode-remap \\='latex-mode)))\n\nWhen expressed as an anonymous function, using `lambda',\nPOST-PROCESS needs to be quoted.\n\nThis function returns BUFFER.\n\n(fn BACKEND BUFFER &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST POST-PROCESS)")(function-put 'org-export-to-buffer 'lisp-indent-function 2)(autoload 'org-export-to-file "ox" "Call `org-export-as' with output to a specified file.\n\nBACKEND is either an export backend, as returned by, e.g.,\n`org-export-create-backend', or a symbol referring to\na registered backend.  FILE is the name of the output file, as\na string.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer will then be accessible\nthrough the `org-export-stack' interface.\n\nOptional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and\nEXT-PLIST are similar to those used in `org-export-as', which\nsee.\n\nOptional argument POST-PROCESS is called with FILE as its\nargument and happens asynchronously when ASYNC is non-nil.  It\nhas to return a file name, or nil.  Export backends can use this\nto send the output file through additional processing, e.g,\n\n  (defun org-latex-export-to-latex\n    (&optional async subtreep visible-only body-only ext-plist)\n    (interactive)\n    (let ((outfile (org-export-output-file-name \".tex\" subtreep)))\n      (org-export-to-file \\='latex outfile\n        async subtreep visible-only body-only ext-plist\n        #\\='org-latex-compile)))\n\nWhen expressed as an anonymous function, using `lambda',\nPOST-PROCESS needs to be quoted.\n\nThe function returns either a file name returned by POST-PROCESS,\nor FILE.\n\n(fn BACKEND FILE &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST POST-PROCESS)")(function-put 'org-export-to-file 'lisp-indent-function 2)(autoload 'org-export-dispatch "ox" "Export dispatcher for Org mode.\n\nIt provides an access to common export related tasks in a buffer.\nIts interface comes in two flavors: standard and expert.\n\nWhile both share the same set of bindings, only the former\ndisplays the valid keys associations in a dedicated buffer.\nScrolling (resp. line-wise motion) in this buffer is done with\nSPC and DEL (resp. C-n and C-p) keys.\n\nSet variable `org-export-dispatch-use-expert-ui' to switch to one\nflavor or the other.\n\nWhen ARG is `\\[universal-argument]', repeat the last export action, with the same\nset of options used back then, on the current buffer.\n\nWhen ARG is `\\[universal-argument] \\[universal-argument]', display the asynchronous export stack.\n\n(fn &optional ARG)" t)(autoload 'org-ascii-convert-region-to-ascii "ox-ascii" "Assume region has Org syntax, and convert it to plain ASCII." t)(autoload 'org-ascii-convert-region-to-utf8 "ox-ascii" "Assume region has Org syntax, and convert it to UTF-8." t)(autoload 'org-ascii-export-as-ascii "ox-ascii" "Export current buffer to a text buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, strip title and\ntable of contents from output.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org ASCII Export*\", which\nwill be displayed when `org-export-show-temporary-export-buffer'\nis non-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-ascii-export-to-ascii "ox-ascii" "Export current buffer to a text file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, strip title and\ntable of contents from output.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-ascii-publish-to-ascii "ox-ascii" "Publish an Org file to ASCII.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-ascii-publish-to-latin1 "ox-ascii" "Publish an Org file to Latin-1.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-ascii-publish-to-utf8 "ox-ascii" "Publish an org file to UTF-8.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-beamer-mode "ox-beamer" "Support for editing Beamer oriented Org mode files.\n\nThis is a minor mode.  If called interactively, toggle the\n`Org-Beamer mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `org-beamer-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'org-beamer-export-as-latex "ox-beamer" "Export current buffer as a Beamer buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org BEAMER Export*\", which\nwill be displayed when `org-export-show-temporary-export-buffer'\nis non-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-beamer-export-to-latex "ox-beamer" "Export current buffer as a Beamer presentation (tex).\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-beamer-export-to-pdf "ox-beamer" "Export current buffer as a Beamer presentation (PDF).\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn PDF file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-beamer-select-environment "ox-beamer" "Select the environment to be used by beamer for this entry.\nWhile this uses (for convenience) a tag selection interface, the\nresult of this command will be that the BEAMER_env *property* of\nthe entry is set.\n\nIn addition to this, the command will also set a tag as a visual\naid, but the tag does not have any semantic meaning." t)(autoload 'org-beamer-publish-to-latex "ox-beamer" "Publish an Org file to a Beamer presentation (LaTeX).\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-beamer-publish-to-pdf "ox-beamer" "Publish an Org file to a Beamer presentation (PDF, via LaTeX).\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(put 'org-html-head-include-default-style 'safe-local-variable 'booleanp)(put 'org-html-head 'safe-local-variable 'stringp)(put 'org-html-head-extra 'safe-local-variable 'stringp)(autoload 'org-html-htmlize-generate-css "ox-html" "Create the CSS for all font definitions in the current Emacs session.\nUse this to create face definitions in your CSS style file that can then\nbe used by code snippets transformed by htmlize.\nThis command just produces a buffer that contains class definitions for all\nfaces used in the current Emacs session.  You can copy and paste the ones you\nneed into your CSS file.\n\nThe face definitions are prepended with\n`org-html-htmlize-font-prefix'.\n\nIf you then set `org-html-htmlize-output-type' to `css', calls\nto the function `org-html-htmlize-region-for-paste' will\nproduce code that uses these same face definitions." t)(autoload 'org-html-export-as-html "ox-html" "Export current buffer to an HTML buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"<body>\" and \"</body>\" tags.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org HTML Export*\", which\nwill be displayed when `org-export-show-temporary-export-buffer'\nis non-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-html-convert-region-to-html "ox-html" "Assume the current region has Org syntax, and convert it to HTML.\nThis can be used in any buffer.  For example, you can write an\nitemized list in Org syntax in an HTML buffer and use this command\nto convert it." t)(autoload 'org-html-export-to-html "ox-html" "Export current buffer to a HTML file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"<body>\" and \"</body>\" tags.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-html-publish-to-html "ox-html" "Publish an org file to HTML.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-icalendar-export-to-ics "ox-icalendar" "Export current buffer to an iCalendar file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"BEGIN:VCALENDAR\" and \"END:VCALENDAR\".\n\nReturn ICS file name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY)" t)(autoload 'org-icalendar-export-agenda-files "ox-icalendar" "Export all agenda files to iCalendar files.\nWhen optional argument ASYNC is non-nil, export happens in an\nexternal process.\n\n(fn &optional ASYNC)" t)(autoload 'org-icalendar-combine-agenda-files "ox-icalendar" "Combine all agenda files into a single iCalendar file.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nThe file is stored under the name chosen in\n`org-icalendar-combined-agenda-file'.\n\n(fn &optional ASYNC)" t)(autoload 'org-koma-letter-export-as-latex "ox-koma-letter" "Export current buffer as a KOMA Scrlttr2 letter.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org KOMA-LETTER Export*\".  It\nwill be displayed if `org-export-show-temporary-export-buffer' is\nnon-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-koma-letter-export-to-latex "ox-koma-letter" "Export current buffer as a KOMA Scrlttr2 letter (tex).\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nWhen optional argument PUB-DIR is set, use it as the publishing\ndirectory.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-koma-letter-export-to-pdf "ox-koma-letter" "Export current buffer as a KOMA Scrlttr2 letter (pdf).\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn PDF file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-latex-make-preamble "ox-latex" "Return a formatted LaTeX preamble.\nINFO is a plist used as a communication channel.  Optional\nargument TEMPLATE, when non-nil, is the header template string,\nas expected by `org-splice-latex-header'.  When SNIPPET? is\nnon-nil, only includes packages relevant to image generation, as\nspecified in `org-latex-default-packages-alist' or\n`org-latex-packages-alist'.\n\n(fn INFO &optional TEMPLATE SNIPPET?)")(autoload 'org-latex-export-as-latex "ox-latex" "Export current buffer as a LaTeX buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org LATEX Export*\", which\nwill be displayed when `org-export-show-temporary-export-buffer'\nis non-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-latex-convert-region-to-latex "ox-latex" "Assume the current region has Org syntax, and convert it to LaTeX.\nThis can be used in any buffer.  For example, you can write an\nitemized list in Org syntax in an LaTeX buffer and use this\ncommand to convert it." t)(autoload 'org-latex-export-to-latex "ox-latex" "Export current buffer to a LaTeX file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-latex-export-to-pdf "ox-latex" "Export current buffer to LaTeX then process through to PDF.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn PDF file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-latex-publish-to-latex "ox-latex" "Publish an Org file to LaTeX.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-latex-publish-to-pdf "ox-latex" "Publish an Org file to PDF (via LaTeX).\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-md-export-as-markdown "ox-md" "Export current buffer to a Markdown buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nExport is done in a buffer named \"*Org MD Export*\", which will\nbe displayed when `org-export-show-temporary-export-buffer' is\nnon-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t)(autoload 'org-md-convert-region-to-md "ox-md" "Assume the current region has Org syntax, and convert it to Markdown.\nThis can be used in any buffer.  For example, you can write an\nitemized list in Org syntax in a Markdown buffer and use\nthis command to convert it." t)(autoload 'org-md-export-to-markdown "ox-md" "Export current buffer to a Markdown file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t)(autoload 'org-md-publish-to-md "ox-md" "Publish an org file to Markdown.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(put 'org-odt-preferred-output-format 'safe-local-variable 'stringp)(autoload 'org-odt-export-as-odf "ox-odt" "Export LATEX-FRAG as OpenDocument formula file ODF-FILE.\nUse `org-create-math-formula' to convert LATEX-FRAG first to\nMathML.  When invoked as an interactive command, use\n`org-latex-regexps' to infer LATEX-FRAG from currently active\nregion.  If no LaTeX fragments are found, prompt for it.  Push\nMathML source to kill ring depending on the value of\n`org-export-copy-to-kill-ring'.\n\n(fn LATEX-FRAG &optional ODF-FILE)" t)(autoload 'org-odt-export-as-odf-and-open "ox-odt" "Export LaTeX fragment as OpenDocument formula and immediately open it.\nUse `org-odt-export-as-odf' to read LaTeX fragment and OpenDocument\nformula file." t)(autoload 'org-odt-export-to-odt "ox-odt" "Export current buffer to a ODT file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY EXT-PLIST)" t)(autoload 'org-odt-convert "ox-odt" "Convert IN-FILE to format OUT-FMT using a command line converter.\nIN-FILE is the file to be converted.  If unspecified, it defaults\nto variable `buffer-file-name'.  OUT-FMT is the desired output\nformat.  Use `org-odt-convert-process' as the converter.  If OPEN\nis non-nil then the newly converted file is opened using\n`org-open-file'.\n\n(fn &optional IN-FILE OUT-FMT OPEN)" t)(autoload 'org-org-export-as-org "ox-org" "Export current buffer to an Org buffer.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting buffer should be accessible\nthrough the `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, strip document\nkeywords from output.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nExport is done in a buffer named \"*Org ORG Export*\", which will\nbe displayed when `org-export-show-temporary-export-buffer' is\nnon-nil.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-org-export-to-org "ox-org" "Export current buffer to an Org file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, strip document\nkeywords from output.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-org-publish-to-org "ox-org" "Publish an Org file to Org.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(defalias 'org-publish-project 'org-publish)(autoload 'org-publish "ox-publish" "Publish PROJECT.\n\nPROJECT is either a project name, as a string, or a project\nalist (see `org-publish-project-alist' variable).\n\nWhen optional argument FORCE is non-nil, force publishing all\nfiles in PROJECT.  With a non-nil optional argument ASYNC,\npublishing will be done asynchronously, in another process.\n\n(fn PROJECT &optional FORCE ASYNC)" t)(autoload 'org-publish-all "ox-publish" "Publish all projects.\nWith prefix argument FORCE, remove all files in the timestamp\ndirectory and force publishing all projects.  With a non-nil\noptional argument ASYNC, publishing will be done asynchronously,\nin another process.\n\n(fn &optional FORCE ASYNC)" t)(autoload 'org-publish-current-file "ox-publish" "Publish the current file.\nWith prefix argument FORCE, force publish the file.  When\noptional argument ASYNC is non-nil, publishing will be done\nasynchronously, in another process.\n\n(fn &optional FORCE ASYNC)" t)(autoload 'org-publish-current-project "ox-publish" "Publish the project associated with the current file.\nWith a prefix argument, force publishing of all files in\nthe project.\n\n(fn &optional FORCE ASYNC)" t)(autoload 'org-texinfo-export-to-texinfo "ox-texinfo" "Export current buffer to a Texinfo file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-texinfo-export-to-info "ox-texinfo" "Export current buffer to Texinfo then process through to INFO.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"\\begin{document}\" and \"\\end{document}\".\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn INFO file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-texinfo-publish-to-texinfo "ox-texinfo" "Publish an org file to Texinfo.\n\nFILENAME is the filename of the Org file to be published.  PLIST\nis the property list for the given project.  PUB-DIR is the\npublishing directory.\n\nReturn output file name.\n\n(fn PLIST FILENAME PUB-DIR)")(autoload 'org-texinfo-convert-region-to-texinfo "ox-texinfo" "Assume the current region has Org syntax, and convert it to Texinfo.\nThis can be used in any buffer.  For example, you can write an\nitemized list in Org syntax in an Texinfo buffer and use this\ncommand to convert it." t)(autoload 'dash-fontify-mode "dash" "Toggle fontification of Dash special variables.\n\nDash-Fontify mode is a buffer-local minor mode intended for Emacs\nLisp buffers.  Enabling it causes the special variables bound in\nanaphoric Dash macros to be fontified.  These anaphoras include\n`it', `it-index', `acc', and `other'.  In older Emacs versions\nwhich do not dynamically detect macros, Dash-Fontify mode\nadditionally fontifies Dash macro calls.\n\nSee also `dash-fontify-mode-lighter' and\n`global-dash-fontify-mode'.\n\nThis is a minor mode.  If called interactively, toggle the\n`Dash-Fontify mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `dash-fontify-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-dash-fontify-mode 'globalized-minor-mode t)(defvar global-dash-fontify-mode nil "Non-nil if Global Dash-Fontify mode is enabled.\nSee the `global-dash-fontify-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-dash-fontify-mode'.")(autoload 'global-dash-fontify-mode "dash" "Toggle Dash-Fontify mode in all buffers.\nWith prefix ARG, enable Global Dash-Fontify mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDash-Fontify mode is enabled in all buffers where\n`dash--turn-on-fontify-mode' would do it.\n\nSee `dash-fontify-mode' for more information on Dash-Fontify mode.\n\n(fn &optional ARG)" t)(autoload 'dash-register-info-lookup "dash" "Register the Dash Info manual with `info-lookup-symbol'.\nThis allows Dash symbols to be looked up with \\[info-lookup-symbol]." t)(with-eval-after-load 'magit (keymap-set magit-mode-map "<remap> <org-store-link>" #'orgit-store-link))(autoload 'orgit-store-link "orgit" "Like `org-store-link' but store links to all selected commits, if any.\n\n(fn ARG)" t)(with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit" :store #'orgit-status-store :follow #'orgit-status-open :export #'orgit-status-export :complete #'orgit-status-complete-link)))(autoload 'orgit-status-store "orgit" "Store a link to a Magit-Status mode buffer.\nWhen the region selects one or more commits, then do nothing.\nIn that case `orgit-rev-store' stores one or more links instead.")(autoload 'orgit-status-open "orgit" "\n\n(fn REPO)")(autoload 'orgit-status-export "orgit" "\n\n(fn PATH DESC FORMAT)")(autoload 'orgit-status-complete-link "orgit" "\n\n(fn &optional ARG)")(with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit-log" :store #'orgit-log-store :follow #'orgit-log-open :export #'orgit-log-export :complete #'orgit-log-complete-link)))(autoload 'orgit-log-store "orgit" "Store a link to a Magit-Log mode buffer.\nWhen the region selects one or more commits, then do nothing.\nIn that case `orgit-rev-store' stores one or more links instead.")(autoload 'orgit-log-open "orgit" "\n\n(fn PATH)")(autoload 'orgit-log-export "orgit" "\n\n(fn PATH DESC FORMAT)")(autoload 'orgit-log-complete-link "orgit" "\n\n(fn &optional ARG)")(with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit-rev" :store #'orgit-rev-store :follow #'orgit-rev-open :export #'orgit-rev-export :complete #'orgit-rev-complete-link)))(autoload 'orgit-rev-store "orgit" "Store a link to a Magit-Revision mode buffer.\n\nBy default store an abbreviated revision hash.\n\n\\<global-map>With a single \\[universal-argument] prefix argument instead store the name of a tag\nor branch that points at the revision, if any.  The meaning of this\nprefix argument is reversed if `orgit-store-reference' is non-nil.\n\nWith a single \\[negative-argument] negative prefix argument store revision using the\nform \":/TEXT\", which is described in the gitrevisions(7) manpage.\n\nWhen more than one prefix argument is used, then `org-store-link'\nstores a link itself, without calling this function.\n\nWhen the region selects one or more commits, e.g., in a log, then\nstore links to the Magit-Revision mode buffers for these commits.")(autoload 'orgit-rev-open "orgit" "\n\n(fn PATH)")(autoload 'orgit-rev-export "orgit" "\n\n(fn PATH DESC FORMAT)")(autoload 'orgit-rev-complete-link "orgit" "\n\n(fn &optional ARG)")(autoload 'seq-subseq "seq-25" "Return the sequence of elements of SEQUENCE from START to END.\nEND is exclusive.\n\nIf END is omitted, it defaults to the length of the sequence.  If\nSTART or END is negative, it counts from the end.  Signal an\nerror if START or END are outside of the sequence (i.e too large\nif positive or too small if negative).\n\n(fn SEQUENCE START &optional END)")(autoload 'seq-take "seq-25" "Return the sequence made of the first N elements of SEQUENCE.\nThe result is a sequence of the same type as SEQUENCE.\n\nIf N is a negative integer or zero, an empty sequence is\nreturned.\n\n(fn SEQUENCE N)")(autoload 'seq-sort-by "seq-25" "Sort SEQUENCE transformed by FUNCTION using PRED as the comparison function.\nElements of SEQUENCE are transformed by FUNCTION before being\nsorted.  FUNCTION must be a function of one argument.\n\n(fn FUNCTION PRED SEQUENCE)")(autoload 'seq-filter "seq-25" "Return a list of all the elements in SEQUENCE for which PRED returns non-nil.\n\n(fn PRED SEQUENCE)")(autoload 'seq-remove "seq-25" "Return a list of all the elements in SEQUENCE for which PRED returns nil.\n\n(fn PRED SEQUENCE)")(autoload 'seq-remove-at-position "seq-25" "Return a copy of SEQUENCE with the element at index N removed.\n\nN is the (zero-based) index of the element that should not be in\nthe result.\n\nThe result is a sequence of the same type as SEQUENCE.\n\n(fn SEQUENCE N)")(autoload 'seq-reduce "seq-25" "Reduce the function FUNCTION across SEQUENCE, starting with INITIAL-VALUE.\n\nReturn the result of calling FUNCTION with INITIAL-VALUE and the\nfirst element of SEQUENCE, then calling FUNCTION with that result\nand the second element of SEQUENCE, then with that result and the\nthird element of SEQUENCE, etc.  FUNCTION will be called with\nINITIAL-VALUE (and then the accumulated value) as the first\nargument, and the elements from SEQUENCE as the second argument.\n\nIf SEQUENCE is empty, return INITIAL-VALUE and FUNCTION is not called.\n\n(fn FUNCTION SEQUENCE INITIAL-VALUE)")(autoload 'seq-every-p "seq-25" "Return non-nil if PRED returns non-nil for all the elements of SEQUENCE.\n\n(fn PRED SEQUENCE)")(autoload 'seq-some "seq-25" "Return non-nil if PRED returns non-nil for at least one element of SEQUENCE.\nIf the value is non-nil, it is the first non-nil value returned by PRED.\n\n(fn PRED SEQUENCE)")(autoload 'seq-find "seq-25" "Return the first element in SEQUENCE for which PRED returns non-nil.\nIf no such element is found, return DEFAULT.\n\nNote that `seq-find' has an ambiguity if the found element is\nidentical to DEFAULT, as in that case it is impossible to know\nwhether an element was found or not.\n\n(fn PRED SEQUENCE &optional DEFAULT)")(autoload 'seq-position "seq-25" "Return the (zero-based) index of the first element in SEQUENCE \"equal\" to ELT.\n\"Equality\" is defined by the function TESTFN, which defaults to `equal'.\n\n(fn SEQUENCE ELT &optional TESTFN)")(autoload 'seq-positions "seq-25" "Return list of indices of SEQUENCE elements for which TESTFN returns non-nil.\n\nTESTFN is a two-argument function which is called with each element of\nSEQUENCE as the first argument and ELT as the second.\nTESTFN defaults to `equal'.\n\nThe result is a list of (zero-based) indices.\n\n(fn SEQUENCE ELT &optional TESTFN)")(autoload 'seq-uniq "seq-25" "Return a list of the elements of SEQUENCE with duplicates removed.\nTESTFN is used to compare elements, and defaults to `equal'.\n\n(fn SEQUENCE &optional TESTFN)")(autoload 'seq-union "seq-25" "Return a list of all the elements that appear in either SEQUENCE1 or SEQUENCE2.\n\"Equality\" of elements is defined by the function TESTFN, which\ndefaults to `equal'.\n\n(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)")(autoload 'seq-intersection "seq-25" "Return a list of all the elements that appear in both SEQUENCE1 and SEQUENCE2.\n\"Equality\" of elements is defined by the function TESTFN, which\ndefaults to `equal'.\n\n(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)")(autoload 'seq-group-by "seq-25" "Apply FUNCTION to each element of SEQUENCE.\nSeparate the elements of SEQUENCE into an alist using the results as\nkeys.  Keys are compared using `equal'.\n\n(fn FUNCTION SEQUENCE)")(autoload 'seq-max "seq-25" "Return the largest element of SEQUENCE.\nSEQUENCE must be a sequence of numbers or markers.\n\n(fn SEQUENCE)")(autoload 'seq-random-elt "seq-25" "Return a randomly chosen element from SEQUENCE.\nSignal an error if SEQUENCE is empty.\n\n(fn SEQUENCE)")(put 'git-commit-major-mode 'safe-local-variable (lambda (val) (memq val '(text-mode markdown-mode org-mode fundamental-mode git-commit-elisp-text-mode))))(autoload 'git-rebase-current-line "git-rebase" "Parse current line into a `git-rebase-action' instance.\nIf the current line isn't recognized as a rebase line, an\ninstance with all nil values is returned.")(autoload 'git-rebase-mode "git-rebase" "Major mode for editing of a Git rebase file.\n\nRebase files are generated when you run \"git rebase -i\" or run\n`magit-interactive-rebase'.  They describe how Git should perform\nthe rebase.  See the documentation for git-rebase (e.g., by\nrunning \"man git-rebase\" at the command line) for details.\n\n(fn)" t)(defconst git-rebase-filename-regexp "/git-rebase-todo\\'")(defvar magit-define-global-key-bindings 'default "Which set of key bindings to add to the global keymap, if any.\n\nThis option controls which set of Magit key bindings, if any, may\nbe added to the global keymap, even before Magit is first used in\nthe current Emacs session.\n\nIf the value is nil, no bindings are added.\n\nIf `default', maybe add:\n\n    C-x g     `magit-status'\n    C-x M-g   `magit-dispatch'\n    C-c M-g   `magit-file-dispatch'\n\nIf `recommended', maybe add:\n\n    C-x g     `magit-status'\n    C-c g     `magit-dispatch'\n    C-c f     `magit-file-dispatch'\n\n    These bindings are strongly recommended, but we cannot use\n    them by default, because the \"C-c <LETTER>\" namespace is\n    strictly reserved for bindings added by the user.\n\nThe bindings in the chosen set may be added when\n`after-init-hook' is run.  Each binding is added if, and only\nif, at that time no other key is bound to the same command,\nand no other command is bound to the same key.  In other words\nwe try to avoid adding bindings that are unnecessary, as well\nas bindings that conflict with other bindings.\n\nAdding these bindings is delayed until `after-init-hook' is\nrun to allow users to set the variable anywhere in their init\nfile (without having to make sure to do so before `magit' is\nloaded or autoloaded) and to increase the likelihood that all\nthe potentially conflicting user bindings have already been\nadded.\n\nTo set this variable use either `setq' or the Custom interface.\nDo not use the function `customize-set-variable' because doing\nthat would cause Magit to be loaded immediately, when that form\nis evaluated (this differs from `custom-set-variables', which\ndoesn't load the libraries that define the customized variables).\n\nSetting this variable has no effect if `after-init-hook' has\nalready been run.")(defun magit-maybe-define-global-key-bindings (&optional force) "See variable `magit-define-global-key-bindings'." (when magit-define-global-key-bindings (let ((map (current-global-map))) (pcase-dolist (`(,key \, def) (cond ((eq magit-define-global-key-bindings 'recommended) '(("C-x g" . magit-status) ("C-c g" . magit-dispatch) ("C-c f" . magit-file-dispatch))) ('(("C-x g" . magit-status) ("C-x M-g" . magit-dispatch) ("C-c M-g" . magit-file-dispatch))))) (when (or force (not (or (lookup-key map (kbd key)) (where-is-internal def (make-sparse-keymap) t)))) (define-key map (kbd key) def))))))(if after-init-time (magit-maybe-define-global-key-bindings) (add-hook 'after-init-hook #'magit-maybe-define-global-key-bindings t))(autoload 'magit-dispatch "magit" nil t)(autoload 'magit-run "magit" nil t)(autoload 'magit-git-command "magit" "Execute COMMAND asynchronously; display output.\n\nInteractively, prompt for COMMAND in the minibuffer. \"git \" is\nused as initial input, but can be deleted to run another command.\n\nWith a prefix argument COMMAND is run in the top-level directory\nof the current working tree, otherwise in `default-directory'.\n\n(fn COMMAND)" t)(autoload 'magit-git-command-topdir "magit" "Execute COMMAND asynchronously; display output.\n\nInteractively, prompt for COMMAND in the minibuffer. \"git \" is\nused as initial input, but can be deleted to run another command.\n\nCOMMAND is run in the top-level directory of the current\nworking tree.\n\n(fn COMMAND)" t)(autoload 'magit-shell-command "magit" "Execute COMMAND asynchronously; display output.\n\nInteractively, prompt for COMMAND in the minibuffer.  With a\nprefix argument COMMAND is run in the top-level directory of\nthe current working tree, otherwise in `default-directory'.\n\n(fn COMMAND)" t)(autoload 'magit-shell-command-topdir "magit" "Execute COMMAND asynchronously; display output.\n\nInteractively, prompt for COMMAND in the minibuffer.  COMMAND\nis run in the top-level directory of the current working tree.\n\n(fn COMMAND)" t)(autoload 'magit-version "magit" "Return the version of Magit currently in use.\n\nIf optional argument PRINT-DEST is non-nil, also print the used\nversions of Magit, Transient, Git and Emacs to the output stream\nselected by that argument.  Interactively use the echo area, or\nwith a prefix argument use the current buffer.  Additionally put\nthe output in the kill ring.\n\n(fn &optional PRINT-DEST)" t)(autoload 'magit-stage-buffer-file "magit-apply" "Stage all changes to the file being visited in the current buffer." t)(autoload 'magit-stage-file "magit-apply" "Read one or more files and stage all changes in those files.\nWith prefix argument FORCE, offer ignored files for completion.\n\n(fn FILES &optional FORCE)" t)(autoload 'magit-stage-modified "magit-apply" "Stage all changes to files modified in the worktree.\nStage all new content of tracked files and remove tracked files\nthat no longer exist in the working tree from the index also.\nWith a prefix argument also stage previously untracked (but not\nignored) files.\n\n(fn &optional ALL)" t)(autoload 'magit-unstage-buffer-file "magit-apply" "Unstage all changes to the file being visited in the current buffer." t)(autoload 'magit-unstage-file "magit-apply" "Read one or more files and unstage all changes to those files.\n\n(fn FILES)" t)(autoload 'magit-unstage-all "magit-apply" "Remove all changes from the staging area." t)(put 'magit-auto-revert-mode 'globalized-minor-mode t)(defvar magit-auto-revert-mode (not (or global-auto-revert-mode noninteractive)) "Non-nil if Magit-Auto-Revert mode is enabled.\nSee the `magit-auto-revert-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `magit-auto-revert-mode'.")(autoload 'magit-auto-revert-mode "magit-autorevert" "Toggle Auto-Revert mode in all buffers.\nWith prefix ARG, enable Magit-Auto-Revert mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nAuto-Revert mode is enabled in all buffers where\n`magit-turn-on-auto-revert-mode-if-desired' would do it.\n\nSee `auto-revert-mode' for more information on Auto-Revert mode.\n\n(fn &optional ARG)" t)(autoload 'magit-emacs-Q-command "magit-base" "Show a shell command that runs an uncustomized Emacs with only Magit loaded.\nSee info node `(magit)Debugging Tools' for more information." t)(define-advice Info-follow-nearest-node (:around (fn &optional fork) gitman) (let ((node (Info-get-token (point) "\\*note[ \n\11]+" "\\*note[ \n\11]+\\([^:]*\\):\\(:\\|[ \n\11]*(\\)?"))) (if (and node (string-match "^(gitman)\\(.+\\)" node)) (pcase magit-view-git-manual-method ('info (funcall fn fork)) ('man (require 'man) (man (match-string 1 node))) ('woman (require 'woman) (woman (match-string 1 node))) (_ (user-error "Invalid value for `magit-view-git-manual-method'"))) (funcall fn fork))))(define-advice org-man-export (:around (fn link description format) gitman) (if (and (eq format 'texinfo) (string-prefix-p "git" link)) (string-replace "%s" link "\n@ifinfo\n@ref{%s,,,gitman,}.\n@end ifinfo\n@ifhtml\n@html\nthe <a href=\"http://git-scm.com/docs/%s\">%s(1)</a> manpage.\n@end html\n@end ifhtml\n@iftex\nthe %s(1) manpage.\n@end iftex\n") (funcall fn link description format)))(autoload 'magit-bisect "magit-bisect" nil t)(autoload 'magit-bisect-start "magit-bisect" "Start a bisect session.\n\nBisecting a bug means to find the commit that introduced it.\nThis command starts such a bisect session by asking for a known\ngood and a known bad commit.  To move the session forward use the\nother actions from the bisect transient command (\\<magit-status-mode-map>\\[magit-bisect]).\n\n(fn BAD GOOD ARGS)" t)(autoload 'magit-bisect-reset "magit-bisect" "After bisecting, cleanup bisection state and return to original `HEAD'." t)(autoload 'magit-bisect-good "magit-bisect" "While bisecting, mark the current commit as good.\nUse this after you have asserted that the commit does not contain\nthe bug in question." t)(autoload 'magit-bisect-bad "magit-bisect" "While bisecting, mark the current commit as bad.\nUse this after you have asserted that the commit does contain the\nbug in question." t)(autoload 'magit-bisect-mark "magit-bisect" "While bisecting, mark the current commit with a bisect term.\nDuring a bisect using alternate terms, commits can still be\nmarked with `magit-bisect-good' and `magit-bisect-bad', as those\ncommands map to the correct term (\"good\" to --term-old's value\nand \"bad\" to --term-new's).  However, in some cases, it can be\ndifficult to keep that mapping straight in your head; this\ncommand provides an interface that exposes the underlying terms." t)(autoload 'magit-bisect-skip "magit-bisect" "While bisecting, skip the current commit.\nUse this if for some reason the current commit is not a good one\nto test.  This command lets Git choose a different one." t)(autoload 'magit-bisect-run "magit-bisect" "Bisect automatically by running commands after each step.\n\nUnlike `git bisect run' this can be used before bisecting has\nbegun.  In that case it behaves like `git bisect start; git\nbisect run'.\n\n(fn CMDLINE &optional BAD GOOD ARGS)" t)(autoload 'magit-blame-echo "magit-blame" nil t)(autoload 'magit-blame-addition "magit-blame" nil t)(autoload 'magit-blame-removal "magit-blame" nil t)(autoload 'magit-blame-reverse "magit-blame" nil t)(autoload 'magit-blame "magit-blame" nil t)(autoload 'magit-branch "magit" nil t)(autoload 'magit-checkout "magit-branch" "Checkout REVISION, updating the index and the working tree.\nIf REVISION is a local branch, then that becomes the current\nbranch.  If it is something else, then `HEAD' becomes detached.\nCheckout fails if the working tree or the staging area contain\nchanges.\n\n(git checkout REVISION).\n\n(fn REVISION &optional ARGS)" t)(function-put 'magit-checkout 'interactive-only 'magit--checkout)(autoload 'magit-branch-create "magit-branch" "Create BRANCH at branch or revision START-POINT.\n\n(fn BRANCH START-POINT)" t)(function-put 'magit-branch-create 'interactive-only 'magit-call-git)(autoload 'magit-branch-and-checkout "magit-branch" "Create and checkout BRANCH at branch or revision START-POINT.\n\n(fn BRANCH START-POINT &optional ARGS)" t)(function-put 'magit-branch-and-checkout 'interactive-only 'magit-call-git)(autoload 'magit-branch-or-checkout "magit-branch" "Hybrid between `magit-checkout' and `magit-branch-and-checkout'.\n\nAsk the user for an existing branch or revision.  If the user\ninput actually can be resolved as a branch or revision, then\ncheck that out, just like `magit-checkout' would.\n\nOtherwise create and checkout a new branch using the input as\nits name.  Before doing so read the starting-point for the new\nbranch.  This is similar to what `magit-branch-and-checkout'\ndoes.\n\n(fn ARG &optional START-POINT)" t)(function-put 'magit-branch-or-checkout 'interactive-only 'magit-call-git)(autoload 'magit-branch-checkout "magit-branch" "Checkout an existing or new local branch.\n\nRead a branch name from the user offering all local branches and\na subset of remote branches as candidates.  Omit remote branches\nfor which a local branch by the same name exists from the list\nof candidates.  The user can also enter a completely new branch\nname.\n\n- If the user selects an existing local branch, then check that\n  out.\n\n- If the user selects a remote branch, then create and checkout\n  a new local branch with the same name.  Configure the selected\n  remote branch as push target.\n\n- If the user enters a new branch name, then create and check\n  that out, after also reading the starting-point from the user.\n\nIn the latter two cases the upstream is also set.  Whether it is\nset to the chosen START-POINT or something else depends on the\nvalue of `magit-branch-adjust-remote-upstream-alist', just like\nwhen using `magit-branch-and-checkout'.\n\n(fn BRANCH &optional START-POINT)" t)(function-put 'magit-branch-checkout 'interactive-only 'magit-call-git)(autoload 'magit-branch-orphan "magit-branch" "Create and checkout an orphan BRANCH with contents from revision START-POINT.\n\n(fn BRANCH START-POINT)" t)(autoload 'magit-branch-spinout "magit-branch" "Create new branch from the unpushed commits.\nLike `magit-branch-spinoff' but remain on the current branch.\nIf there are any uncommitted changes, then behave exactly like\n`magit-branch-spinoff'.\n\n(fn BRANCH &optional FROM)" t)(autoload 'magit-branch-spinoff "magit-branch" "Create new branch from the unpushed commits.\n\nCreate and checkout a new branch starting at and tracking the\ncurrent branch.  That branch in turn is reset to the last commit\nit shares with its upstream.  If the current branch has no\nupstream or no unpushed commits, then the new branch is created\nanyway and the previously current branch is not touched.\n\nThis is useful to create a feature branch after work has already\nbegan on the old branch (likely but not necessarily \"master\").\n\nIf the current branch is a member of the value of option\n`magit-branch-prefer-remote-upstream' (which see), then the\ncurrent branch will be used as the starting point as usual, but\nthe upstream of the starting-point may be used as the upstream\nof the new branch, instead of the starting-point itself.\n\nIf optional FROM is non-nil, then the source branch is reset\nto `FROM~', instead of to the last commit it shares with its\nupstream.  Interactively, FROM is only ever non-nil, if the\nregion selects some commits, and among those commits, FROM is\nthe commit that is the fewest commits ahead of the source\nbranch.\n\nThe commit at the other end of the selection actually does not\nmatter, all commits between FROM and `HEAD' are moved to the new\nbranch.  If FROM is not reachable from `HEAD' or is reachable\nfrom the source branch's upstream, then an error is raised.\n\n(fn BRANCH &optional FROM)" t)(autoload 'magit-branch-reset "magit-branch" "Reset a branch to the tip of another branch or any other commit.\n\nWhen the branch being reset is the current branch, then do a\nhard reset.  If there are any uncommitted changes, then the user\nhas to confirm the reset because those changes would be lost.\n\nThis is useful when you have started work on a feature branch but\nrealize it's all crap and want to start over.\n\nWhen resetting to another branch and a prefix argument is used,\nthen also set the target branch as the upstream of the branch\nthat is being reset.\n\n(fn BRANCH TO &optional SET-UPSTREAM)" t)(autoload 'magit-branch-delete "magit-branch" "Delete one or multiple branches.\n\nIf the region marks multiple branches, then offer to delete\nthose, otherwise prompt for a single branch to be deleted,\ndefaulting to the branch at point.\n\nRequire confirmation when deleting branches is dangerous in some\nway.  Option `magit-no-confirm' can be customized to not require\nconfirmation in certain cases.  See its docstring to learn why\nconfirmation is required by default in certain cases or if a\nprompt is confusing.\n\n(fn BRANCHES &optional FORCE)" t)(autoload 'magit-branch-rename "magit-branch" "Rename the branch named OLD to NEW.\n\nWith a prefix argument FORCE, rename even if a branch named NEW\nalready exists.\n\nIf `branch.OLD.pushRemote' is set, then unset it.  Depending on\nthe value of `magit-branch-rename-push-target' (which see) maybe\nset `branch.NEW.pushRemote' and maybe rename the push-target on\nthe remote.\n\n(fn OLD NEW &optional FORCE)" t)(autoload 'magit-branch-shelve "magit-branch" "Shelve a BRANCH.\nRename \"refs/heads/BRANCH\" to \"refs/shelved/BRANCH\",\nand also rename the respective reflog file.\n\n(fn BRANCH)" t)(autoload 'magit-branch-unshelve "magit-branch" "Unshelve a BRANCH\nRename \"refs/shelved/BRANCH\" to \"refs/heads/BRANCH\",\nand also rename the respective reflog file.\n\n(fn BRANCH)" t)(autoload 'magit-branch-configure "magit-branch" nil t)(autoload 'magit-bundle "magit-bundle" nil t)(autoload 'magit-bundle-import "magit-bundle" nil t)(autoload 'magit-bundle-create-tracked "magit-bundle" "Create and track a new bundle.\n\n(fn FILE TAG BRANCH REFS ARGS)" t)(autoload 'magit-bundle-update-tracked "magit-bundle" "Update a bundle that is being tracked using TAG.\n\n(fn TAG)" t)(autoload 'magit-bundle-verify "magit-bundle" "Check whether FILE is valid and applies to the current repository.\n\n(fn FILE)" t)(autoload 'magit-bundle-list-heads "magit-bundle" "List the refs in FILE.\n\n(fn FILE)" t)(autoload 'magit-clone "magit-clone" nil t)(autoload 'magit-clone-regular "magit-clone" "Create a clone of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\n\n(fn REPOSITORY DIRECTORY ARGS)" t)(autoload 'magit-clone-shallow "magit-clone" "Create a shallow clone of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\nWith a prefix argument read the DEPTH of the clone;\notherwise use 1.\n\n(fn REPOSITORY DIRECTORY ARGS DEPTH)" t)(autoload 'magit-clone-shallow-since "magit-clone" "Create a shallow clone of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\nExclude commits before DATE, which is read from the\nuser.\n\n(fn REPOSITORY DIRECTORY ARGS DATE)" t)(autoload 'magit-clone-shallow-exclude "magit-clone" "Create a shallow clone of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\nExclude commits reachable from EXCLUDE, which is a\nbranch or tag read from the user.\n\n(fn REPOSITORY DIRECTORY ARGS EXCLUDE)" t)(autoload 'magit-clone-bare "magit-clone" "Create a bare clone of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\n\n(fn REPOSITORY DIRECTORY ARGS)" t)(autoload 'magit-clone-mirror "magit-clone" "Create a mirror of REPOSITORY in DIRECTORY.\nThen show the status buffer for the new repository.\n\n(fn REPOSITORY DIRECTORY ARGS)" t)(autoload 'magit-clone-sparse "magit-clone" "Clone REPOSITORY into DIRECTORY and create a sparse checkout.\n\n(fn REPOSITORY DIRECTORY ARGS)" t)(autoload 'magit-commit "magit-commit" nil t)(autoload 'magit-commit-create "magit-commit" "Create a new commit on `HEAD'.\nWith a prefix argument, amend to the commit at `HEAD' instead.\n\n(git commit [--amend] ARGS)\n\n(fn &optional ARGS)" t)(autoload 'magit-commit-amend "magit-commit" "Amend the last commit.\n\n(git commit --amend ARGS)\n\n(fn &optional ARGS)" t)(autoload 'magit-commit-extend "magit-commit" "Amend the last commit, without editing the message.\n\nWith a prefix argument keep the committer date, otherwise change\nit.  The option `magit-commit-extend-override-date' can be used\nto inverse the meaning of the prefix argument.\n\n(git commit --amend --no-edit)\n\n(fn &optional ARGS OVERRIDE-DATE)" t)(autoload 'magit-commit-reword "magit-commit" "Reword the last commit, ignoring staged changes.\n\nWith a prefix argument keep the committer date, otherwise change\nit.  The option `magit-commit-reword-override-date' can be used\nto inverse the meaning of the prefix argument.\n\nNon-interactively respect the optional OVERRIDE-DATE argument\nand ignore the option.\n\n(git commit --amend --only)\n\n(fn &optional ARGS OVERRIDE-DATE)" t)(autoload 'magit-commit-fixup "magit-commit" "Create a fixup commit.\n\nWith a prefix argument the target COMMIT has to be confirmed.\nOtherwise the commit at point may be used without confirmation\ndepending on the value of option `magit-commit-squash-confirm'.\n\n(fn &optional COMMIT ARGS)" t)(autoload 'magit-commit-squash "magit-commit" "Create a squash commit, without editing the squash message.\n\nWith a prefix argument the target COMMIT has to be confirmed.\nOtherwise the commit at point may be used without confirmation\ndepending on the value of option `magit-commit-squash-confirm'.\n\nIf you want to immediately add a message to the squash commit,\nthen use `magit-commit-augment' instead of this command.\n\n(fn &optional COMMIT ARGS)" t)(autoload 'magit-commit-augment "magit-commit" "Create a squash commit, editing the squash message.\n\nWith a prefix argument the target COMMIT has to be confirmed.\nOtherwise the commit at point may be used without confirmation\ndepending on the value of option `magit-commit-squash-confirm'.\n\n(fn &optional COMMIT ARGS)" t)(autoload 'magit-commit-instant-fixup "magit-commit" "Create a fixup commit targeting COMMIT and instantly rebase.\n\n(fn &optional COMMIT ARGS)" t)(autoload 'magit-commit-instant-squash "magit-commit" "Create a squash commit targeting COMMIT and instantly rebase.\n\n(fn &optional COMMIT ARGS)" t)(autoload 'magit-commit-reshelve "magit-commit" "Change the committer date and possibly the author date of `HEAD'.\n\nThe current time is used as the initial minibuffer input and the\noriginal author or committer date is available as the previous\nhistory element.\n\nBoth the author and the committer dates are changed, unless one\nof the following is true, in which case only the committer date\nis updated:\n- You are not the author of the commit that is being reshelved.\n- The command was invoked with a prefix argument.\n- Non-interactively if UPDATE-AUTHOR is nil.\n\n(fn DATE UPDATE-AUTHOR &optional ARGS)" t)(autoload 'magit-commit-absorb-modules "magit-commit" "Spread modified modules across recent commits.\n\n(fn PHASE COMMIT)" t)(autoload 'magit-commit-absorb "magit-commit" nil t)(autoload 'magit-commit-autofixup "magit-commit" nil t)(autoload 'magit-diff "magit-diff" nil t)(autoload 'magit-diff-refresh "magit-diff" nil t)(autoload 'magit-diff-dwim "magit-diff" "Show changes for the thing at point.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-diff-range "magit-diff" "Show differences between two commits.\n\nREV-OR-RANGE should be a range or a single revision.  If it is a\nrevision, then show changes in the working tree relative to that\nrevision.  If it is a range, but one side is omitted, then show\nchanges relative to `HEAD'.\n\nIf the region is active, use the revisions on the first and last\nline of the region as the two sides of the range.  With a prefix\nargument, instead of diffing the revisions, choose a revision to\nview changes along, starting at the common ancestor of both\nrevisions (i.e., use a \"...\" range).\n\n(fn REV-OR-RANGE &optional ARGS FILES)" t)(autoload 'magit-diff-working-tree "magit-diff" "Show changes between the current working tree and the `HEAD' commit.\nWith a prefix argument show changes between the working tree and\na commit read from the minibuffer.\n\n(fn &optional REV ARGS FILES)" t)(autoload 'magit-diff-staged "magit-diff" "Show changes between the index and the `HEAD' commit.\nWith a prefix argument show changes between the index and\na commit read from the minibuffer.\n\n(fn &optional REV ARGS FILES)" t)(autoload 'magit-diff-unstaged "magit-diff" "Show changes between the working tree and the index.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-diff-unmerged "magit-diff" "Show changes that are being merged.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-diff-while-committing "magit-diff" "While committing, show the changes that are about to be committed.\nWhile amending, invoking the command again toggles between\nshowing just the new changes or all the changes that will\nbe committed." t)(autoload 'magit-diff-buffer-file "magit-diff" "Show diff for the blob or file visited in the current buffer.\n\nWhen the buffer visits a blob, then show the respective commit.\nWhen the buffer visits a file, then show the differences between\n`HEAD' and the working tree.  In both cases limit the diff to\nthe file or blob." t)(autoload 'magit-diff-paths "magit-diff" "Show changes between any two files on disk.\n\n(fn A B)" t)(autoload 'magit-show-commit "magit-diff" "Visit the revision at point in another buffer.\nIf there is no revision at point or with a prefix argument prompt\nfor a revision.\n\n(fn REV &optional ARGS FILES MODULE)" t)(autoload 'magit-ediff "magit-ediff" nil)(autoload 'magit-ediff-resolve-all "magit-ediff" "Resolve all conflicts in the FILE at point using Ediff.\n\nIf there is no file at point or if it doesn't have any unmerged\nchanges, then prompt for a file.\n\nSee info node `(magit) Ediffing' for more information about this\nand alternative commands.\n\n(fn FILE)" t)(autoload 'magit-ediff-resolve-rest "magit-ediff" "Resolve outstanding conflicts in the FILE at point using Ediff.\n\nIf there is no file at point or if it doesn't have any unmerged\nchanges, then prompt for a file.\n\nSee info node `(magit) Ediffing' for more information about this\nand alternative commands.\n\n(fn FILE)" t)(autoload 'magit-ediff-stage "magit-ediff" "Stage and unstage changes to FILE using Ediff.\nFILE has to be relative to the top directory of the repository.\n\n(fn FILE)" t)(autoload 'magit-ediff-compare "magit-ediff" "Compare REVA:FILEA with REVB:FILEB using Ediff.\n\nFILEA and FILEB have to be relative to the top directory of the\nrepository.  If REVA or REVB is nil, then this stands for the\nworking tree state.\n\nIf the region is active, use the revisions on the first and last\nline of the region.  With a prefix argument, instead of diffing\nthe revisions, choose a revision to view changes along, starting\nat the common ancestor of both revisions (i.e., use a \"...\"\nrange).\n\n(fn REVA REVB FILEA FILEB)" t)(autoload 'magit-ediff-dwim "magit-ediff" "Compare, stage, or resolve using Ediff.\nThis command tries to guess what file, and what commit or range\nthe user wants to compare, stage, or resolve using Ediff.  It\nmight only be able to guess either the file, or range or commit,\nin which case the user is asked about the other.  It might not\nalways guess right, in which case the appropriate `magit-ediff-*'\ncommand has to be used explicitly.  If it cannot read the user's\nmind at all, then it asks the user for a command to run." t)(autoload 'magit-ediff-show-staged "magit-ediff" "Show staged changes using Ediff.\n\nThis only allows looking at the changes; to stage, unstage,\nand discard changes using Ediff, use `magit-ediff-stage'.\n\nFILE must be relative to the top directory of the repository.\n\n(fn FILE)" t)(autoload 'magit-ediff-show-unstaged "magit-ediff" "Show unstaged changes using Ediff.\n\nThis only allows looking at the changes; to stage, unstage,\nand discard changes using Ediff, use `magit-ediff-stage'.\n\nFILE must be relative to the top directory of the repository.\n\n(fn FILE)" t)(autoload 'magit-ediff-show-working-tree "magit-ediff" "Show changes between `HEAD' and working tree using Ediff.\nFILE must be relative to the top directory of the repository.\n\n(fn FILE)" t)(autoload 'magit-ediff-show-commit "magit-ediff" "Show changes introduced by COMMIT using Ediff.\n\n(fn COMMIT)" t)(autoload 'magit-ediff-show-stash "magit-ediff" "Show changes introduced by STASH using Ediff.\n`magit-ediff-show-stash-with-index' controls whether a\nthree-buffer Ediff is used in order to distinguish changes in the\nstash that were staged.\n\n(fn STASH)" t)(autoload 'magit-git-mergetool "magit-extras" nil t)(autoload 'magit-run-git-gui-blame "magit-extras" "Run `git gui blame' on the given FILENAME and COMMIT.\nInteractively run it for the current file and the `HEAD', with a\nprefix or when the current file cannot be determined let the user\nchoose.  When the current buffer is visiting FILENAME instruct\nblame to center around the line point is on.\n\n(fn COMMIT FILENAME &optional LINENUM)" t)(autoload 'magit-run-git-gui "magit-extras" "Run `git gui' for the current git repository." t)(autoload 'magit-run-gitk "magit-extras" "Run `gitk' in the current repository." t)(autoload 'magit-run-gitk-branches "magit-extras" "Run `gitk --branches' in the current repository." t)(autoload 'magit-run-gitk-all "magit-extras" "Run `gitk --all' in the current repository." t)(autoload 'ido-enter-magit-status "magit-extras" "Drop into `magit-status' from file switching.\n\nTo make this command available use something like:\n\n  (keymap-set ido-common-completion-map\n              \"C-x g\" \\='ido-enter-magit-status)\n\nThis command does not work in Emacs 26.1.\nSee https://github.com/magit/magit/issues/3634\nand https://debbugs.gnu.org/cgi/bugreport.cgi?bug=31707." t)(autoload 'magit-project-status "magit-extras" "Run `magit-status' in the current project's root." t)(autoload 'magit-dired-jump "magit-extras" "Visit file at point using Dired.\nWith a prefix argument, visit in another window.  If there\nis no file at point, then instead visit `default-directory'.\n\n(fn &optional OTHER-WINDOW)" t)(autoload 'magit-dired-log "magit-extras" "Show log for all marked files, or the current file.\n\n(fn &optional FOLLOW)" t)(autoload 'magit-dired-am-apply-patches "magit-extras" "In Dired, apply the marked (or next ARG) files as patches.\nIf inside a repository, then apply in that.  Otherwise prompt\nfor a repository.\n\n(fn REPO &optional ARG)" t)(autoload 'magit-do-async-shell-command "magit-extras" "Open FILE with `dired-do-async-shell-command'.\nInteractively, open the file at point.\n\n(fn FILE)" t)(autoload 'magit-previous-line "magit-extras" "Like `previous-line' but with Magit-specific shift-selection.\n\nMagit's selection mechanism is based on the region but selects an\narea that is larger than the region.  This causes `previous-line'\nwhen invoked while holding the shift key to move up one line and\nthereby select two lines.  When invoked inside a hunk body this\ncommand does not move point on the first invocation and thereby\nit only selects a single line.  Which inconsistency you prefer\nis a matter of preference.\n\n(fn &optional ARG TRY-VSCROLL)" t)(function-put 'magit-previous-line 'interactive-only '"use `forward-line' with negative argument instead.")(autoload 'magit-next-line "magit-extras" "Like `next-line' but with Magit-specific shift-selection.\n\nMagit's selection mechanism is based on the region but selects\nan area that is larger than the region.  This causes `next-line'\nwhen invoked while holding the shift key to move down one line\nand thereby select two lines.  When invoked inside a hunk body\nthis command does not move point on the first invocation and\nthereby it only selects a single line.  Which inconsistency you\nprefer is a matter of preference.\n\n(fn &optional ARG TRY-VSCROLL)" t)(function-put 'magit-next-line 'interactive-only 'forward-line)(autoload 'magit-clean "magit-extras" "Remove untracked files from the working tree.\nWith a prefix argument also remove ignored files,\nwith two prefix arguments remove ignored files only.\n\n(git clean -f -d [-x|-X])\n\n(fn &optional ARG)" t)(autoload 'magit-generate-changelog "magit-extras" "Insert ChangeLog entries into the current buffer.\n\nThe entries are generated from the diff being committed.\nIf prefix argument, AMENDING, is non-nil, include changes\nin HEAD as well as staged changes in the diff to check.\n\n(fn &optional AMENDING)" t)(autoload 'magit-add-change-log-entry "magit-extras" "Find change log file and add date entry and item for current change.\nThis differs from `add-change-log-entry' (which see) in that\nit acts on the current hunk in a Magit buffer instead of on\na position in a file-visiting buffer.\n\n(fn &optional WHOAMI FILE-NAME OTHER-WINDOW)" t)(autoload 'magit-add-change-log-entry-other-window "magit-extras" "Find change log file in other window and add entry and item.\nThis differs from `add-change-log-entry-other-window' (which see)\nin that it acts on the current hunk in a Magit buffer instead of\non a position in a file-visiting buffer.\n\n(fn &optional WHOAMI FILE-NAME)" t)(autoload 'magit-edit-line-commit "magit-extras" "Edit the commit that added the current line.\n\nWith a prefix argument edit the commit that removes the line,\nif any.  The commit is determined using `git blame' and made\neditable using `git rebase --interactive' if it is reachable\nfrom `HEAD', or by checking out the commit (or a branch that\npoints at it) otherwise.\n\n(fn &optional TYPE)" t)(autoload 'magit-diff-edit-hunk-commit "magit-extras" "From a hunk, edit the respective commit and visit the file.\n\nFirst visit the file being modified by the hunk at the correct\nlocation using `magit-diff-visit-file'.  This actually visits a\nblob.  When point is on a diff header, not within an individual\nhunk, then this visits the blob the first hunk is about.\n\nThen invoke `magit-edit-line-commit', which uses an interactive\nrebase to make the commit editable, or if that is not possible\nbecause the commit is not reachable from `HEAD' by checking out\nthat commit directly.  This also causes the actual worktree file\nto be visited.\n\nNeither the blob nor the file buffer are killed when finishing\nthe rebase.  If that is undesirable, then it might be better to\nuse `magit-rebase-edit-commit' instead of this command.\n\n(fn FILE)" t)(autoload 'magit-reshelve-since "magit-extras" "Change the author and committer dates of the commits since REV.\n\nAsk the user for the first reachable commit whose dates should\nbe changed.  Then read the new date for that commit.  The initial\nminibuffer input and the previous history element offer good\nvalues.  The next commit will be created one minute later and so\non.\n\nThis command is only intended for interactive use and should only\nbe used on highly rearranged and unpublished history.\n\nIf KEYID is non-nil, then use that to sign all reshelved commits.\nInteractively use the value of the \"--gpg-sign\" option in the\nlist returned by `magit-rebase-arguments'.\n\n(fn REV KEYID)" t)(autoload 'magit-pop-revision-stack "magit-extras" "Insert a representation of a revision into the current buffer.\n\nPop a revision from the `magit-revision-stack' and insert it into\nthe current buffer according to `magit-pop-revision-stack-format'.\nRevisions can be put on the stack using `magit-copy-section-value'\nand `magit-copy-buffer-revision'.\n\nIf the stack is empty or with a prefix argument, instead read a\nrevision in the minibuffer.  By using the minibuffer history this\nallows selecting an item which was popped earlier or to insert an\narbitrary reference or revision without first pushing it onto the\nstack.\n\nWhen reading the revision from the minibuffer, then it might not\nbe possible to guess the correct repository.  When this command\nis called inside a repository (e.g., while composing a commit\nmessage), then that repository is used.  Otherwise (e.g., while\ncomposing an email) then the repository recorded for the top\nelement of the stack is used (even though we insert another\nrevision).  If not called inside a repository and with an empty\nstack, or with two prefix arguments, then read the repository in\nthe minibuffer too.\n\n(fn REV TOPLEVEL)" t)(autoload 'magit-copy-section-value "magit-extras" "Save the value of the current section for later use.\n\nSave the section value to the `kill-ring', and, provided that\nthe current section is a commit, branch, or tag section, push\nthe (referenced) revision to the `magit-revision-stack' for use\nwith `magit-pop-revision-stack'.\n\nWhen `magit-copy-revision-abbreviated' is non-nil, save the\nabbreviated revision to the `kill-ring' and the\n`magit-revision-stack'.\n\nWhen the current section is a branch or a tag, and a prefix\nargument is used, then save the revision at its tip to the\n`kill-ring' instead of the reference name.\n\nWhen the region is active, then save that to the `kill-ring',\nlike `kill-ring-save' would, instead of behaving as described\nabove.  If a prefix argument is used and the region is within\na hunk, then strip the diff marker column and keep only either\nthe added or removed lines, depending on the sign of the prefix\nargument.\n\n(fn ARG)" t)(autoload 'magit-copy-buffer-revision "magit-extras" "Save the revision of the current buffer for later use.\n\nSave the revision shown in the current buffer to the `kill-ring'\nand push it to the `magit-revision-stack'.\n\nThis command is mainly intended for use in `magit-revision-mode'\nbuffers, the only buffers where it is always unambiguous exactly\nwhich revision should be saved.\n\nMost other Magit buffers usually show more than one revision, in\nsome way or another, so this command has to select one of them,\nand that choice might not always be the one you think would have\nbeen the best pick.\n\nIn such buffers it is often more useful to save the value of\nthe current section instead, using `magit-copy-section-value'.\n\nWhen the region is active, then save that to the `kill-ring',\nlike `kill-ring-save' would, instead of behaving as described\nabove.\n\nWhen `magit-copy-revision-abbreviated' is non-nil, save the\nabbreviated revision to the `kill-ring' and the\n`magit-revision-stack'." t)(autoload 'magit-display-repository-buffer "magit-extras" "Display a Magit buffer belonging to the current Git repository.\nThe buffer is displayed using `magit-display-buffer', which see.\n\n(fn BUFFER)" t)(autoload 'magit-switch-to-repository-buffer "magit-extras" "Switch to a Magit buffer belonging to the current Git repository.\n\n(fn BUFFER)" t)(autoload 'magit-switch-to-repository-buffer-other-window "magit-extras" "Switch to a Magit buffer belonging to the current Git repository.\n\n(fn BUFFER)" t)(autoload 'magit-switch-to-repository-buffer-other-frame "magit-extras" "Switch to a Magit buffer belonging to the current Git repository.\n\n(fn BUFFER)" t)(autoload 'magit-abort-dwim "magit-extras" "Abort current operation.\nDepending on the context, this will abort a merge, a rebase, a\npatch application, a cherry-pick, a revert, or a bisect." t)(autoload 'magit-back-to-indentation "magit-extras" "Move point to the first non-whitespace character on this line.\nIn Magit diffs, also skip over - and + at the beginning of the line." t)(autoload 'magit-fetch "magit-fetch" nil t)(autoload 'magit-fetch-from-pushremote "magit-fetch" nil t)(autoload 'magit-fetch-from-upstream "magit-fetch" nil t)(autoload 'magit-fetch-other "magit-fetch" "Fetch from another repository.\n\n(fn REMOTE ARGS)" t)(autoload 'magit-fetch-branch "magit-fetch" "Fetch a BRANCH from a REMOTE.\n\n(fn REMOTE BRANCH ARGS)" t)(autoload 'magit-fetch-refspec "magit-fetch" "Fetch a REFSPEC from a REMOTE.\n\n(fn REMOTE REFSPEC ARGS)" t)(autoload 'magit-fetch-all "magit-fetch" "Fetch from all remotes.\n\n(fn ARGS)" t)(autoload 'magit-fetch-all-prune "magit-fetch" "Fetch from all remotes, and prune.\nPrune remote tracking branches for branches that have been\nremoved on the respective remote." t)(autoload 'magit-fetch-all-no-prune "magit-fetch" "Fetch from all remotes." t)(autoload 'magit-fetch-modules "magit-fetch" nil t)(autoload 'magit-find-file "magit-files" "View FILE from REV.\nSwitch to a buffer visiting blob REV:FILE, creating one if none\nalready exists.  If prior to calling this command the current\nbuffer and/or cursor position is about the same file, then go\nto the line and column corresponding to that location.\n\n(fn REV FILE)" t)(autoload 'magit-find-file-other-window "magit-files" "View FILE from REV, in another window.\nSwitch to a buffer visiting blob REV:FILE, creating one if none\nalready exists.  If prior to calling this command the current\nbuffer and/or cursor position is about the same file, then go to\nthe line and column corresponding to that location.\n\n(fn REV FILE)" t)(autoload 'magit-find-file-other-frame "magit-files" "View FILE from REV, in another frame.\nSwitch to a buffer visiting blob REV:FILE, creating one if none\nalready exists.  If prior to calling this command the current\nbuffer and/or cursor position is about the same file, then go to\nthe line and column corresponding to that location.\n\n(fn REV FILE)" t)(autoload 'magit-file-dispatch "magit" nil t)(autoload 'magit-blob-visit-file "magit-files" "View the file from the worktree corresponding to the current blob.\nWhen visiting a blob or the version from the index, then go to\nthe same location in the respective file in the working tree." t)(autoload 'magit-file-checkout "magit-files" "Checkout FILE from REV.\n\n(fn REV FILE)" t)(autoload 'magit-gitignore "magit-gitignore" nil t)(autoload 'magit-gitignore-in-topdir "magit-gitignore" "Add the Git ignore RULE to the top-level \".gitignore\" file.\nSince this file is tracked, it is shared with other clones of the\nrepository.  Also stage the file.\n\n(fn RULE)" t)(autoload 'magit-gitignore-in-subdir "magit-gitignore" "Add the Git ignore RULE to a \".gitignore\" file in DIRECTORY.\nPrompt the user for a directory and add the rule to the\n\".gitignore\" file in that directory.  Since such files are\ntracked, they are shared with other clones of the repository.\nAlso stage the file.\n\n(fn RULE DIRECTORY)" t)(autoload 'magit-gitignore-in-gitdir "magit-gitignore" "Add the Git ignore RULE to \"$GIT_DIR/info/exclude\".\nRules in that file only affects this clone of the repository.\n\n(fn RULE)" t)(autoload 'magit-gitignore-on-system "magit-gitignore" "Add the Git ignore RULE to the file specified by `core.excludesFile'.\nRules that are defined in that file affect all local repositories.\n\n(fn RULE)" t)(autoload 'magit-skip-worktree "magit-gitignore" "Call \"git update-index --skip-worktree -- FILE\".\n\n(fn FILE)" t)(autoload 'magit-no-skip-worktree "magit-gitignore" "Call \"git update-index --no-skip-worktree -- FILE\".\n\n(fn FILE)" t)(autoload 'magit-assume-unchanged "magit-gitignore" "Call \"git update-index --assume-unchanged -- FILE\".\n\n(fn FILE)" t)(autoload 'magit-no-assume-unchanged "magit-gitignore" "Call \"git update-index --no-assume-unchanged -- FILE\".\n\n(fn FILE)" t)(autoload 'magit-log "magit-log" nil t)(autoload 'magit-log-refresh "magit-log" nil t)(autoload 'magit-log-current "magit-log" "Show log for the current branch.\nWhen `HEAD' is detached or with a prefix argument show log for\none or more revs read from the minibuffer.\n\n(fn REVS &optional ARGS FILES)" t)(autoload 'magit-log-head "magit-log" "Show log for `HEAD'.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-log-related "magit-log" "Show log for the current branch, its upstream and its push target.\nWhen the upstream is a local branch, then also show its own\nupstream.  When `HEAD' is detached, then show log for that, the\npreviously checked out branch and its upstream and push-target.\n\n(fn REVS &optional ARGS FILES)" t)(autoload 'magit-log-other "magit-log" "Show log for one or more revs read from the minibuffer.\nThe user can input any revision or revisions separated by a\nspace, or even ranges, but only branches and tags, and a\nrepresentation of the commit at point, are available as\ncompletion candidates.\n\n(fn REVS &optional ARGS FILES)" t)(autoload 'magit-log-branches "magit-log" "Show log for all local branches and `HEAD'.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-log-matching-branches "magit-log" "Show log for all branches matching PATTERN and `HEAD'.\n\n(fn PATTERN &optional ARGS FILES)" t)(autoload 'magit-log-matching-tags "magit-log" "Show log for all tags matching PATTERN and `HEAD'.\n\n(fn PATTERN &optional ARGS FILES)" t)(autoload 'magit-log-all-branches "magit-log" "Show log for all local and remote branches and `HEAD'.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-log-all "magit-log" "Show log for all references and `HEAD'.\n\n(fn &optional ARGS FILES)" t)(autoload 'magit-log-buffer-file "magit-log" "Show log for the blob or file visited in the current buffer.\nWith a prefix argument or when `--follow' is an active log\nargument, then follow renames.  When the region is active,\nrestrict the log to the lines that the region touches.\n\n(fn &optional FOLLOW BEG END)" t)(autoload 'magit-log-trace-definition "magit-log" "Show log for the definition at point.\n\n(fn FILE FN REV)" t)(autoload 'magit-log-merged "magit-log" "Show log for the merge of COMMIT into BRANCH.\n\nMore precisely, find merge commit M that brought COMMIT into\nBRANCH, and show the log of the range \"M^1..M\". If COMMIT is\ndirectly on BRANCH, then show approximately\n`magit-log-merged-commit-count' surrounding commits instead.\n\nThis command requires git-when-merged, which is available from\nhttps://github.com/mhagger/git-when-merged.\n\n(fn COMMIT BRANCH &optional ARGS FILES)" t)(autoload 'magit-log-move-to-parent "magit-log" "Move to the Nth parent of the current commit.\n\n(fn &optional N)" t)(autoload 'magit-shortlog "magit-log" nil t)(autoload 'magit-shortlog-since "magit-log" "Show a history summary for commits since REV.\n\n(fn REV ARGS)" t)(autoload 'magit-shortlog-range "magit-log" "Show a history summary for commit or range REV-OR-RANGE.\n\n(fn REV-OR-RANGE ARGS)" t)(autoload 'magit-cherry "magit-log" "Show commits in a branch that are not merged in the upstream branch.\n\n(fn HEAD UPSTREAM)" t)(autoload 'magit-merge "magit" nil t)(autoload 'magit-merge-plain "magit-merge" "Merge commit REV into the current branch; using default message.\n\nUnless there are conflicts or a prefix argument is used create a\nmerge commit using a generic commit message and without letting\nthe user inspect the result.  With a prefix argument pretend the\nmerge failed to give the user the opportunity to inspect the\nmerge.\n\n(git merge --no-edit|--no-commit [ARGS] REV)\n\n(fn REV &optional ARGS NOCOMMIT)" t)(autoload 'magit-merge-editmsg "magit-merge" "Merge commit REV into the current branch; and edit message.\nPerform the merge and prepare a commit message but let the user\nedit it.\n\n(git merge --edit --no-ff [ARGS] REV)\n\n(fn REV &optional ARGS)" t)(autoload 'magit-merge-nocommit "magit-merge" "Merge commit REV into the current branch; pretending it failed.\nPretend the merge failed to give the user the opportunity to\ninspect the merge and change the commit message.\n\n(git merge --no-commit --no-ff [ARGS] REV)\n\n(fn REV &optional ARGS)" t)(autoload 'magit-merge-into "magit-merge" "Merge the current branch into BRANCH and remove the former.\n\nBefore merging, force push the source branch to its push-remote,\nprovided the respective remote branch already exists, ensuring\nthat the respective pull-request (if any) won't get stuck on some\nobsolete version of the commits that are being merged.  Finally\nif `forge-branch-pullreq' was used to create the merged branch,\nthen also remove the respective remote branch.\n\n(fn BRANCH &optional ARGS)" t)(autoload 'magit-merge-absorb "magit-merge" "Merge BRANCH into the current branch and remove the former.\n\nBefore merging, force push the source branch to its push-remote,\nprovided the respective remote branch already exists, ensuring\nthat the respective pull-request (if any) won't get stuck on some\nobsolete version of the commits that are being merged.  Finally\nif `forge-branch-pullreq' was used to create the merged branch,\nthen also remove the respective remote branch.\n\n(fn BRANCH &optional ARGS)" t)(autoload 'magit-merge-squash "magit-merge" "Squash commit REV into the current branch; don't create a commit.\n\n(git merge --squash REV)\n\n(fn REV)" t)(autoload 'magit-merge-preview "magit-merge" "Preview result of merging REV into the current branch.\n\n(fn REV)" t)(autoload 'magit-merge-abort "magit-merge" "Abort the current merge operation.\n\n(git merge --abort)" t)(autoload 'magit-info "magit-mode" "Visit the Magit manual." t)(autoload 'magit-notes "magit" nil t)(autoload 'magit-patch "magit-patch" nil t)(autoload 'magit-patch-create "magit-patch" nil t)(autoload 'magit-patch-apply "magit-patch" nil t)(autoload 'magit-patch-save "magit-patch" "Write current diff into patch FILE.\n\nWhat arguments are used to create the patch depends on the value\nof `magit-patch-save-arguments' and whether a prefix argument is\nused.\n\nIf the value is the symbol `buffer', then use the same arguments\nas the buffer.  With a prefix argument use no arguments.\n\nIf the value is a list beginning with the symbol `exclude', then\nuse the same arguments as the buffer except for those matched by\nentries in the cdr of the list.  The comparison is done using\n`string-prefix-p'.  With a prefix argument use the same arguments\nas the buffer.\n\nIf the value is a list of strings (including the empty list),\nthen use those arguments.  With a prefix argument use the same\narguments as the buffer.\n\nOf course the arguments that are required to actually show the\nsame differences as those shown in the buffer are always used.\n\n(fn FILE &optional ARG)" t)(autoload 'magit-request-pull "magit-patch" "Request upstream to pull from your public repository.\n\nURL is the url of your publicly accessible repository.\nSTART is a commit that already is in the upstream repository.\nEND is the last commit, usually a branch name, which upstream\nis asked to pull.  START has to be reachable from that commit.\n\n(fn URL START END)" t)(autoload 'magit-pull "magit-pull" nil t)(autoload 'magit-pull-from-pushremote "magit-pull" nil t)(autoload 'magit-pull-from-upstream "magit-pull" nil t)(autoload 'magit-pull-branch "magit-pull" "Pull from a branch read in the minibuffer.\n\n(fn SOURCE ARGS)" t)(autoload 'magit-push "magit-push" nil t)(autoload 'magit-push-current-to-pushremote "magit-push" nil t)(autoload 'magit-push-current-to-upstream "magit-push" nil t)(autoload 'magit-push-current "magit-push" "Push the current branch to a branch read in the minibuffer.\n\n(fn TARGET ARGS)" t)(autoload 'magit-push-other "magit-push" "Push an arbitrary branch or commit somewhere.\nBoth the source and the target are read in the minibuffer.\n\n(fn SOURCE TARGET ARGS)" t)(autoload 'magit-push-refspecs "magit-push" "Push one or multiple REFSPECS to a REMOTE.\nBoth the REMOTE and the REFSPECS are read in the minibuffer.  To\nuse multiple REFSPECS, separate them with commas.  Completion is\nonly available for the part before the colon, or when no colon\nis used.\n\n(fn REMOTE REFSPECS ARGS)" t)(autoload 'magit-push-matching "magit-push" "Push all matching branches to another repository.\nIf multiple remotes exist, then read one from the user.\nIf just one exists, use that without requiring confirmation.\n\n(fn REMOTE &optional ARGS)" t)(autoload 'magit-push-tags "magit-push" "Push all tags to another repository.\nIf only one remote exists, then push to that.  Otherwise prompt\nfor a remote, offering the remote configured for the current\nbranch as default.\n\n(fn REMOTE &optional ARGS)" t)(autoload 'magit-push-tag "magit-push" "Push a tag to another repository.\n\n(fn TAG REMOTE &optional ARGS)" t)(autoload 'magit-push-notes-ref "magit-push" "Push a notes ref to another repository.\n\n(fn REF REMOTE &optional ARGS)" t)(autoload 'magit-push-implicitly "magit-push" nil t)(autoload 'magit-push-to-remote "magit-push" nil t)(autoload 'magit-reflog-current "magit-reflog" "Display the reflog of the current branch.\nIf `HEAD' is detached, then show the reflog for that instead." t)(autoload 'magit-reflog-other "magit-reflog" "Display the reflog of a branch or another ref.\n\n(fn REF)" t)(autoload 'magit-reflog-head "magit-reflog" "Display the `HEAD' reflog." t)(autoload 'magit-show-refs "magit-refs" nil t)(autoload 'magit-show-refs-head "magit-refs" "List and compare references in a dedicated buffer.\nCompared with `HEAD'.\n\n(fn &optional ARGS)" t)(autoload 'magit-show-refs-current "magit-refs" "List and compare references in a dedicated buffer.\nCompare with the current branch or `HEAD' if it is detached.\n\n(fn &optional ARGS)" t)(autoload 'magit-show-refs-other "magit-refs" "List and compare references in a dedicated buffer.\nCompared with a branch read from the user.\n\n(fn &optional REF ARGS)" t)(autoload 'magit-remote "magit-remote" nil t)(autoload 'magit-remote-add "magit-remote" "Add a remote named REMOTE and fetch it.\n\n(fn REMOTE URL &optional ARGS)" t)(autoload 'magit-remote-rename "magit-remote" "Rename the remote named OLD to NEW.\n\n(fn OLD NEW)" t)(autoload 'magit-remote-remove "magit-remote" "Delete the remote named REMOTE.\n\n(fn REMOTE)" t)(autoload 'magit-remote-prune "magit-remote" "Remove stale remote-tracking branches for REMOTE.\n\n(fn REMOTE)" t)(autoload 'magit-remote-prune-refspecs "magit-remote" "Remove stale refspecs for REMOTE.\n\nA refspec is stale if there no longer exists at least one branch\non the remote that would be fetched due to that refspec.  A stale\nrefspec is problematic because its existence causes Git to refuse\nto fetch according to the remaining non-stale refspecs.\n\nIf only stale refspecs remain, then offer to either delete the\nremote or to replace the stale refspecs with the default refspec.\n\nAlso remove the remote-tracking branches that were created due to\nthe now stale refspecs.  Other stale branches are not removed.\n\n(fn REMOTE)" t)(autoload 'magit-remote-set-head "magit-remote" "Set the local representation of REMOTE's default branch.\nQuery REMOTE and set the symbolic-ref refs/remotes/<remote>/HEAD\naccordingly.  With a prefix argument query for the branch to be\nused, which allows you to select an incorrect value if you fancy\ndoing that.\n\n(fn REMOTE &optional BRANCH)" t)(autoload 'magit-remote-unset-head "magit-remote" "Unset the local representation of REMOTE's default branch.\nDelete the symbolic-ref \"refs/remotes/<remote>/HEAD\".\n\n(fn REMOTE)" t)(autoload 'magit-update-default-branch "magit-remote" nil t)(autoload 'magit-remote-unshallow "magit-remote" "Convert a shallow remote into a full one.\nIf only a single refspec is set and it does not contain a\nwildcard, then also offer to replace it with the standard\nrefspec.\n\n(fn REMOTE)" t)(autoload 'magit-remote-configure "magit-remote" nil t)(autoload 'magit-list-repositories "magit-repos" "Display a list of repositories.\n\nUse the option `magit-repository-directories' to control which\nrepositories are displayed." t)(autoload 'magit-reset "magit" nil t)(autoload 'magit-reset-mixed "magit-reset" "Reset the `HEAD' and index to COMMIT, but not the working tree.\n\n(git reset --mixed COMMIT)\n\n(fn COMMIT)" t)(autoload 'magit-reset-soft "magit-reset" "Reset the `HEAD' to COMMIT, but not the index and working tree.\n\n(git reset --soft REVISION)\n\n(fn COMMIT)" t)(autoload 'magit-reset-hard "magit-reset" "Reset the `HEAD', index, and working tree to COMMIT.\n\n(git reset --hard REVISION)\n\n(fn COMMIT)" t)(autoload 'magit-reset-keep "magit-reset" "Reset the `HEAD' and index to COMMIT, while keeping uncommitted changes.\n\n(git reset --keep REVISION)\n\n(fn COMMIT)" t)(autoload 'magit-reset-index "magit-reset" "Reset the index to COMMIT.\nKeep the `HEAD' and working tree as-is, so if COMMIT refers to the\nhead this effectively unstages all changes.\n\n(git reset COMMIT .)\n\n(fn COMMIT)" t)(autoload 'magit-reset-worktree "magit-reset" "Reset the worktree to COMMIT.\nKeep the `HEAD' and index as-is.\n\n(fn COMMIT)" t)(autoload 'magit-reset-quickly "magit-reset" "Reset the `HEAD' and index to COMMIT, and possibly the working tree.\nWith a prefix argument reset the working tree otherwise don't.\n\n(git reset --mixed|--hard COMMIT)\n\n(fn COMMIT &optional HARD)" t)(autoload 'magit-sequencer-continue "magit-sequence" "Resume the current cherry-pick or revert sequence." t)(autoload 'magit-sequencer-skip "magit-sequence" "Skip the stopped at commit during a cherry-pick or revert sequence." t)(autoload 'magit-sequencer-abort "magit-sequence" "Abort the current cherry-pick or revert sequence.\nThis discards all changes made since the sequence started." t)(autoload 'magit-cherry-pick "magit-sequence" nil t)(autoload 'magit-cherry-copy "magit-sequence" "Copy COMMITS from another branch onto the current branch.\nPrompt for a commit, defaulting to the commit at point.  If\nthe region selects multiple commits, then pick all of them,\nwithout prompting.\n\n(fn COMMITS &optional ARGS)" t)(autoload 'magit-cherry-apply "magit-sequence" "Apply the changes in COMMITS but do not commit them.\nPrompt for a commit, defaulting to the commit at point.  If\nthe region selects multiple commits, then apply all of them,\nwithout prompting.\n\n(fn COMMITS &optional ARGS)" t)(autoload 'magit-cherry-harvest "magit-sequence" "Move COMMITS from another BRANCH onto the current branch.\nRemove the COMMITS from BRANCH and stay on the current branch.\nIf a conflict occurs, then you have to fix that and finish the\nprocess manually.\n\n(fn COMMITS BRANCH &optional ARGS)" t)(autoload 'magit-cherry-donate "magit-sequence" "Move COMMITS from the current branch onto another existing BRANCH.\nRemove COMMITS from the current branch and stay on that branch.\nIf a conflict occurs, then you have to fix that and finish the\nprocess manually.  `HEAD' is allowed to be detached initially.\n\n(fn COMMITS BRANCH &optional ARGS)" t)(autoload 'magit-cherry-spinout "magit-sequence" "Move COMMITS from the current branch onto a new BRANCH.\nRemove COMMITS from the current branch and stay on that branch.\nIf a conflict occurs, then you have to fix that and finish the\nprocess manually.\n\n(fn COMMITS BRANCH START-POINT &optional ARGS)" t)(autoload 'magit-cherry-spinoff "magit-sequence" "Move COMMITS from the current branch onto a new BRANCH.\nRemove COMMITS from the current branch and checkout BRANCH.\nIf a conflict occurs, then you have to fix that and finish\nthe process manually.\n\n(fn COMMITS BRANCH START-POINT &optional ARGS)" t)(autoload 'magit-revert "magit-sequence" nil t)(autoload 'magit-revert-and-commit "magit-sequence" "Revert COMMIT by creating a new commit.\nPrompt for a commit, defaulting to the commit at point.  If\nthe region selects multiple commits, then revert all of them,\nwithout prompting.\n\n(fn COMMIT &optional ARGS)" t)(autoload 'magit-revert-no-commit "magit-sequence" "Revert COMMIT by applying it in reverse to the worktree.\nPrompt for a commit, defaulting to the commit at point.  If\nthe region selects multiple commits, then revert all of them,\nwithout prompting.\n\n(fn COMMIT &optional ARGS)" t)(autoload 'magit-am "magit-sequence" nil t)(autoload 'magit-am-apply-patches "magit-sequence" "Apply the patches FILES.\n\n(fn &optional FILES ARGS)" t)(autoload 'magit-am-apply-maildir "magit-sequence" "Apply the patches from MAILDIR.\n\n(fn &optional MAILDIR ARGS)" t)(autoload 'magit-am-continue "magit-sequence" "Resume the current patch applying sequence." t)(autoload 'magit-am-skip "magit-sequence" "Skip the stopped at patch during a patch applying sequence." t)(autoload 'magit-am-abort "magit-sequence" "Abort the current patch applying sequence.\nThis discards all changes made since the sequence started." t)(autoload 'magit-rebase "magit-sequence" nil t)(autoload 'magit-rebase-onto-pushremote "magit-sequence" nil t)(autoload 'magit-rebase-onto-upstream "magit-sequence" nil t)(autoload 'magit-rebase-branch "magit-sequence" "Rebase the current branch onto a branch read in the minibuffer.\nAll commits that are reachable from `HEAD' but not from the\nselected branch TARGET are being rebased.\n\n(fn TARGET ARGS)" t)(autoload 'magit-rebase-subset "magit-sequence" "Rebase a subset of the current branch's history onto a new base.\nRebase commits from START to `HEAD' onto NEWBASE.\nSTART has to be selected from a list of recent commits.\n\n(fn NEWBASE START ARGS)" t)(autoload 'magit-rebase-interactive "magit-sequence" "Start an interactive rebase sequence.\n\n(fn COMMIT ARGS)" t)(autoload 'magit-rebase-autosquash "magit-sequence" "Combine squash and fixup commits with their intended targets.\n\n(fn ARGS)" t)(autoload 'magit-rebase-edit-commit "magit-sequence" "Edit a single older commit using rebase.\n\n(fn COMMIT ARGS)" t)(autoload 'magit-rebase-reword-commit "magit-sequence" "Reword a single older commit using rebase.\n\n(fn COMMIT ARGS)" t)(autoload 'magit-rebase-remove-commit "magit-sequence" "Remove a single older commit using rebase.\n\n(fn COMMIT ARGS)" t)(autoload 'magit-rebase-continue "magit-sequence" "Restart the current rebasing operation.\nIn some cases this pops up a commit message buffer for you do\nedit.  With a prefix argument the old message is reused as-is.\n\n(fn &optional NOEDIT)" t)(autoload 'magit-rebase-skip "magit-sequence" "Skip the current commit and restart the current rebase operation." t)(autoload 'magit-rebase-edit "magit-sequence" "Edit the todo list of the current rebase operation." t)(autoload 'magit-rebase-abort "magit-sequence" "Abort the current rebase operation, restoring the original branch." t)(autoload 'magit-sparse-checkout "magit-sparse-checkout" nil t)(autoload 'magit-sparse-checkout-enable "magit-sparse-checkout" "Convert the working tree to a sparse checkout.\n\n(fn &optional ARGS)" t)(autoload 'magit-sparse-checkout-set "magit-sparse-checkout" "Restrict working tree to DIRECTORIES.\nTo extend rather than override the currently configured\ndirectories, call `magit-sparse-checkout-add' instead.\n\n(fn DIRECTORIES)" t)(autoload 'magit-sparse-checkout-add "magit-sparse-checkout" "Add DIRECTORIES to the working tree.\nTo override rather than extend the currently configured\ndirectories, call `magit-sparse-checkout-set' instead.\n\n(fn DIRECTORIES)" t)(autoload 'magit-sparse-checkout-reapply "magit-sparse-checkout" "Reapply the sparse checkout rules to the working tree.\nSome operations such as merging or rebasing may need to check out\nfiles that aren't included in the sparse checkout.  Call this\ncommand to reset to the sparse checkout state." t)(autoload 'magit-sparse-checkout-disable "magit-sparse-checkout" "Convert sparse checkout to full checkout.\nNote that disabling the sparse checkout does not clear the\nconfigured directories.  Call `magit-sparse-checkout-enable' to\nrestore the previous sparse checkout." t)(autoload 'magit-stash "magit-stash" nil t)(autoload 'magit-stash-both "magit-stash" "Create a stash of the index and working tree.\nUntracked files are included according to infix arguments.\nOne prefix argument is equivalent to `--include-untracked'\nwhile two prefix arguments are equivalent to `--all'.\n\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t)(autoload 'magit-stash-index "magit-stash" "Create a stash of the index only.\nUnstaged and untracked changes are not stashed.  The stashed\nchanges are applied in reverse to both the index and the\nworktree.  This command can fail when the worktree is not clean.\nApplying the resulting stash has the inverse effect.\n\n(fn MESSAGE)" t)(autoload 'magit-stash-worktree "magit-stash" "Create a stash of unstaged changes in the working tree.\nUntracked files are included according to infix arguments.\nOne prefix argument is equivalent to `--include-untracked'\nwhile two prefix arguments are equivalent to `--all'.\n\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t)(autoload 'magit-stash-keep-index "magit-stash" "Create a stash of the index and working tree, keeping index intact.\nUntracked files are included according to infix arguments.\nOne prefix argument is equivalent to `--include-untracked'\nwhile two prefix arguments are equivalent to `--all'.\n\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t)(autoload 'magit-snapshot-both "magit-stash" "Create a snapshot of the index and working tree.\nUntracked files are included according to infix arguments.\nOne prefix argument is equivalent to `--include-untracked'\nwhile two prefix arguments are equivalent to `--all'.\n\n(fn &optional INCLUDE-UNTRACKED)" t)(autoload 'magit-snapshot-index "magit-stash" "Create a snapshot of the index only.\nUnstaged and untracked changes are not stashed." t)(autoload 'magit-snapshot-worktree "magit-stash" "Create a snapshot of unstaged changes in the working tree.\nUntracked files are included according to infix arguments.\nOne prefix argument is equivalent to `--include-untracked'\nwhile two prefix arguments are equivalent to `--all'.\n\n(fn &optional INCLUDE-UNTRACKED)" t)(autoload 'magit-stash-push "magit-stash" nil t)(autoload 'magit-stash-apply "magit-stash" "Apply a stash to the working tree.\n\nFirst try \"git stash apply --index\", which tries to preserve\nthe index stored in the stash, if any.  This may fail because\napplying the stash could result in conflicts and those have to\nbe stored in the index, making it impossible to also store the\nstash's index there as well.\n\nIf the above failed, then try \"git stash apply\".  This fails\n(with or without \"--index\") if there are any uncommitted\nchanges to files that are also modified in the stash.\n\nIf both of the above failed, then apply using \"git apply\".\nIf there are no conflicting files, use \"--3way\".  If there are\nconflicting files, then using \"--3way\" requires that those\nfiles are staged first, which may be undesirable, so prompt\nthe user whether to use \"--3way\" or \"--reject\".\n\n(fn STASH)" t)(autoload 'magit-stash-pop "magit-stash" "Apply a stash to the working tree, on success remove it from stash list.\n\nFirst try \"git stash pop --index\", which tries to preserve\nthe index stored in the stash, if any.  This may fail because\napplying the stash could result in conflicts and those have to\nbe stored in the index, making it impossible to also store the\nstash's index there as well.\n\nIf the above failed, then try \"git stash apply\".  This fails\n(with or without \"--index\") if there are any uncommitted\nchanges to files that are also modified in the stash.\n\nIf both of the above failed, then apply using \"git apply\".\nIf there are no conflicting files, use \"--3way\".  If there are\nconflicting files, then using \"--3way\" requires that those\nfiles are staged first, which may be undesirable, so prompt\nthe user whether to use \"--3way\" or \"--reject\".\n\n(fn STASH)" t)(autoload 'magit-stash-drop "magit-stash" "Remove a stash from the stash list.\nWhen the region is active offer to drop all contained stashes.\n\n(fn STASH)" t)(autoload 'magit-stash-clear "magit-stash" "Remove all stashes saved in REF's reflog by deleting REF.\n\n(fn REF)" t)(autoload 'magit-stash-branch "magit-stash" "Create and checkout a new BRANCH from an existing STASH.\nThe new branch starts at the commit that was current when the\nstash was created.  If the stash applies cleanly, then drop it.\n\n(fn STASH BRANCH)" t)(autoload 'magit-stash-branch-here "magit-stash" "Create and checkout a new BRANCH from an existing STASH.\nUse the current branch or `HEAD' as the starting-point of BRANCH.\nThen apply STASH, dropping it if it applies cleanly.\n\n(fn STASH BRANCH)" t)(autoload 'magit-stash-format-patch "magit-stash" "Create a patch from STASH\n\n(fn STASH)" t)(autoload 'magit-stash-list "magit-stash" "List all stashes in a buffer." t)(autoload 'magit-stash-show "magit-stash" "Show all diffs of a stash in a buffer.\n\n(fn STASH &optional ARGS FILES)" t)(autoload 'magit-init "magit-status" "Initialize a Git repository, then show its status.\n\nIf the directory is below an existing repository, then the user\nhas to confirm that a new one should be created inside.  If the\ndirectory is the root of the existing repository, then the user\nhas to confirm that it should be reinitialized.\n\nNon-interactively DIRECTORY is (re-)initialized unconditionally.\n\n(fn DIRECTORY)" t)(autoload 'magit-status "magit-status" "Show the status of the current Git repository in a buffer.\n\nIf the current directory isn't located within a Git repository,\nthen prompt for an existing repository or an arbitrary directory,\ndepending on option `magit-repository-directories', and show the\nstatus of the selected repository instead.\n\n* If that option specifies any existing repositories, then offer\n  those for completion and show the status buffer for the\n  selected one.\n\n* Otherwise read an arbitrary directory using regular file-name\n  completion.  If the selected directory is the top-level of an\n  existing working tree, then show the status buffer for that.\n\n* Otherwise offer to initialize the selected directory as a new\n  repository.  After creating the repository show its status\n  buffer.\n\nThese fallback behaviors can also be forced using one or more\nprefix arguments:\n\n* With two prefix arguments (or more precisely a numeric prefix\n  value of 16 or greater) read an arbitrary directory and act on\n  it as described above.  The same could be accomplished using\n  the command `magit-init'.\n\n* With a single prefix argument read an existing repository, or\n  if none can be found based on `magit-repository-directories',\n  then fall back to the same behavior as with two prefix\n  arguments.\n\n(fn &optional DIRECTORY CACHE)" t)(defalias 'magit #'magit-status "Begin using Magit.\n\nThis alias for `magit-status' exists for better discoverability.\n\nInstead of invoking this alias for `magit-status' using\n\"M-x magit RET\", you should bind a key to `magit-status'\nand read the info node `(magit)Getting Started', which\nalso contains other useful hints.")(autoload 'magit-status-here "magit-status" "Like `magit-status' but with non-nil `magit-status-goto-file-position'." t)(autoload 'magit-status-quick "magit-status" "Show the status of the current Git repository, maybe without refreshing.\n\nIf the status buffer of the current Git repository exists but\nisn't being displayed in the selected frame, then display it\nwithout refreshing it.\n\nIf the status buffer is being displayed in the selected frame,\nthen also refresh it.\n\nPrefix arguments have the same meaning as for `magit-status',\nand additionally cause the buffer to be refresh.\n\nTo use this function instead of `magit-status', add this to your\ninit file: (global-set-key (kbd \"C-x g\") \\='magit-status-quick)." t)(autoload 'magit-status-setup-buffer "magit-status" "\n\n(fn &optional DIRECTORY)")(autoload 'magit-submodule "magit-submodule" nil t)(autoload 'magit-submodule-add "magit-submodule" nil t)(autoload 'magit-submodule-read-name-for-path "magit-submodule" "\n\n(fn PATH &optional PREFER-SHORT)")(autoload 'magit-submodule-register "magit-submodule" nil t)(autoload 'magit-submodule-populate "magit-submodule" nil t)(autoload 'magit-submodule-update "magit-submodule" nil t)(autoload 'magit-submodule-synchronize "magit-submodule" nil t)(autoload 'magit-submodule-unpopulate "magit-submodule" nil t)(autoload 'magit-submodule-remove "magit-submodule" "Unregister MODULES and remove their working directories.\n\nFor safety reasons, do not remove the gitdirs and if a module has\nuncommitted changes, then do not remove it at all.  If a module's\ngitdir is located inside the working directory, then move it into\nthe gitdir of the superproject first.\n\nWith the \"--force\" argument offer to remove dirty working\ndirectories and with a prefix argument offer to delete gitdirs.\nBoth actions are very dangerous and have to be confirmed.  There\nare additional safety precautions in place, so you might be able\nto recover from making a mistake here, but don't count on it.\n\n(fn MODULES ARGS TRASH-GITDIRS)" t)(autoload 'magit-insert-modules "magit-submodule" "Insert submodule sections.\nHook `magit-module-sections-hook' controls which module sections\nare inserted, and option `magit-module-sections-nested' controls\nwhether they are wrapped in an additional section.")(autoload 'magit-insert-modules-overview "magit-submodule" "Insert sections for all modules.\nFor each section insert the path and the output of `git describe --tags',\nor, failing that, the abbreviated HEAD commit hash.")(autoload 'magit-insert-modules-unpulled-from-upstream "magit-submodule" "Insert sections for modules that haven't been pulled from the upstream.\nThese sections can be expanded to show the respective commits.")(autoload 'magit-insert-modules-unpulled-from-pushremote "magit-submodule" "Insert sections for modules that haven't been pulled from the push-remote.\nThese sections can be expanded to show the respective commits.")(autoload 'magit-insert-modules-unpushed-to-upstream "magit-submodule" "Insert sections for modules that haven't been pushed to the upstream.\nThese sections can be expanded to show the respective commits.")(autoload 'magit-insert-modules-unpushed-to-pushremote "magit-submodule" "Insert sections for modules that haven't been pushed to the push-remote.\nThese sections can be expanded to show the respective commits.")(autoload 'magit-list-submodules "magit-submodule" "Display a list of the current repository's populated submodules." t)(autoload 'magit-subtree "magit-subtree" nil t)(autoload 'magit-subtree-import "magit-subtree" nil t)(autoload 'magit-subtree-export "magit-subtree" nil t)(autoload 'magit-subtree-add "magit-subtree" "Add REF from REPOSITORY as a new subtree at PREFIX.\n\n(fn PREFIX REPOSITORY REF ARGS)" t)(autoload 'magit-subtree-add-commit "magit-subtree" "Add COMMIT as a new subtree at PREFIX.\n\n(fn PREFIX COMMIT ARGS)" t)(autoload 'magit-subtree-merge "magit-subtree" "Merge COMMIT into the PREFIX subtree.\n\n(fn PREFIX COMMIT ARGS)" t)(autoload 'magit-subtree-pull "magit-subtree" "Pull REF from REPOSITORY into the PREFIX subtree.\n\n(fn PREFIX REPOSITORY REF ARGS)" t)(autoload 'magit-subtree-push "magit-subtree" "Extract the history of the subtree PREFIX and push it to REF on REPOSITORY.\n\n(fn PREFIX REPOSITORY REF ARGS)" t)(autoload 'magit-subtree-split "magit-subtree" "Extract the history of the subtree PREFIX.\n\n(fn PREFIX COMMIT ARGS)" t)(autoload 'magit-tag "magit" nil t)(autoload 'magit-tag-create "magit-tag" "Create a new tag with the given NAME at REV.\nWith a prefix argument annotate the tag.\n\n(git tag [--annotate] NAME REV)\n\n(fn NAME REV &optional ARGS)" t)(autoload 'magit-tag-delete "magit-tag" "Delete one or more tags.\nIf the region marks multiple tags (and nothing else), then offer\nto delete those, otherwise prompt for a single tag to be deleted,\ndefaulting to the tag at point.\n\n(git tag -d TAGS)\n\n(fn TAGS)" t)(autoload 'magit-tag-prune "magit-tag" "Offer to delete tags missing locally from REMOTE, and vice versa.\n\n(fn TAGS REMOTE-TAGS REMOTE)" t)(autoload 'magit-tag-release "magit-tag" "Create a release tag for `HEAD'.\n\nAssume that release tags match `magit-release-tag-regexp'.\n\nIf `HEAD's message matches `magit-release-commit-regexp', then\nbase the tag on the version string specified by that.  Otherwise\nprompt for the name of the new tag using the highest existing\ntag as initial input and leaving it to the user to increment the\ndesired part of the version string.\n\nWhen creating an annotated tag, prepare a message based on the message\nof the highest existing tag, provided that contains the corresponding\nversion string, and substituting the new version string for that.  If\nthat is not the case, propose a message using a reasonable format.\n\n(fn TAG MSG &optional ARGS)" t)(defvar magit-wip-mode nil "Non-nil if Magit-Wip mode is enabled.\nSee the `magit-wip-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `magit-wip-mode'.")(autoload 'magit-wip-mode "magit-wip" "Save uncommitted changes to work-in-progress refs.\n\nWhenever appropriate (i.e., when dataloss would be a possibility\notherwise) this mode causes uncommitted changes to be committed\nto dedicated work-in-progress refs.\n\nFor historic reasons this mode is implemented on top of four\nother `magit-wip-*' modes, which can also be used individually,\nif you want finer control over when the wip refs are updated;\nbut that is discouraged.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Magit-Wip mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='magit-wip-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'magit-wip-after-save-mode 'globalized-minor-mode t)(defvar magit-wip-after-save-mode nil "Non-nil if Magit-Wip-After-Save mode is enabled.\nSee the `magit-wip-after-save-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `magit-wip-after-save-mode'.")(autoload 'magit-wip-after-save-mode "magit-wip" "Toggle Magit-Wip-After-Save-Local mode in all buffers.\nWith prefix ARG, enable Magit-Wip-After-Save mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nMagit-Wip-After-Save-Local mode is enabled in all buffers where\n`magit-wip-after-save-local-mode-turn-on' would do it.\n\nSee `magit-wip-after-save-local-mode' for more information on\nMagit-Wip-After-Save-Local mode.\n\n(fn &optional ARG)" t)(defvar magit-wip-after-apply-mode nil "Non-nil if Magit-Wip-After-Apply mode is enabled.\nSee the `magit-wip-after-apply-mode' command\nfor a description of this minor mode.")(autoload 'magit-wip-after-apply-mode "magit-wip" "Commit to work-in-progress refs.\n\nAfter applying a change using any \"apply variant\"\ncommand (apply, stage, unstage, discard, and reverse) commit the\naffected files to the current wip refs.  For each branch there\nmay be two wip refs; one contains snapshots of the files as found\nin the worktree and the other contains snapshots of the entries\nin the index.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Magit-Wip-After-Apply mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='magit-wip-after-apply-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar magit-wip-before-change-mode nil "Non-nil if Magit-Wip-Before-Change mode is enabled.\nSee the `magit-wip-before-change-mode' command\nfor a description of this minor mode.")(autoload 'magit-wip-before-change-mode "magit-wip" "Commit to work-in-progress refs before certain destructive changes.\n\nBefore invoking a revert command or an \"apply variant\"\ncommand (apply, stage, unstage, discard, and reverse) commit the\naffected tracked files to the current wip refs.  For each branch\nthere may be two wip refs; one contains snapshots of the files\nas found in the worktree and the other contains snapshots of the\nentries in the index.\n\nOnly changes to files which could potentially be affected by the\ncommand which is about to be called are committed.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Magit-Wip-Before-Change mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='magit-wip-before-change-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'magit-wip-commit-initial-backup "magit-wip" "Before saving, commit current file to a worktree wip ref.\n\nThe user has to add this function to `before-save-hook'.\n\nCommit the current state of the visited file before saving the\ncurrent buffer to that file.  This backs up the same version of\nthe file as `backup-buffer' would, but stores the backup in the\nworktree wip ref, which is also used by the various Magit Wip\nmodes, instead of in a backup file as `backup-buffer' would.\n\nThis function ignores the variables that affect `backup-buffer'\nand can be used along-side that function, which is recommended\nbecause this function only backs up files that are tracked in\na Git repository.")(autoload 'magit-worktree "magit-worktree" nil t)(autoload 'magit-worktree-checkout "magit-worktree" "Checkout BRANCH in a new worktree at PATH.\n\n(fn PATH BRANCH)" t)(autoload 'magit-worktree-branch "magit-worktree" "Create a new BRANCH and check it out in a new worktree at PATH.\n\n(fn PATH BRANCH START-POINT)" t)(autoload 'magit-worktree-move "magit-worktree" "Move WORKTREE to PATH.\n\n(fn WORKTREE PATH)" t)(autoload 'magit-add-section-hook "magit-section" "Add to the value of section hook HOOK the function FUNCTION.\n\nAdd FUNCTION at the beginning of the hook list unless optional\nAPPEND is non-nil, in which case FUNCTION is added at the end.\nIf FUNCTION already is a member, then move it to the new location.\n\nIf optional AT is non-nil and a member of the hook list, then\nadd FUNCTION next to that instead.  Add before or after AT, or\nreplace AT with FUNCTION depending on APPEND.  If APPEND is the\nsymbol `replace', then replace AT with FUNCTION.  For any other\nnon-nil value place FUNCTION right after AT.  If nil, then place\nFUNCTION right before AT.  If FUNCTION already is a member of the\nlist but AT is not, then leave FUNCTION where ever it already is.\n\nIf optional LOCAL is non-nil, then modify the hook's buffer-local\nvalue rather than its global value.  This makes the hook local by\ncopying the default value.  That copy is then modified.\n\nHOOK should be a symbol.  If HOOK is void, it is first set to nil.\nHOOK's value must not be a single hook function.  FUNCTION should\nbe a function that takes no arguments and inserts one or multiple\nsections at point, moving point forward.  FUNCTION may choose not\nto insert its section(s), when doing so would not make sense.  It\nshould not be abused for other side-effects.  To remove FUNCTION\nagain use `remove-hook'.\n\n(fn HOOK FUNCTION &optional AT APPEND LOCAL)")(autoload 'magit--handle-bookmark "magit-section" "Open a bookmark created by `magit--make-bookmark'.\n\nCall the generic function `magit-bookmark-get-buffer-create' to get\nthe appropriate buffer without displaying it.\n\nThen call the `magit-*-setup-buffer' function of the the major-mode\nwith the variables' values as arguments, which were recorded by\n`magit--make-bookmark'.\n\n(fn BOOKMARK)")(autoload 'transient-insert-suffix "transient" "Insert a SUFFIX into PREFIX before LOC.\nPREFIX is a prefix command, a symbol.\nSUFFIX is a suffix command or a group specification (of\n  the same forms as expected by `transient-define-prefix').\nLOC is a command, a key vector, a key description (a string\n  as returned by `key-description'), or a coordination list\n  (whose last element may also be a command or key).\nRemove a conflicting binding unless optional KEEP-OTHER is\n  non-nil.\nSee info node `(transient)Modifying Existing Transients'.\n\n(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)")(function-put 'transient-insert-suffix 'lisp-indent-function 'defun)(autoload 'transient-append-suffix "transient" "Insert a SUFFIX into PREFIX after LOC.\nPREFIX is a prefix command, a symbol.\nSUFFIX is a suffix command or a group specification (of\n  the same forms as expected by `transient-define-prefix').\nLOC is a command, a key vector, a key description (a string\n  as returned by `key-description'), or a coordination list\n  (whose last element may also be a command or key).\nRemove a conflicting binding unless optional KEEP-OTHER is\n  non-nil.\nSee info node `(transient)Modifying Existing Transients'.\n\n(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)")(function-put 'transient-append-suffix 'lisp-indent-function 'defun)(autoload 'transient-replace-suffix "transient" "Replace the suffix at LOC in PREFIX with SUFFIX.\nPREFIX is a prefix command, a symbol.\nSUFFIX is a suffix command or a group specification (of\n  the same forms as expected by `transient-define-prefix').\nLOC is a command, a key vector, a key description (a string\n  as returned by `key-description'), or a coordination list\n  (whose last element may also be a command or key).\nSee info node `(transient)Modifying Existing Transients'.\n\n(fn PREFIX LOC SUFFIX)")(function-put 'transient-replace-suffix 'lisp-indent-function 'defun)(autoload 'transient-remove-suffix "transient" "Remove the suffix or group at LOC in PREFIX.\nPREFIX is a prefix command, a symbol.\nLOC is a command, a key vector, a key description (a string\n  as returned by `key-description'), or a coordination list\n  (whose last element may also be a command or key).\nSee info node `(transient)Modifying Existing Transients'.\n\n(fn PREFIX LOC)")(function-put 'transient-remove-suffix 'lisp-indent-function 'defun)(autoload 'with-editor-export-editor "with-editor" "Teach subsequent commands to use current Emacs instance as editor.\n\nSet and export the environment variable ENVVAR, by default\n\"EDITOR\".  The value is automatically generated to teach\ncommands to use the current Emacs instance as \"the editor\".\n\nThis works in `shell-mode', `term-mode', `eshell-mode' and\n`vterm'.\n\n(fn &optional (ENVVAR \"EDITOR\"))" t)(autoload 'with-editor-export-git-editor "with-editor" "Like `with-editor-export-editor' but always set `$GIT_EDITOR'." t)(autoload 'with-editor-export-hg-editor "with-editor" "Like `with-editor-export-editor' but always set `$HG_EDITOR'." t)(defvar shell-command-with-editor-mode nil "Non-nil if Shell-Command-With-Editor mode is enabled.\nSee the `shell-command-with-editor-mode' command\nfor a description of this minor mode.")(autoload 'shell-command-with-editor-mode "with-editor" "Teach `shell-command' to use current Emacs instance as editor.\n\nTeach `shell-command', and all commands that ultimately call that\ncommand, to use the current Emacs instance as editor by executing\n\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".\n\nCLIENT is automatically generated; EDITOR=CLIENT instructs\nCOMMAND to use to the current Emacs instance as \"the editor\",\nassuming no other variable overrides the effect of \"$EDITOR\".\nCLIENT may be the path to an appropriate emacsclient executable\nwith arguments, or a script which also works over Tramp.\n\nAlternatively you can use the `with-editor-async-shell-command',\nwhich also allows the use of another variable instead of\n\"EDITOR\".\n\nThis is a global minor mode.  If called interactively, toggle the\n`Shell-Command-With-Editor mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='shell-command-with-editor-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'with-editor-async-shell-command "with-editor" "Like `async-shell-command' but with `$EDITOR' set.\n\nExecute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;\ndisplay output, if any.  With a prefix argument prompt for an\nenvironment variable, otherwise the default \"EDITOR\" variable\nis used.  With a negative prefix argument additionally insert\nthe COMMAND's output at point.\n\nCLIENT is automatically generated; ENVVAR=CLIENT instructs\nCOMMAND to use to the current Emacs instance as \"the editor\",\nassuming it respects ENVVAR as an \"EDITOR\"-like variable.\nCLIENT may be the path to an appropriate emacsclient executable\nwith arguments, or a script which also works over Tramp.\n\nAlso see `async-shell-command' and `shell-command'.\n\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t)(autoload 'with-editor-shell-command "with-editor" "Like `shell-command' or `with-editor-async-shell-command'.\nIf COMMAND ends with \"&\" behave like the latter,\nelse like the former.\n\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t)(autoload 'evil-org-mode "evil-org" "Buffer local minor mode for evil-org\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Org mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-org-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-org-agenda-mode "evil-org-agenda" "Buffer local minor mode for evil-org-agenda\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Org-Agenda mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-org-agenda-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-mode "evil" nil t)(autoload 'evil-digraph "evil-digraphs" "Convert DIGRAPH to character or list representation.\nIf DIGRAPH is a list (CHAR1 CHAR2), return the corresponding character;\nif DIGRAPH is a character, return the corresponding list.\nSearches in `evil-digraphs-table-user' and `evil-digraphs-table'.\n\n(fn DIGRAPH)")(autoload 'goto-last-change "goto-chg" "Go to the point where the last edit was made in the current buffer.\nRepeat the command to go to the second last edit, etc.\n\nTo go back to more recent edit, the reverse of this command, use \\[goto-last-change-reverse]\nor precede this command with \\[universal-argument] - (minus).\n\nIt does not go to the same point twice even if there has been many edits\nthere. I call the minimal distance between distinguishable edits \"span\".\nSet variable `glc-default-span' to control how close is \"the same point\".\nDefault span is 8.\nThe span can be changed temporarily with \\[universal-argument] right before \\[goto-last-change]:\n\\[universal-argument] <NUMBER> set current span to that number,\n\\[universal-argument] (no number) multiplies span by 4, starting with default.\nThe so set span remains until it is changed again with \\[universal-argument], or the consecutive\nrepetition of this command is ended by any other command.\n\nWhen span is zero (i.e. \\[universal-argument] 0) subsequent \\[goto-last-change] visits each and\nevery point of edit and a message shows what change was made there.\nIn this case it may go to the same point twice.\n\nThis command uses undo information. If undo is disabled, so is this command.\nAt times, when undo information becomes too large, the oldest information is\ndiscarded. See variable `undo-limit'.\n\n(fn ARG)" t)(autoload 'goto-last-change-reverse "goto-chg" "Go back to more recent changes after \\[goto-last-change] have been used.\nSee `goto-last-change' for use of prefix argument.\n\n(fn ARG)" t)(autoload 'org-cliplink-retrieve-title "org-cliplink" "\n\n(fn URL TITLE-CALLBACK)")(autoload 'org-cliplink-insert-transformed-title "org-cliplink" "Takes the URL, asynchronously retrieves the title and applies\na custom TRANSFORMER which transforms the url and title and insert\nthe required text to the current buffer.\n\n(fn URL TRANSFORMER)")(autoload 'org-cliplink-retrieve-title-synchronously "org-cliplink" "\n\n(fn URL)")(autoload 'org-cliplink "org-cliplink" "Takes a URL from the clipboard and inserts an org-mode link\nwith the title of a page found by the URL into the current\nbuffer" t)(autoload 'org-cliplink-capture "org-cliplink" "org-cliplink version for org-capture templates.\nMakes synchronous request. Returns the link instead of inserting\nit to the current buffer. Doesn't support Basic Auth. Doesn't\nsupport cURL transport." t)(autoload 'toc-org-enable "toc-org" "Enable toc-org in this buffer.")(autoload 'toc-org-mode "toc-org" "Toggle `toc-org' in this buffer.\n\nThis is a minor mode.  If called interactively, toggle the\n`Toc-Org mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `toc-org-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'ox-clip-get-command "ox-clip" "Get the command form OPTIONS.\nOPTIONS is one of `ox-clip-w32-cmd', `ox-clip-osx-cmd', or\n`ox-clip-linux-cmd'. Those may be a string, or a list of\ncandidates to choose from.\n\n(fn OPTIONS)")(autoload 'ox-clip-formatted-copy "ox-clip" "Export the selected region to HTML and copy it to the clipboard.\nR1 and R2 define the selected region.\n\nIf SUBTREEP (interactively, the prefix argument) is non-nil then\nexport the current `org-mode' subtree, including hidden content.\n\n(fn R1 R2 &optional SUBTREEP)" t)(autoload 'ox-clip-image-to-clipboard "ox-clip" "Copy the image file or latex fragment at point to the clipboard as an image.\nSCALE is a numerical\nprefix (default=`ox-clip-default-latex-scale') that determines\nthe size of the latex image. It has no effect on other kinds of\nimages. Currently only works on Linux.\n\n(fn &optional SCALE)" t)(autoload 'htmlize-buffer "htmlize" "Convert BUFFER to HTML, preserving colors and decorations.\n\nThe generated HTML is available in a new buffer, which is returned.\nWhen invoked interactively (or if optional INTERACTIVE is non-nil),\nthe new buffer is selected in the current window.  The title of the\ngenerated document will be set to the buffer's file name or, if that\nis not available, to the buffer's name.\n\nNote that htmlize doesn't fontify your buffers, it only uses the\ndecorations that are already present.  If you don't set up font-lock or\nsomething else to fontify your buffers, the resulting HTML will be\nplain.  Likewise, if you don't like the choice of colors, fix the mode\nthat created them, or simply alter the faces it uses.\n\n(fn &optional BUFFER INTERACTIVE)" t)(autoload 'htmlize-region "htmlize" "Convert the region to HTML, preserving colors and decorations.\nSee `htmlize-buffer' for details.\n\n(fn BEG END &optional INTERACTIVE)" t)(autoload 'htmlize-file "htmlize" "Load FILE, fontify it, convert it to HTML, and save the result.\n\nContents of FILE are inserted into a temporary buffer, whose major mode\nis set with `normal-mode' as appropriate for the file type.  The buffer\nis subsequently fontified with `font-lock' and converted to HTML.  Note\nthat, unlike `htmlize-buffer', this function explicitly turns on\nfont-lock.  If a form of highlighting other than font-lock is desired,\nplease use `htmlize-buffer' directly on buffers so highlighted.\n\nBuffers currently visiting FILE are unaffected by this function.  The\nfunction does not change current buffer or move the point.\n\nIf TARGET is specified and names a directory, the resulting file will be\nsaved there instead of to FILE's directory.  If TARGET is specified and\ndoes not name a directory, it will be used as output file name.\n\n(fn FILE &optional TARGET)" t)(autoload 'htmlize-many-files "htmlize" "Convert FILES to HTML and save the corresponding HTML versions.\n\nFILES should be a list of file names to convert.  This function calls\n`htmlize-file' on each file; see that function for details.  When\ninvoked interactively, you are prompted for a list of files to convert,\nterminated with RET.\n\nIf TARGET-DIRECTORY is specified, the HTML files will be saved to that\ndirectory.  Normally, each HTML file is saved to the directory of the\ncorresponding source file.\n\n(fn FILES &optional TARGET-DIRECTORY)" t)(autoload 'htmlize-many-files-dired "htmlize" "HTMLize dired-marked files.\n\n(fn ARG &optional TARGET-DIRECTORY)" t)(autoload 'org-annotate-file "org-annotate-file" "Visit `org-annotate-file-storage-file` and add a new annotation section.\nThe annotation is opened at the new section which will be referencing\nthe point in the current file." t)(autoload 'org-annotate-file-show-section "org-annotate-file" "Add or show annotation entry in STORAGE-FILE and return the buffer.\nThe annotation will link to ANNOTATED-BUFFER if specified,\n  otherwise the current buffer is used.\n\n(fn STORAGE-FILE &optional ANNOTATED-BUFFER)")(autoload 'org-eldoc-load "org-eldoc" "Set up org-eldoc documentation function." t)(autoload 'org-registry-show "org-registry" "Show Org files where there are links pointing to the current\nbuffer.\n\n(fn &optional VISIT)" t)(autoload 'org-registry-visit "org-registry" "If an Org file contains a link to the current location, visit\nthis file." t)(autoload 'org-registry-initialize "org-registry" "Initialize `org-registry-alist'.\nIf FROM-SCRATCH is non-nil or the registry does not exist yet,\ncreate a new registry from scratch and eval it. If the registry\nexists, eval `org-registry-file' and make it the new value for\n`org-registry-alist'.\n\n(fn &optional FROM-SCRATCH)" t)(autoload 'org-registry-insinuate "org-registry" "Call `org-registry-update' after saving in Org-mode.\nUse with caution.  This could slow down things a bit." t)(autoload 'org-registry-update "org-registry" "Update the registry for the current Org file." t)(autoload 'org-screenshot-take "org-screenshot" "Take a screenshot and insert link to it at point, if image\ndisplay is already on (see \\[org-toggle-inline-images])\nscreenshot will be displayed as an image\n\nScreen area for the screenshot is selected with the mouse, left\nclick on a window screenshots that window, while left click and\ndrag selects a region. Pressing any key cancels the screen shot\n\nWith `C-u' universal argument waits one second after target is\nselected before taking the screenshot. With double `C-u' wait two\nseconds.\n\nWith triple `C-u' wait 3 seconds, and also rings the bell when\nscreenshot is done, any more `C-u' after that increases delay by\n2 seconds\n\n(fn &optional DELAY)" t)(autoload 'org-screenshot-rotate-prev "org-screenshot" "Rotate last screenshot with one of the previously taken\nscreenshots from the same directory. If DIR is negative, rotate\nin the other direction\n\n(fn DIR)" t)(autoload 'org-screenshot-rotate-next "org-screenshot" "Rotate last screenshot with one of the previously taken\nscreenshots from the same directory. If DIR is negative, rotate\nin the other direction\n\n(fn DIR)" t)(autoload 'org-screenshot-show-unused "org-screenshot" "Open A Dired buffer with unused screenshots marked" t)(autoload 'org-toc-show "org-toc" "Show the table of contents of the current Org-mode buffer.\n\n(fn &optional DEPTH POSITION)" t)(autoload 'org-freemind-export-to-freemind "ox-freemind" "Export current buffer to a Freemind Mindmap file.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nWhen optional argument BODY-ONLY is non-nil, only write code\nbetween \"<body>\" and \"</body>\" tags.\n\nEXT-PLIST, when provided, is a property list with external\nparameters overriding Org default settings, but still inferior to\nfile-local settings.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t)(autoload 'org-taskjuggler-export "ox-taskjuggler" "Export current buffer to a TaskJuggler file.\n\nThe exporter looks for a tree with tag that matches\n`org-taskjuggler-project-tag' and takes this as the tasks for\nthis project.  The first node of this tree defines the project\nproperties such as project name and project period.\n\nIf there is a tree with tag that matches\n`org-taskjuggler-resource-tag' this tree is taken as resources\nfor the project.  If no resources are specified, a default\nresource is created and allocated to the project.\n\nAlso the TaskJuggler project will be created with default reports\nas defined in `org-taskjuggler-default-reports'.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nA non-nil optional argument ASYNC means the process should happen\nasynchronously.  The resulting file should be accessible through\nthe `org-export-stack' interface.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nReturn output file's name.\n\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY)" t)(autoload 'org-taskjuggler-export-and-process "ox-taskjuggler" "Export current buffer to a TaskJuggler file and process it.\n\nThe exporter looks for a tree with tag that matches\n`org-taskjuggler-project-tag' and takes this as the tasks for\nthis project.  The first node of this tree defines the project\nproperties such as project name and project period.\n\nIf there is a tree with tag that matches\n`org-taskjuggler-resource-tag' this tree is taken as resources\nfor the project.  If no resources are specified, a default\nresource is created and allocated to the project.\n\nAlso the TaskJuggler project will be created with default reports\nas defined in `org-taskjuggler-default-reports'.\n\nIf narrowing is active in the current buffer, only export its\nnarrowed part.\n\nIf a region is active, export that region.\n\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\nat point, extracting information from the headline properties\nfirst.\n\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\ncontents of hidden elements.\n\nReturn a list of reports.\n\n(fn &optional SUBTREEP VISIBLE-ONLY)" t)(autoload 'org-taskjuggler-export-process-and-open "ox-taskjuggler" "Export current buffer to a TaskJuggler file, process and open it.\n\nExport and process the file using\n`org-taskjuggler-export-and-process' and open the generated\nreports with a browser.\n\nIf you are targeting TaskJuggler 2.4 (see\n`org-taskjuggler-target-version') the processing and display of\nthe reports is done using the TaskJuggler GUI.\n\n(fn &optional SUBTREEP VISIBLE-ONLY)" t)(autoload 'evil-markdown-mode "evil-markdown" "Buffer local minor mode for evil-markdown\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Markdown mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-markdown-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-markdown-set-key-theme "evil-markdown" "Select what key THEMEs to enable.\n\n(fn THEME)")(autoload 'edit-indirect-region "edit-indirect" "Edit the region BEG..END in a separate buffer.\nThe region is copied, without text properties, to a separate\nbuffer, called edit-indirect buffer, and\n`edit-indirect-guess-mode-function' is called to set the major\nmode.\nWhen done, exit with `edit-indirect-commit', which will remove the\noriginal region and replace it with the edited version; or with\n`edit-indirect-abort', which will drop the modifications.\n\nThis differs from `clone-indirect-buffer' with narrowing in that\nthe text properties are not shared, so the parent buffer major mode\nand the edit-indirect buffer major mode will not be able to tread\non each other's toes by setting up potentially conflicting text\nproperties, which happens surprisingly often when the font-lock\nmode is used.\n\nEdit-indirect buffers use the `edit-indirect-mode-map' keymap.\nRegions with active edit-indirect buffers use the\n`edit-indirect-overlay-map' keymap.\n\nIf there's already an edit-indirect buffer for BEG..END, use that.\nIf there's already an edit-indirect buffer active overlapping any\nportion of BEG..END, an `edit-indirect-overlapping' error is\nsignaled.\n\nWhen DISPLAY-BUFFER is non-nil or when called interactively,\ndisplay the edit-indirect buffer in some window and select it.\n\nIn any case, return the edit-indirect buffer.\n\n(fn BEG END &optional DISPLAY-BUFFER)" t)(autoload 'markdown-toc-version "markdown-toc" "Markdown-toc version." t)(autoload 'markdown-toc-generate-toc "markdown-toc" "Generate a TOC for markdown file at current point.\nDeletes any previous TOC.\nIf called interactively with prefix arg REPLACE-TOC-P, replaces previous TOC.\n\n(fn &optional REPLACE-TOC-P)" t)(autoload 'markdown-toc-generate-or-refresh-toc "markdown-toc" "Generate a TOC for markdown file at current point or refreshes an already generated TOC." t)(autoload 'markdown-toc-refresh-toc "markdown-toc" "Refreshes an already generated TOC." t)(autoload 'markdown-toc-delete-toc "markdown-toc" "Deletes a previously generated TOC." t)(autoload 'markdown-toc-follow-link-at-point "markdown-toc" "On a given toc link, navigate to the current markdown header.\nIf the toc is misindented (according to markdown-toc-indentation-space`)\nor if not on a toc link, this does nothing.\n" t)(autoload 'markdown-toc-mode "markdown-toc" "Functionality for generating toc in markdown file.\n\nWith no argument, the mode is toggled on/off.\nNon-nil argument turns mode on.\nNil argument turns mode off.\n\nCommands:\n\\{markdown-toc-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`Markdown-Toc mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `markdown-toc-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'markdown-mode "markdown-mode" "Major mode for editing Markdown files.\n\n(fn)" t)(autoload 'gfm-mode "markdown-mode" "Major mode for editing GitHub Flavored Markdown files.\n\n(fn)" t)(autoload 'markdown-view-mode "markdown-mode" "Major mode for viewing Markdown content.\n\n(fn)" t)(autoload 'gfm-view-mode "markdown-mode" "Major mode for viewing GitHub Flavored Markdown content.\n\n(fn)" t)(autoload 'markdown-live-preview-mode "markdown-mode" "Toggle native previewing on save for a specific markdown file.\n\nThis is a minor mode.  If called interactively, toggle the\n`Markdown-Live-Preview mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `markdown-live-preview-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'buttercup-run-at-point "buttercup" "Run the buttercup suite at point." t)(autoload 'buttercup-run-discover "buttercup" "Discover and load test files, then run all defined suites.\n\nTakes directories as command line arguments, defaulting to the\ncurrent directory.")(autoload 'buttercup-run-markdown-buffer "buttercup" "Run all test suites defined in MARKDOWN-BUFFERS.\nA suite must be defined within a Markdown \"lisp\" code block.\nIf MARKDOWN-BUFFERS is empty (nil), use the current buffer.\n\n(fn &rest MARKDOWN-BUFFERS)" t)(autoload 'buttercup-run-markdown "buttercup" "Run all test suites defined in Markdown files passed as arguments.\nA suite must be defined within a Markdown \"lisp\" code block.")(autoload 'buttercup-run-markdown-file "buttercup" "Run all test suites defined in Markdown FILE.\nA suite must be defined within a Markdown \"lisp\" code block.\n\n(fn FILE)" t)(autoload 'buttercup-minor-mode "buttercup" "Activate buttercup minor mode.\n\nWith buttercup minor mode active the following is activated:\n\n- `describe' and `it' forms are fontified with\n  `font-lock-keyword-face'.\n- `describe' and `it' forms are available from `imenu' for\n  quicker access.\n\nThis is a minor mode.  If called interactively, toggle the\n`Buttercup minor mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `buttercup-minor-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'flycheck-cask-setup "flycheck-cask" "Setup Cask integration for Flycheck.\n\nIf the current file is part of a Cask project, as denoted by the\nexistence of a Cask file in the file's directory or any ancestor\nthereof, configure Flycheck to initialze Cask packages while\nsyntax checking.\n\nSet `flycheck-emacs-lisp-initialize-packages' and\n`flycheck-emacs-lisp-package-user-dir' accordingly.")(autoload 'flycheck-manual "flycheck" "Open the Flycheck manual." t)(autoload 'flycheck-quick-help "flycheck" "Display brief Flycheck help." t)(autoload 'flycheck-mode "flycheck" "Flycheck is a minor mode for on-the-fly syntax checking.\n\nIn `flycheck-mode' the buffer is automatically syntax-checked\nusing the first suitable syntax checker from `flycheck-checkers'.\nUse `flycheck-select-checker' to select a checker for the current\nbuffer manually.\n\nIf you run into issues, use `\\[flycheck-verify-setup]' to get help.\n\nFlycheck supports many languages out of the box, and many\nadditional ones are available on MELPA.  Adding new ones is very\neasy.  Complete documentation is available online at URL\n`https://www.flycheck.org/en/latest/'.  Please report issues and\nrequest features at URL `https://github.com/flycheck/flycheck'.\n\nFlycheck displays its status in the mode line.  In the default\nconfiguration, it looks like this:\n\n`FlyC'     This buffer has not been checked yet.\n`FlyC*'    Flycheck is running.  Expect results soon!\n`FlyC:0'   Last check resulted in no errors and no warnings.\n`FlyC:3|5' This buffer contains three errors and five warnings.\n           Use `\\[flycheck-list-errors]' to see the list.\n`FlyC-'    Flycheck doesn't have a checker for this buffer.\n\nYou may also see the following icons:\n`FlyC!'    The checker crashed.\n`FlyC.'    The last syntax check was manually interrupted.\n`FlyC?'    The checker did something unexpected, like exiting with 1\n           but returning no errors.\n\nThe following keybindings are available in `flycheck-mode':\n\n\\{flycheck-mode-map}\n(you can change the prefix by customizing\n`flycheck-keymap-prefix')\n\nIf called interactively, enable Flycheck mode if ARG is positive,\nand disable it if ARG is zero or negative.  If called from Lisp,\nalso enable the mode if ARG is omitted or nil, and toggle it if\nARG is \x2018toggle\x2019; disable the mode otherwise.\n\n(fn &optional ARG)" t)(put 'global-flycheck-mode 'globalized-minor-mode t)(defvar global-flycheck-mode nil "Non-nil if Global Flycheck mode is enabled.\nSee the `global-flycheck-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-flycheck-mode'.")(autoload 'global-flycheck-mode "flycheck" "Toggle Flycheck mode in all buffers.\nWith prefix ARG, enable Global Flycheck mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nFlycheck mode is enabled in all buffers where `flycheck-mode-on-safe'\nwould do it.\n\nSee `flycheck-mode' for more information on Flycheck mode.\n\n(fn &optional ARG)" t)(autoload 'flycheck-define-error-level "flycheck" "Define a new error LEVEL with PROPERTIES.\n\nThe following PROPERTIES constitute an error level:\n\n`:severity SEVERITY'\n     A number denoting the severity of this level.  The higher\n     the number, the more severe is this level compared to other\n     levels.  Defaults to 0; info is -10, warning is 10, and\n     error is 100.\n\n     The severity is used by `flycheck-error-level-<' to\n     determine the ordering of errors according to their levels.\n\n`:compilation-level LEVEL'\n\n     A number indicating the broad class of messages that errors\n     at this level belong to: one of 0 (info), 1 (warning), or\n     2 or nil (error).  Defaults to nil.\n\n     This is used by `flycheck-checker-pattern-to-error-regexp'\n     to map error levels into `compilation-mode''s hierarchy and\n     to get proper highlighting of errors in `compilation-mode'.\n\n`:overlay-category CATEGORY'\n     A symbol denoting the overlay category to use for error\n     highlight overlays for this level.  See Info\n     node `(elisp)Overlay Properties' for more information about\n     overlay categories.\n\n     A category for an error level overlay should at least define\n     the `face' property, for error highlighting.  Another useful\n     property for error level categories is `priority', to\n     influence the stacking of multiple error level overlays.\n\n`:fringe-bitmap BITMAPS'\n     A fringe bitmap symbol denoting the bitmap to use for fringe\n     indicators for this level, or a cons of two bitmaps (one for\n     narrow fringes and one for wide fringes).  See Info node\n     `(elisp)Fringe Bitmaps' for more information about fringe\n     bitmaps, including a list of built-in fringe bitmaps.\n\n`:fringe-face FACE'\n     A face symbol denoting the face to use for fringe indicators\n     for this level.\n\n`:margin-spec SPEC'\n     A display specification indicating what to display in the\n     margin when `flycheck-indication-mode' is `left-margin' or\n     `right-margin'.  See Info node `(elisp)Displaying in the\n     Margins'.  If omitted, Flycheck generates an image spec from\n     the fringe bitmap.\n\n`:error-list-face FACE'\n     A face symbol denoting the face to use for messages of this\n     level in the error list.  See `flycheck-list-errors'.\n\n(fn LEVEL &rest PROPERTIES)")(function-put 'flycheck-define-error-level 'lisp-indent-function 1)(autoload 'flycheck-define-command-checker "flycheck" "Define SYMBOL as syntax checker to run a command.\n\nDefine SYMBOL as generic syntax checker via\n`flycheck-define-generic-checker', which uses an external command\nto check the buffer.  SYMBOL and DOCSTRING are the same as for\n`flycheck-define-generic-checker'.\n\nIn addition to the properties understood by\n`flycheck-define-generic-checker', the following PROPERTIES\nconstitute a command syntax checker.  Unless otherwise noted, all\nproperties are mandatory.  Note that the default `:error-filter'\nof command checkers is `flycheck-sanitize-errors'.\n\n`:command COMMAND'\n     The command to run for syntax checking.\n\n     COMMAND is a list of the form `(EXECUTABLE [ARG ...])'.\n\n     EXECUTABLE is a string with the executable of this syntax\n     checker.  It can be overridden with the variable\n     `flycheck-SYMBOL-executable'.  Note that this variable is\n     NOT implicitly defined by this function.  Use\n     `flycheck-def-executable-var' to define this variable.\n\n     Each ARG is an argument to the executable, either as string,\n     or as special symbol or form for\n     `flycheck-substitute-argument', which see.\n\n`:error-patterns PATTERNS'\n     A list of patterns to parse the output of the `:command'.\n\n     Each ITEM in PATTERNS is a list `(LEVEL SEXP ...)', where\n     LEVEL is a Flycheck error level (see\n     `flycheck-define-error-level'), followed by one or more RX\n     `SEXP's which parse an error of that level and extract line,\n     column, file name and the message.\n\n     See `rx' for general information about RX, and\n     `flycheck-rx-to-string' for some special RX forms provided\n     by Flycheck.\n\n     All patterns are applied in the order of declaration to the\n     whole output of the syntax checker.  Output already matched\n     by a pattern will not be matched by subsequent patterns.  In\n     other words, the first pattern wins.\n\n     This property is optional.  If omitted, however, an\n     `:error-parser' is mandatory.\n\n`:error-parser FUNCTION'\n     A function to parse errors with.\n\n     The function shall accept three arguments OUTPUT CHECKER\n     BUFFER.  OUTPUT is the syntax checker output as string,\n     CHECKER the syntax checker that was used, and BUFFER a\n     buffer object representing the checked buffer.  The function\n     must return a list of `flycheck-error' objects parsed from\n     OUTPUT.\n\n     This property is optional.  If omitted, it defaults to\n     `flycheck-parse-with-patterns'.  In this case,\n     `:error-patterns' is mandatory.\n\n`:standard-input t'\n     Whether to send the buffer contents on standard input.\n\n     If this property is given and has a non-nil value, send the\n     contents of the buffer on standard input.\n\n     Some checkers that support reading from standard input have\n     a separate flag to indicate the name of the file whose\n     contents are being passed on standard input (typically\n     `stdin-filename').  In that case, use the `(option)' form in\n     `:command' to pass the value of variable `buffer-file-name'\n     when the current buffer has a file name (that is,\n     use `option \"--stdin-file-name\" buffer-file-name').\n\n     For buffers not backed by files, checkers that support input\n     on stdin typically report a file name like `-' or `<stdin>'.\n     Make sure your error parser or patterns expect these file\n     names (for example, use `(or \"<stdin>\" (file-name))') or\n     call `flycheck-remove-error-file-names' in a custom\n     `:error-filter'.\n\n     Defaults to nil.\n\nNote that you may not give `:start', `:interrupt', and\n`:print-doc' for a command checker.  You can give a custom\n`:verify' function, though, whose results will be appended to the\ndefault `:verify' function of command checkers.\n\n(fn SYMBOL DOCSTRING &rest PROPERTIES)")(function-put 'flycheck-define-command-checker 'lisp-indent-function 1)(function-put 'flycheck-define-command-checker 'doc-string-elt 2)(autoload 'flycheck-def-config-file-var "flycheck" "Define SYMBOL as config file variable for CHECKER, with default FILE-NAME.\n\nSYMBOL is declared as customizable variable using `defcustom', to\nprovide configuration files for the given syntax CHECKER.\nCUSTOM-ARGS are forwarded to `defcustom'.\n\nFILE-NAME is the initial value of the new variable.  If omitted,\nthe default value is nil.  It can be either a string or a list of\nstrings.\n\nUse this together with the `config-file' form in the `:command'\nargument to `flycheck-define-checker'.\n\n(fn SYMBOL CHECKER &optional FILE-NAME &rest CUSTOM-ARGS)" nil t)(function-put 'flycheck-def-config-file-var 'lisp-indent-function 3)(autoload 'flycheck-def-option-var "flycheck" "Define SYMBOL as option variable with INIT-VALUE for CHECKER.\n\nSYMBOL is declared as customizable variable using `defcustom', to\nprovide an option for the given syntax CHECKERS (a checker or a\nlist of checkers).  INIT-VALUE is the initial value of the\nvariable, and DOCSTRING is its docstring.  CUSTOM-ARGS are\nforwarded to `defcustom'.\n\nUse this together with the `option', `option-list' and\n`option-flag' forms in the `:command' argument to\n`flycheck-define-checker'.\n\n(fn SYMBOL INIT-VALUE CHECKERS DOCSTRING &rest CUSTOM-ARGS)" nil t)(function-put 'flycheck-def-option-var 'lisp-indent-function 3)(function-put 'flycheck-def-option-var 'doc-string-elt 4)(autoload 'flycheck-define-checker "flycheck" "Define SYMBOL as command syntax checker with DOCSTRING and PROPERTIES.\n\nLike `flycheck-define-command-checker', but PROPERTIES must not\nbe quoted.  Also, implicitly define the executable variable for\nSYMBOL with `flycheck-def-executable-var'.\n\n(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil t)(function-put 'flycheck-define-checker 'lisp-indent-function 1)(function-put 'flycheck-define-checker 'doc-string-elt 2)(autoload 'flycheck-package-setup "flycheck-package" "Setup flycheck-package.\nAdd `flycheck-emacs-lisp-package' to `flycheck-checkers'." t)(autoload 'package-lint-describe-symbol-history "package-lint" "Show the version history of SYM, if any.\n\n(fn SYM)" t)(autoload 'package-lint-buffer "package-lint" "Get linter errors and warnings for BUFFER.\n\nReturns a list, each element of which is list of\n\n   (LINE COL TYPE MESSAGE)\n\nwhere TYPE is either `warning' or `error'.\n\nCurrent buffer is used if none is specified.\n\n(fn &optional BUFFER)")(autoload 'package-lint-current-buffer "package-lint" "Display lint errors and warnings for the current buffer." t)(autoload 'package-lint-batch-and-exit "package-lint" "Run `package-lint-buffer' on the files remaining on the command line.\nUse this only with -batch, it won't work interactively.\n\nWhen done, exit Emacs with status 1 in case of any errors, otherwise exit\nwith status 0.  The variable `package-lint-batch-fail-on-warnings' controls\nwhether or not warnings alone produce a non-zero exit code.")(autoload 'package-lint-looks-like-a-package-p "package-lint" "Return non-nil if the current buffer appears to be intended as a package.")(autoload 'elisp-demos-advice-describe-function-1 "elisp-demos" "\n\n(fn FUNCTION)")(autoload 'elisp-demos-advice-helpful-update "elisp-demos")(autoload 'elisp-demos-for-helpful "elisp-demos" "Find a demo for the current `helpful' buffer." t)(autoload 'elisp-def "elisp-def" "Go to the definition of the symbol at point." t)(autoload 'elisp-def-mode "elisp-def" "Minor mode for finding definitions with `elisp-def'.\n\n\\{elisp-def-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`Elisp-Def mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `elisp-def-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'overseer-version "overseer" "Get the Overseer version as string.\n\nIf called interactively or if SHOW-VERSION is non-nil, show the\nversion in the echo area and the messages buffer.\n\nThe returned string includes both, the version from package.el\nand the library version, if both a present and different.\n\nIf the version number could not be determined, signal an error,\nif called interactively, or if SHOW-VERSION is non-nil, otherwise\njust return nil.\n\n(fn &optional SHOW-VERSION)" t)(autoload 'overseer-mode "overseer" "Minor mode for emacs lisp files to test through ert-runner.\n\nKey bindings:\n\\{overseer-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`overseer mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `overseer-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'overseer-enable-mode "overseer")(dolist (hook '(emacs-lisp-mode-hook)) (add-hook hook 'overseer-enable-mode))(autoload 'pkg-info-library-original-version "pkg-info" "Get the original version in the header of LIBRARY.\n\nThe original version is stored in the X-Original-Version header.\nThis header is added by the MELPA package archive to preserve\nupstream version numbers.\n\nLIBRARY is either a symbol denoting a named feature, or a library\nname as string.\n\nIf SHOW is non-nil, show the version in the minibuffer.\n\nReturn the version from the header of LIBRARY as list.  Signal an\nerror if the LIBRARY was not found or had no X-Original-Version\nheader.\n\nSee Info node `(elisp)Library Headers' for more information\nabout library headers.\n\n(fn LIBRARY &optional SHOW)" t)(autoload 'pkg-info-library-version "pkg-info" "Get the version in the header of LIBRARY.\n\nLIBRARY is either a symbol denoting a named feature, or a library\nname as string.\n\nIf SHOW is non-nil, show the version in the minibuffer.\n\nReturn the version from the header of LIBRARY as list.  Signal an\nerror if the LIBRARY was not found or had no proper header.\n\nSee Info node `(elisp)Library Headers' for more information\nabout library headers.\n\n(fn LIBRARY &optional SHOW)" t)(autoload 'pkg-info-defining-library-original-version "pkg-info" "Get the original version of the library defining FUNCTION.\n\nThe original version is stored in the X-Original-Version header.\nThis header is added by the MELPA package archive to preserve\nupstream version numbers.\n\nIf SHOW is non-nil, show the version in mini-buffer.\n\nThis function is mainly intended to find the version of a major\nor minor mode, i.e.\n\n   (pkg-info-defining-library-version 'flycheck-mode)\n\nReturn the version of the library defining FUNCTION.  Signal an\nerror if FUNCTION is not a valid function, if its defining\nlibrary was not found, or if the library had no proper version\nheader.\n\n(fn FUNCTION &optional SHOW)" t)(autoload 'pkg-info-defining-library-version "pkg-info" "Get the version of the library defining FUNCTION.\n\nIf SHOW is non-nil, show the version in mini-buffer.\n\nThis function is mainly intended to find the version of a major\nor minor mode, i.e.\n\n   (pkg-info-defining-library-version 'flycheck-mode)\n\nReturn the version of the library defining FUNCTION.  Signal an\nerror if FUNCTION is not a valid function, if its defining\nlibrary was not found, or if the library had no proper version\nheader.\n\n(fn FUNCTION &optional SHOW)" t)(autoload 'pkg-info-package-version "pkg-info" "Get the version of an installed PACKAGE.\n\nIf SHOW is non-nil, show the version in the minibuffer.\n\nReturn the version as list, or nil if PACKAGE is not installed.\n\n(fn PACKAGE &optional SHOW)" t)(autoload 'pkg-info-version-info "pkg-info" "Obtain complete version info for LIBRARY and PACKAGE.\n\nLIBRARY is a symbol denoting a named feature, or a library name\nas string.  PACKAGE is a symbol denoting an ELPA package.  If\nomitted or nil, default to LIBRARY.\n\nIf SHOW is non-nil, show the version in the minibuffer.\n\nWhen called interactively, prompt for LIBRARY.  When called\ninteractively with prefix argument, prompt for PACKAGE as well.\n\nReturn a string with complete version information for LIBRARY.\nThis version information contains the version from the headers of\nLIBRARY, and the version of the installed PACKAGE, the LIBRARY is\npart of.  If PACKAGE is not installed, or if the PACKAGE version\nis the same as the LIBRARY version, do not include a package\nversion.\n\n(fn LIBRARY &optional PACKAGE SHOW)" t)(autoload 'macrostep-mode "macrostep" "Minor mode for inline expansion of macros in Emacs Lisp source buffers.\n\n\\<macrostep-mode-map>Progressively expand macro forms with \\[macrostep-expand], collapse them with \\[macrostep-collapse],\nand move back and forth with \\[macrostep-next-macro] and \\[macrostep-prev-macro].  Use \\[macrostep-collapse-all] or collapse all\nvisible expansions to quit and return to normal editing.\n\n\\{macrostep-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`Macrostep mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `macrostep-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'macrostep-expand "macrostep" "Expand the macro form following point by one step.\n\nEnters `macrostep-mode' if it is not already active, making the\nbuffer temporarily read-only.  If `macrostep-mode' is active and\nthe form following point is not a macro form, search forward in\nthe buffer and expand the next macro form found, if any.\n\nIf optional argument TOGGLE-SEPARATE-BUFFER is non-nil (or set\n with a prefix argument), the expansion is displayed in a\n separate buffer instead of inline in the current buffer.\n Setting `macrostep-expand-in-separate-buffer' to non-nil swaps\n these two behaviors.\n\n(fn &optional TOGGLE-SEPARATE-BUFFER)" t)(autoload 'macrostep-c-mode-hook "macrostep-c")(add-hook 'c-mode-hook #'macrostep-c-mode-hook)(autoload 'helpful-function "helpful" "Show help for function named SYMBOL.\n\nSee also `helpful-macro', `helpful-command' and `helpful-callable'.\n\n(fn SYMBOL)" t)(autoload 'helpful-command "helpful" "Show help for interactive function named SYMBOL.\n\nSee also `helpful-function'.\n\n(fn SYMBOL)" t)(autoload 'helpful-key "helpful" "Show help for interactive command bound to KEY-SEQUENCE.\n\n(fn KEY-SEQUENCE)" t)(autoload 'helpful-macro "helpful" "Show help for macro named SYMBOL.\n\n(fn SYMBOL)" t)(autoload 'helpful-callable "helpful" "Show help for function, macro or special form named SYMBOL.\n\nSee also `helpful-macro', `helpful-function' and `helpful-command'.\n\n(fn SYMBOL)" t)(autoload 'helpful-symbol "helpful" "Show help for SYMBOL, a variable, function, macro, or face.\n\nSee also `helpful-callable' and `helpful-variable'.\n\n(fn SYMBOL)" t)(autoload 'helpful-variable "helpful" "Show help for variable named SYMBOL.\n\n(fn SYMBOL)" t)(autoload 'helpful-at-point "helpful" "Show help for the symbol at point." t)(autoload 'elisp-refs-function "elisp-refs" "Display all the references to function SYMBOL, in all loaded\nelisp files.\n\nIf called with a prefix, prompt for a directory to limit the search.\n\nThis searches for functions, not macros. For that, see\n`elisp-refs-macro'.\n\n(fn SYMBOL &optional PATH-PREFIX)" t)(autoload 'elisp-refs-macro "elisp-refs" "Display all the references to macro SYMBOL, in all loaded\nelisp files.\n\nIf called with a prefix, prompt for a directory to limit the search.\n\nThis searches for macros, not functions. For that, see\n`elisp-refs-function'.\n\n(fn SYMBOL &optional PATH-PREFIX)" t)(autoload 'elisp-refs-special "elisp-refs" "Display all the references to special form SYMBOL, in all loaded\nelisp files.\n\nIf called with a prefix, prompt for a directory to limit the search.\n\n(fn SYMBOL &optional PATH-PREFIX)" t)(autoload 'elisp-refs-variable "elisp-refs" "Display all the references to variable SYMBOL, in all loaded\nelisp files.\n\nIf called with a prefix, prompt for a directory to limit the search.\n\n(fn SYMBOL &optional PATH-PREFIX)" t)(autoload 'elisp-refs-symbol "elisp-refs" "Display all the references to SYMBOL in all loaded elisp files.\n\nIf called with a prefix, prompt for a directory to limit the\nsearch.\n\n(fn SYMBOL &optional PATH-PREFIX)" t)(autoload 'highlight-quoted-mode "highlight-quoted" "Highlight Lisp quotes and quoted symbols.\n\nToggle Highlight-Quoted mode on or off.\nWith a prefix argument ARG, enable Highlight-Quoted mode if ARG is positive, and\ndisable it otherwise.  If called from Lisp, enable the mode if ARG is omitted or\nnil, and toggle it if ARG is `toggle'.\n\\{highlight-quoted-mode-map}\n\n(fn &optional ARG)" t)(autoload 'request-response-header "request" "Fetch the values of RESPONSE header field named FIELD-NAME.\n\nIt returns comma separated values when the header has multiple\nfield with the same name, as :RFC:`2616` specifies.\n\nExamples::\n\n  (request-response-header response\n                           \"content-type\") ; => \"text/html; charset=utf-8\"\n  (request-response-header response\n                           \"unknown-field\") ; => nil\n\n(fn RESPONSE FIELD-NAME)")(autoload 'request-response-headers "request" "Return RESPONSE headers as an alist.\nI would have chosen a function name that wasn't so suggestive that\n`headers` is a member of the `request-response` struct, but\nas there's already precedent with `request-response-header', I\nhew to consistency.\n\n(fn RESPONSE)")(autoload 'request "request" "Main entry requesting URL with property list SETTINGS as follow.\n\n==================== ========================================================\nKeyword argument      Explanation\n==================== ========================================================\nTYPE          (string)   type of request to make: POST/GET/PUT/DELETE\nPARAMS         (alist)   set \"?key=val\" part in URL\nDATA    (string/alist)   data to be sent to the server\nFILES          (alist)   files to be sent to the server (see below)\nPARSER        (symbol)   a function that reads current buffer and return data\nHEADERS        (alist)   additional headers to send with the request\nENCODING      (symbol)   encoding for request body (utf-8 by default)\nSUCCESS     (function)   called on success\nERROR       (function)   called on error\nCOMPLETE    (function)   called on both success and error\nTIMEOUT       (number)   timeout in second\nSTATUS-CODE    (alist)   map status code (int) to callback\nSYNC            (bool)   If non-nil, wait until request is done. Default is nil.\n==================== ========================================================\n\n\n* Callback functions\n\nCallback functions STATUS, ERROR, COMPLETE and `cdr\\='s in element of\nthe alist STATUS-CODE take same keyword arguments listed below.  For\nforward compatibility, these functions must ignore unused keyword\narguments (i.e., it\\='s better to use `&allow-other-keys\\=' [#]_).::\n\n    (CALLBACK                      ; SUCCESS/ERROR/COMPLETE/STATUS-CODE\n     :data          data           ; whatever PARSER function returns, or nil\n     :error-thrown  error-thrown   ; (ERROR-SYMBOL . DATA), or nil\n     :symbol-status symbol-status  ; success/error/timeout/abort/parse-error\n     :response      response       ; request-response object\n     ...)\n\n.. [#] `&allow-other-keys\\=' is a special \"markers\" available in macros\n   in the CL library for function definition such as `cl-defun\\=' and\n   `cl-function\\='.  Without this marker, you need to specify all arguments\n   to be passed.  This becomes problem when request.el adds new arguments\n   when calling callback functions.  If you use `&allow-other-keys\\='\n   (or manually ignore other arguments), your code is free from this\n   problem.  See info node `(cl) Argument Lists\\=' for more information.\n\nArguments data, error-thrown, symbol-status can be accessed by\n`request-response-data\\=', `request-response-error-thrown\\=',\n`request-response-symbol-status\\=' accessors, i.e.::\n\n    (request-response-data RESPONSE)  ; same as data\n\nResponse object holds other information which can be accessed by\nthe following accessors:\n`request-response-status-code\\=',\n`request-response-url\\=' and\n`request-response-settings\\='\n\n* STATUS-CODE callback\n\nSTATUS-CODE is an alist of the following format::\n\n    ((N-1 . CALLBACK-1)\n     (N-2 . CALLBACK-2)\n     ...)\n\nHere, N-1, N-2,... are integer status codes such as 200.\n\n\n* FILES\n\nFILES is an alist of the following format::\n\n    ((NAME-1 . FILE-1)\n     (NAME-2 . FILE-2)\n     ...)\n\nwhere FILE-N is a list of the form::\n\n    (FILENAME &key PATH BUFFER STRING MIME-TYPE)\n\nFILE-N can also be a string (path to the file) or a buffer object.\nIn that case, FILENAME is set to the file name or buffer name.\n\nExample FILES argument::\n\n    `((\"passwd\"   . \"/etc/passwd\")                ; filename = passwd\n      (\"scratch\"  . ,(get-buffer \"*scratch*\"))    ; filename = *scratch*\n      (\"passwd2\"  . (\"password.txt\" :file \"/etc/passwd\"))\n      (\"scratch2\" . (\"scratch.txt\"  :buffer ,(get-buffer \"*scratch*\")))\n      (\"data\"     . (\"data.csv\"     :data \"1,2,3\\n4,5,6\\n\")))\n\n.. note:: FILES is implemented only for curl backend for now.\n   As furl.el_ supports multipart POST, it should be possible to\n   support FILES in pure elisp by making furl.el_ another backend.\n   Contributions are welcome.\n\n   .. _furl.el: https://code.google.com/p/furl-el/\n\n\n* PARSER function\n\nPARSER function takes no argument and it is executed in the\nbuffer with HTTP response body.  The current position in the HTTP\nresponse buffer is at the beginning of the buffer.  As the HTTP\nheader is stripped off, the cursor is actually at the beginning\nof the response body.  So, for example, you can pass `json-read\\='\nto parse JSON object in the buffer.  To fetch whole response as a\nstring, pass `buffer-string\\='.\n\nWhen using `json-read\\=', it is useful to know that the returned\ntype can be modified by `json-object-type\\=', `json-array-type\\=',\n`json-key-type\\=', `json-false\\=' and `json-null\\='.  See docstring of\neach function for what it does.  For example, to convert JSON\nobjects to plist instead of alist, wrap `json-read\\=' by `lambda\\='\nlike this.::\n\n    (request\n     \"https://...\"\n     :parser (lambda ()\n               (let ((json-object-type \\='plist))\n                 (json-read)))\n     ...)\n\nThis is analogous to the `dataType\\=' argument of jQuery.ajax_.\nOnly this function can access to the process buffer, which\nis killed immediately after the execution of this function.\n\n* SYNC\n\nSynchronous request is functional, but *please* don\\='t use it\nother than testing or debugging.  Emacs users have better things\nto do rather than waiting for HTTP request.  If you want a better\nway to write callback chains, use `request-deferred\\='.\n\nIf you can\\='t avoid using it (e.g., you are inside of some hook\nwhich must return some value), make sure to set TIMEOUT to\nrelatively small value.\n\nDue to limitation of `url-retrieve-synchronously\\=', response slots\n`request-response-error-thrown\\=', `request-response-history\\=' and\n`request-response-url\\=' are unknown (always nil) when using\nsynchronous request with `url-retrieve\\=' backend.\n\n* Note\n\nAPI of `request\\=' is somewhat mixture of jQuery.ajax_ (Javascript)\nand requests.request_ (Python).\n\n.. _jQuery.ajax: https://api.jquery.com/jQuery.ajax/\n.. _requests.request: https://docs.python-requests.org\n\n(fn URL &rest SETTINGS &key (PARAMS nil) (DATA nil) (HEADERS nil) (ENCODING \\='utf-8) (ERROR nil) (SYNC nil) (RESPONSE (make-request-response)) &allow-other-keys)")(function-put 'request 'lisp-indent-function 'defun)(autoload 'request-untrampify-filename "request" "Return FILE as the local file name.\n\n(fn FILE)")(autoload 'request-abort "request" "Abort request for RESPONSE (the object returned by `request').\nNote that this function invoke ERROR and COMPLETE callbacks.\nCallbacks may not be called immediately but called later when\nassociated process is exited.\n\n(fn RESPONSE)")(defvar dumb-jump-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-M-g") 'dumb-jump-go) (define-key map (kbd "C-M-p") 'dumb-jump-back) (define-key map (kbd "C-M-q") 'dumb-jump-quick-look) map))(autoload 'dumb-jump-back "dumb-jump" "Jump back to where the last jump was done." t)(autoload 'dumb-jump-quick-look "dumb-jump" "Run dumb-jump-go in quick look mode.  That is, show a tooltip of where it would jump instead." t)(autoload 'dumb-jump-go-other-window "dumb-jump" "Like 'dumb-jump-go' but use 'find-file-other-window' instead of 'find-file'." t)(autoload 'dumb-jump-go-current-window "dumb-jump" "Like dumb-jump-go but always use 'find-file'." t)(autoload 'dumb-jump-go-prefer-external "dumb-jump" "Like dumb-jump-go but prefer external matches from the current file." t)(autoload 'dumb-jump-go-prompt "dumb-jump" "Like dumb-jump-go but prompts for function instead of using under point" t)(autoload 'dumb-jump-go-prefer-external-other-window "dumb-jump" "Like dumb-jump-go-prefer-external but use 'find-file-other-window' instead of 'find-file'." t)(autoload 'dumb-jump-go "dumb-jump" "Go to the function/variable declaration for thing at point.\nWhen USE-TOOLTIP is t a tooltip jump preview will show instead.\nWhen PREFER-EXTERNAL is t it will sort external matches before\ncurrent file.\n\n(fn &optional USE-TOOLTIP PREFER-EXTERNAL PROMPT)" t)(defvar dumb-jump-mode nil "Non-nil if Dumb-Jump mode is enabled.\nSee the `dumb-jump-mode' command\nfor a description of this minor mode.")(autoload 'dumb-jump-mode "dumb-jump" "Minor mode for jumping to variable and function definitions\n\nThis is a global minor mode.  If called interactively, toggle the\n`Dumb-Jump mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='dumb-jump-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dumb-jump-xref-activate "dumb-jump" "Function to activate xref backend.\nAdd this function to `xref-backend-functions' to dumb jump to be\nactiviated, whenever it finds a project. It is recommended to add\nit to the end, so that it only gets activated when no better\noption is found.")(autoload 'eros-eval-last-sexp "eros" "Wrapper for `eval-last-sexp' that overlays results.\n\n(fn EVAL-LAST-SEXP-ARG-INTERNAL)" t)(autoload 'eros-eval-defun "eros" "Wrapper for `eval-defun' that overlays results.\n\n(fn EDEBUG-IT)" t)(defvar eros-mode nil "Non-nil if Eros mode is enabled.\nSee the `eros-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `eros-mode'.")(autoload 'eros-mode "eros" "Display Emacs Lisp evaluation results overlays.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Eros mode' mode.  If the prefix argument is positive, enable the\nmode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='eros-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'quickrun-set-default "quickrun" "Set `key' as default key in programing language `lang'.\n\n(fn LANG KEY)")(autoload 'quickrun-select-default "quickrun" "Update the default." t)(autoload 'quickrun-add-command "quickrun" "Not documented.\n\n(fn KEY ALIST &key DEFAULT MODE OVERRIDE)")(function-put 'quickrun-add-command 'lisp-indent-function 'defun)(autoload 'quickrun "quickrun" "Run commands quickly for current buffer.\n\nWith universal prefix argument(C-u), select command-key,\nWith double prefix argument(C-u C-u), run in compile-only-mode.\n\n(fn &rest PLIST)" t)(autoload 'quickrun-select "quickrun" "Run commands after selecting the backend." t)(autoload 'quickrun-with-arg "quickrun" "Run commands quickly for current buffer with arguments.\n\n(fn ARG)" t)(autoload 'quickrun-region "quickrun" "Run commands with specified region.\n\n(fn START END)" t)(autoload 'quickrun-replace-region "quickrun" "Run commands with specified region and replace.\n\n(fn START END)" t)(autoload 'quickrun-eval-print "quickrun" "Run commands with specified region and replace.\n\n(fn START END)" t)(autoload 'quickrun-compile-only "quickrun" "Exec only compilation." t)(autoload 'quickrun-compile-only-select "quickrun" "Run commands after selecting the backend." t)(autoload 'quickrun-shell "quickrun" "Run commands in shell for interactive programs." t)(autoload 'quickrun-autorun-mode "quickrun" "`quickrun' after saving buffer.\n\nThis is a minor mode.  If called interactively, toggle the\n`Quickrun-Autorun mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `quickrun-autorun-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'anything-quickrun "quickrun" "Run quickrun with `anything'." t)(autoload 'helm-quickrun "quickrun" "Run quickrun with `helm'." t)(autoload 'flycheck-popup-tip-mode "flycheck-popup-tip" "A minor mode to show Flycheck error messages in a popup.\n\nThis is a minor mode.  If called interactively, toggle the\n`Flycheck-Popup-Tip mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `flycheck-popup-tip-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'gitattributes-mode "gitattributes-mode" "A major mode for editing .gitattributes files.\n\\{gitattributes-mode-map}\n\n(fn)" t)(dolist (pattern '("/\\.gitattributes\\'" "/info/attributes\\'" "/git/attributes\\'")) (add-to-list 'auto-mode-alist (cons pattern #'gitattributes-mode)))(autoload 'gitconfig-mode "gitconfig-mode" "A major mode for editing .gitconfig files.\n\n(fn)" t)(dolist (pattern '("/\\.gitconfig\\'" "/\\.git/config\\'" "/modules/.*/config\\'" "/git/config\\'" "/\\.gitmodules\\'" "/etc/gitconfig\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitconfig-mode)))(autoload 'gitignore-mode "gitignore-mode" "A major mode for editing .gitignore files.\n\n(fn)" t)(dolist (pattern (list "/\\.gitignore\\'" "/info/exclude\\'" "/git/ignore\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitignore-mode)))(autoload 'git-timemachine-toggle "git-timemachine" "Toggle git timemachine mode." t)(autoload 'git-timemachine "git-timemachine" "Enable git timemachine for file of current buffer." t)(autoload 'git-timemachine-switch-branch "git-timemachine" "Enable git timemachine for current buffer, switching to GIT-BRANCH.\n\n(fn GIT-BRANCH)" t)(autoload 'browse-at-remote "browse-at-remote" "Browse the current file with `browse-url'." t)(autoload 'browse-at-remote-kill "browse-at-remote" "Add the URL of the current file to the kill ring.\n\nWorks like `browse-at-remote', but puts the address in the\nkill ring instead of opening it with `browse-url'." t)(defalias 'bar-browse 'browse-at-remote "Browse the current file with `browse-url'.")(defalias 'bar-to-clipboard 'browse-at-remote-kill "Add the URL of the current file to the kill ring.\n\nWorks like `browse-at-remote', but puts the address in the\nkill ring instead of opening it with `browse-url'.")(defconst vundo-ascii-symbols '((selected-node . 120) (node . 111) (horizontal-stem . 45) (vertical-stem . 124) (branch . 124) (last-branch . 96)) "ASCII symbols to draw vundo tree.")(defconst vundo-unicode-symbols '((selected-node . 9679) (node . 9675) (horizontal-stem . 9472) (vertical-stem . 9474) (branch . 9500) (last-branch . 9492)) "Unicode symbols to draw vundo tree.")(autoload 'vundo "vundo" "Display visual undo for the current buffer." t)(autoload 'vundo-diff-mark "vundo-diff" "Mark NODE for vundo diff.\nNODE defaults to the current node.\n\n(fn &optional NODE)" t)(autoload 'vundo-diff-unmark "vundo-diff" "Unmark the node marked for vundo diff." t)(autoload 'vundo-diff "vundo-diff" "Perform diff between marked and current buffer state.\nDisplays in a separate diff buffer with name based on\nthe original buffer name." t)(autoload 'undo-fu-session-save "undo-fu-session" "Save undo data." t)(autoload 'undo-fu-session-recover "undo-fu-session" "Recover undo data." t)(autoload 'undo-fu-session-compression-update "undo-fu-session" "Update existing undo session data after changing compression settings." t)(autoload 'undo-fu-session-mode "undo-fu-session" "Toggle saving the undo data in the current buffer (Undo-Fu Session Mode).\n\nThis is a minor mode.  If called interactively, toggle the\n`Undo-Fu-Session mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `undo-fu-session-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'undo-fu-session-global-mode 'globalized-minor-mode t)(defvar undo-fu-session-global-mode nil "Non-nil if Undo-Fu-Session-Global mode is enabled.\nSee the `undo-fu-session-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `undo-fu-session-global-mode'.")(autoload 'undo-fu-session-global-mode "undo-fu-session" "Toggle Undo-Fu-Session mode in all buffers.\nWith prefix ARG, enable Undo-Fu-Session-Global mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nUndo-Fu-Session mode is enabled in all buffers where\n`undo-fu-session--mode-turn-on' would do it.\n\nSee `undo-fu-session-mode' for more information on Undo-Fu-Session\nmode.\n\n(fn &optional ARG)" t)(autoload 'undo-fu-disable-checkpoint "undo-fu" "Remove the undo-fu checkpoint, making all future actions unconstrained.\n\nThis command is needed when `undo-fu-ignore-keyboard-quit' is t,\nsince in this case `keyboard-quit' cannot be used\nto perform unconstrained undo/redo actions." t)(autoload 'undo-fu-only-redo-all "undo-fu" "Redo all actions until the initial undo step.\n\nwraps the `undo' function." t)(autoload 'undo-fu-only-redo "undo-fu" "Redo an action until the initial undo action.\n\nwraps the `undo' function.\n\nOptional argument ARG The number of steps to redo.\n\n(fn &optional ARG)" t)(autoload 'undo-fu-only-undo "undo-fu" "Undo the last action.\n\nwraps the `undo-only' function.\n\nOptional argument ARG the number of steps to undo.\n\n(fn &optional ARG)" t)(autoload 'undo-fu-clear-all "undo-fu" "Clear all undo/redo steps." t)(autoload 'diredfl-mode "diredfl" "Enable additional font locking in `dired-mode'.\n\nThis is a minor mode.  If called interactively, toggle the\n`Diredfl mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diredfl-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'diredfl-global-mode 'globalized-minor-mode t)(defvar diredfl-global-mode nil "Non-nil if Diredfl-Global mode is enabled.\nSee the `diredfl-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `diredfl-global-mode'.")(autoload 'diredfl-global-mode "diredfl" "Toggle Diredfl mode in all buffers.\nWith prefix ARG, enable Diredfl-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDiredfl mode is enabled in all buffers where `(lambda nil (when\n(derived-mode-p 'dired-mode) (diredfl-mode)))' would do it.\n\nSee `diredfl-mode' for more information on Diredfl mode.\n\n(fn &optional ARG)" t)(defvar dirvish-override-dired-mode nil "Non-nil if Dirvish-Override-Dired mode is enabled.\nSee the `dirvish-override-dired-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `dirvish-override-dired-mode'.")(autoload 'dirvish-override-dired-mode "dirvish" "Let Dirvish take over Dired globally.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Dirvish-Override-Dired mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='dirvish-override-dired-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dirvish "dirvish" "Start a full frame Dirvish session with optional PATH.\nIf called with \\[universal-arguments], prompt for PATH,\notherwise it defaults to `default-directory'.\n\n(fn &optional PATH)" t)(autoload 'dirvish-dwim "dirvish" "Start a fullframe session only when `one-window-p'.\nIf called with \\[universal-arguments], prompt for PATH,\notherwise it defaults to `default-directory'.\nIf `one-window-p' returns nil, open PATH using regular Dired.\n\n(fn &optional PATH)" t)(autoload 'dirvish-emerge-menu "dirvish-emerge" "Manage pinned files in Dirvish." t)(autoload 'dirvish-emerge-mode "dirvish-emerge" "Toggle grouping of files in Dirvish.\n\nThis is a minor mode.  If called interactively, toggle the\n`Dirvish-Emerge mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `dirvish-emerge-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dirvish-setup-menu "dirvish-extras" nil t)(autoload 'dirvish-copy-file-name "dirvish-extras" "Copy filename of marked files.\nIf MULTI-LINE, make every name occupy a new line.\n\n(fn &optional MULTI-LINE)" t)(autoload 'dirvish-copy-file-path "dirvish-extras" "Copy filepath of marked files.\nIf MULTI-LINE, make every path occupy a new line.\n\n(fn &optional MULTI-LINE)" t)(autoload 'dirvish-total-file-size "dirvish-extras" "Echo total file size of FILESET.\nFILESET defaults to `dired-get-marked-files'.\n\n(fn &optional FILESET)" t)(autoload 'dirvish-layout-toggle "dirvish-extras" "Toggle layout of current Dirvish session.\nA session with layout means it has a companion preview window and\npossibly one or more parent windows." t)(autoload 'dirvish-layout-switch "dirvish-extras" "Switch Dirvish layout according to RECIPE.\nIf RECIPE is not provided, switch to the recipe next to the\ncurrent layout defined in `dirvish-layout-recipes'.\n\n(fn &optional RECIPE)" t)(autoload 'dirvish-file-info-menu "dirvish-extras" nil t)(autoload 'dirvish-chxxx-menu "dirvish-extras" nil t)(autoload 'dirvish-mark-menu "dirvish-extras" nil t)(autoload 'dirvish-dired-cheatsheet "dirvish-extras" nil t)(autoload 'dirvish-fd-switches-menu "dirvish-fd" nil t)(autoload 'dirvish-fd-jump "dirvish-fd" "Browse directories using `fd' command.\nThis command takes a while to index all the directories the first\ntime you run it.  After the indexing, it fires up instantly.\n\nIf called with \\`C-u' or if CURRENT-DIR-P holds the value 4,\nsearch for directories in the current directory.  Otherwise,\nsearch for directories in `dirvish-fd-default-dir'.\n\nIf prefixed twice with \\`C-u' or if CURRENT-DIR-P holds the\nvalue 16, let the user choose the root directory of their search.\n\n(fn &optional CURRENT-DIR-P)" t)(autoload 'dirvish-fd "dirvish-fd" "Run `fd' on DIR and go into Dired mode on a buffer of the output.\nThe command run is essentially:\n\n  fd --color=never -0 `dirvish-fd-switches' PATTERN\n     --exec-batch `dirvish-fd-ls-program' `dired-listing-switches' --directory.\n\n(fn DIR PATTERN)" t)(autoload 'dirvish-fd-ask "dirvish-fd" "The same as `dirvish-fd' but ask initial `pattern' via prompt. \n\n(fn DIR PATTERN)" t)(autoload 'dirvish-history-jump "dirvish-history" "Open a target directory from `dirvish--history'." t)(autoload 'dirvish-history-last "dirvish-history" "Switch to the most recently visited dirvish buffer." t)(autoload 'dirvish-history-go-forward "dirvish-history" "Navigate to next ARG directory in history.\nARG defaults to 1.\n\n(fn ARG)" t)(autoload 'dirvish-history-go-backward "dirvish-history" "Navigate to previous ARG directory in history.\nARG defaults to 1.\n\n(fn ARG)" t)(autoload 'dirvish-history-menu "dirvish-history" nil t)(autoload 'dirvish-quicksort "dirvish-ls" nil t)(autoload 'dirvish-ls-switches-menu "dirvish-ls" nil t)(autoload 'dirvish-narrow "dirvish-narrow" "Narrow a Dirvish buffer to the files matching a regex." t)(defvar dirvish-peek-mode nil "Non-nil if Dirvish-Peek mode is enabled.\nSee the `dirvish-peek-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `dirvish-peek-mode'.")(autoload 'dirvish-peek-mode "dirvish-peek" "Show file preview when narrowing candidates using minibuffer.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Dirvish-Peek mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='dirvish-peek-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dirvish-quick-access "dirvish-quick-access" nil t)(defvar dirvish-side-follow-mode nil "Non-nil if Dirvish-Side-Follow mode is enabled.\nSee the `dirvish-side-follow-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `dirvish-side-follow-mode'.")(autoload 'dirvish-side-follow-mode "dirvish-side" "Toggle `dirvish-side-follow-mode'.\n\nWhen enabled the visible side session will select the current\nbuffer's filename.  It will also visits the latest `project-root'\nafter switching to a new project.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Dirvish-Side-Follow mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='dirvish-side-follow-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'dirvish-side "dirvish-side" "Toggle a Dirvish session at the side window.\n\n- If the current window is a side session window, hide it.\n- If a side session is visible, select it.\n- If a side session exists but is not visible, show it.\n- If there is no side session exists,create a new one with PATH.\n\nIf called with \\[universal-arguments], prompt for PATH,\notherwise it defaults to `project-current'.\n\n(fn &optional PATH)" t)(autoload 'dirvish-subtree-up "dirvish-subtree" "Jump to beginning of current subtree." t)(autoload 'dirvish-subtree-remove "dirvish-subtree" "Remove subtree at point." t)(autoload 'dirvish-subtree-clear "dirvish-subtree" "Clear all subtrees in the buffer." t)(autoload 'dirvish-subtree-toggle "dirvish-subtree" "Insert subtree at point or remove it if it was not present." t)(autoload 'dirvish-subtree-menu "dirvish-subtree" nil t)(autoload 'dirvish-vc-menu "dirvish-vc" nil t)(autoload 'dirvish-yank-menu "dirvish-yank" nil t)(autoload 'dirvish-yank "dirvish-yank" "Paste marked files to DEST.\nPrompt for DEST when prefixed with \\[universal-argument], it\ndefaults to `dired-current-directory.'\n\n(fn &optional DEST)" t)(autoload 'dirvish-move "dirvish-yank" "Move marked files to DEST.\nPrompt for DEST when prefixed with \\[universal-argument], it\ndefaults to `dired-current-directory'.\n\n(fn &optional DEST)" t)(autoload 'dirvish-symlink "dirvish-yank" "Symlink marked files to DEST.\nPrompt for DEST when prefixed with \\[universal-argument], it\ndefaults to `dired-current-directory'.\n\n(fn &optional DEST)" t)(autoload 'dirvish-relative-symlink "dirvish-yank" "Similar to `dirvish-symlink', but link files relatively.\nPrompt for DEST when prefixed with \\[universal-argument], it\ndefaults to `dired-current-directory'.\n\n(fn &optional DEST)" t)(autoload 'dirvish-hardlink "dirvish-yank" "Hardlink marked files to DEST.\nPrompt for DEST when prefixed with \\[universal-argument], it\ndefaults to `dired-current-directory'.\n\n(fn &optional DEST)" t)(autoload 'dirvish-rsync "dirvish-yank" "Rsync marked files to DEST, prompt for DEST if not called with.\nIf either the sources or the DEST is located in a remote host,\nthe `dirvish-yank-rsync-program' and `dirvish-yank-rsync-args'\nare used to transfer the files.\n\nThis command requires proper ssh authentication setup to work\ncorrectly for file transfer involving remote hosts, because rsync\ncommand is always run locally, the password prompts may lead to\nunexpected errors.\n\n(fn DEST)" t)(autoload 'dirvish-rsync-transient "dirvish-yank" nil t)(autoload 'dirvish-yank--rsync-apply-switches-and-copy "dirvish-yank" "Execute rsync command generated by transient ARGS.\n\n(fn ARGS)" t)(autoload 'doom-snippets-remove-compiled-snippets "doom-snippets" "Delete all .yas-compiled-snippets.el files." t)(autoload 'doom-snippets-initialize "doom-snippets" "Add `doom-snippets-dir' to `yas-snippet-dirs', replacing the default\nyasnippet directory.")(eval-after-load 'yasnippet (lambda nil (doom-snippets-initialize)))(autoload 'yas-minor-mode "yasnippet" "Toggle YASnippet mode.\n\nWhen YASnippet mode is enabled, `yas-expand', normally bound to\nthe TAB key, expands snippets of code depending on the major\nmode.\n\nWith no argument, this command toggles the mode.\npositive prefix argument turns on the mode.\nNegative prefix argument turns off the mode.\n\nKey bindings:\n\\{yas-minor-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the `yas\nminor mode' mode.  If the prefix argument is positive, enable the\nmode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `yas-minor-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'yas-global-mode 'globalized-minor-mode t)(defvar yas-global-mode nil "Non-nil if Yas-Global mode is enabled.\nSee the `yas-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `yas-global-mode'.")(autoload 'yas-global-mode "yasnippet" "Toggle Yas minor mode in all buffers.\nWith prefix ARG, enable Yas-Global mode if ARG is positive; otherwise,\ndisable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nYas minor mode is enabled in all buffers where `yas-minor-mode-on'\nwould do it.\n\nSee `yas-minor-mode' for more information on Yas minor mode.\n\n(fn &optional ARG)" t)(autoload 'snippet-mode "yasnippet" "A mode for editing yasnippets" t nil)(autoload 'aya-create "auto-yasnippet" "Create a snippet from the text between BEG and END.\nWhen the bounds are not given, use either the current region or line.\n\nRemove `aya-marker' prefixes, write the corresponding snippet to\n`aya-current', with words prefixed by `aya-marker' as fields, and\nmirrors properly set up.\n\n(fn &optional BEG END)" t)(autoload 'aya-create-one-line "auto-yasnippet" "A simplistic `aya-create' to create only one mirror.\nYou can still have as many instances of this mirror as you want.\nIt's less flexible than `aya-create', but faster.\nIt uses a different marker, which is `aya-marker-one-line'.\nYou can use it to quickly generate one-liners such as\nmenu.add_item(spamspamspam, \"spamspamspam\")" t)(autoload 'aya-expand "auto-yasnippet" "Insert the last yasnippet created by `aya-create'.\n\nOptionally use PREFIX to set any field as `$0' for wrapping the\ncurrent region. (`$0' also sets the exit point after `aya-expand'\nwhen there's no active region.) When PREFIX is it defaults to 1.\n\nFor example let's say the second field in a snippet is where you\nwant to wrap the currently selected region.\n\nUse `M-2' \\[aya-expand].\n\nIf we use this text as a snippet:\n\n```~lang\n~code\n````'\n\nand assume the selected region as:\n\n`let somePrettyComplexCode = \"Hello World!\"'\n\nwe'd do `M-2' \\[aya-expand] which allows us to\nfill in `~lang' as `javascript' and wraps our\ncode into the code-fences like this.\n\n```javascript\nlet somePrettyComplexCode = \"Hello World!\"\n```\n\nHint: if you view the current snippet(s) in history with\n`aya-expand-from-history'. The snippets are shown with their\nfields numbered.\n\nIn our example the snippet looks like like this:\n\n\\`\\`\\`$1\x2936$2\x2936\\`\\`\\`\x2936\n\n(fn &optional PREFIX)" t)(autoload 'aya-expand-from-history "auto-yasnippet" "Select and insert a yasnippet from the `aya-history'.\nThe selected snippet will become `aya-current'\nand will be used for consecutive `aya-expand' commands.\n\nWhen PREFIX is given, the corresponding field number is\nmodified to make it the current point after expansion.\n\n(fn &optional PREFIX)" t)(autoload 'aya-delete-from-history "auto-yasnippet" "Select and delete one or more snippets from `aya-history'.\nIf the selected snippet is also `aya-current', it will be replaced\nby the next snippet in history, or blank if no other history items\nare available." t)(autoload 'aya-open-line "auto-yasnippet" "Call `open-line', unless there are abbrevs or snippets at point.\nIn that case expand them.  If there's a snippet expansion in progress,\nmove to the next field.  Call `open-line' if nothing else applies." t)(autoload 'aya-yank-snippet "auto-yasnippet" "Insert current snippet at point.\nTo save a snippet permanently, create an empty file and call this." t)(autoload 'aya-yank-snippet-from-history "auto-yasnippet" "Insert snippet from history at point." t)(autoload 'evil-vimish-fold-mode "evil-vimish-fold" "Evil-vimish-fold-mode.\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Vimish-Fold mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-vimish-fold-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-evil-vimish-fold-mode 'globalized-minor-mode t)(defvar global-evil-vimish-fold-mode nil "Non-nil if Global Evil-Vimish-Fold mode is enabled.\nSee the `global-evil-vimish-fold-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-evil-vimish-fold-mode'.")(autoload 'global-evil-vimish-fold-mode "evil-vimish-fold" "Toggle Evil-Vimish-Fold mode in all buffers.\nWith prefix ARG, enable Global Evil-Vimish-Fold mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nEvil-Vimish-Fold mode is enabled in all buffers where\n`turn-on-evil-vimish-fold-mode' would do it.\n\nSee `evil-vimish-fold-mode' for more information on Evil-Vimish-Fold\nmode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-evil-vimish-fold-mode "evil-vimish-fold")(autoload 'turn-off-evil-vimish-fold-mode "evil-vimish-fold" "Turn off `evil-vimish-fold-mode'." t)(autoload 'vimish-fold "vimish-fold" "Fold active region staring at BEG, ending at END.\n\n(fn BEG END)" t)(autoload 'vimish-fold-unfold "vimish-fold" "Delete all `vimish-fold--folded' overlays at point." t)(autoload 'vimish-fold-refold "vimish-fold" "Refold unfolded fold at point." t)(autoload 'vimish-fold-delete "vimish-fold" "Delete fold at point." t)(autoload 'vimish-fold-unfold-all "vimish-fold" "Unfold all folds in current buffer." t)(autoload 'vimish-fold-refold-all "vimish-fold" "Refold all closed folds in current buffer." t)(autoload 'vimish-fold-delete-all "vimish-fold" "Delete all folds in current buffer." t)(autoload 'vimish-fold-toggle "vimish-fold" "Toggle fold at point." t)(autoload 'vimish-fold-toggle-all "vimish-fold" "Toggle all folds in current buffer." t)(autoload 'vimish-fold-avy "vimish-fold" "Fold region of text between point and line selected with avy.\n\nThis feature needs `avy' package." t)(autoload 'vimish-fold-next-fold "vimish-fold" "Jump to next folded region in current buffer." t)(autoload 'vimish-fold-previous-fold "vimish-fold" "Jump to previous folded region in current buffer." t)(autoload 'vimish-fold-from-marks "vimish-fold" "Create folds from folding symbols.\n\nMark strings are controlled by `vimish-fold-marks' customize variable." t)(autoload 'vimish-fold-mode "vimish-fold" "Toggle `vimish-fold-mode' minor mode.\n\nWith a prefix argument ARG, enable `vimish-fold-mode' mode if ARG\nis positive, and disable it otherwise.  If called from Lisp,\nenable the mode if ARG is omitted or NIL, and toggle it if ARG is\n`toggle'.\n\nThis minor mode sets hooks so when you `find-file' it calls\n`vimish-fold--restore-folds' and when you kill a file it calls\n`vimish-fold--save-folds'.\n\nFor globalized version of this mode see `vimish-fold-global-mode'.\n\n(fn &optional ARG)" t)(put 'vimish-fold-global-mode 'globalized-minor-mode t)(defvar vimish-fold-global-mode nil "Non-nil if Vimish-Fold-Global mode is enabled.\nSee the `vimish-fold-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vimish-fold-global-mode'.")(autoload 'vimish-fold-global-mode "vimish-fold" "Toggle Vimish-Fold mode in all buffers.\nWith prefix ARG, enable Vimish-Fold-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nVimish-Fold mode is enabled in all buffers where `vimish-fold-mode'\nwould do it.\n\nSee `vimish-fold-mode' for more information on Vimish-Fold mode.\n\n(fn &optional ARG)" t)(autoload 'evil-collection-translate-minor-mode-key "evil-collection" "Translate keys in the keymap(s) corresponding to STATES and MODES.\n\nSimilar to `evil-collection-translate-key' but for minor modes.\nSTATES should be the name of an evil state, a list of states, or nil. MODES\nshould be a symbol corresponding to minor-mode to make the translations in or a\nlist of minor-mode symbols. TRANSLATIONS corresponds to a list of\nkey replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to\n\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a\nkey. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial\ninvocation, and future invocations will always look up keys in the backup\nkeymap. When no TRANSLATIONS are given, this function will only create the\nbackup keymap without making any translations. On the other hand, if DESTRUCTIVE\nis non-nil, the keymap will be destructively altered without creating a backup.\nFor example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"\nwould continue to swap and unswap the definitions of these keys. This means that\nwhen DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\ninvocation.\n\n(fn STATES MODES &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)")(function-put 'evil-collection-translate-minor-mode-key 'lisp-indent-function 'defun)(autoload 'evil-collection-translate-key "evil-collection" "Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.\nSTATES should be the name of an evil state, a list of states, or nil. KEYMAPS\nshould be a symbol corresponding to the keymap to make the translations in or a\nlist of keymap symbols. Like `evil-define-key', when a keymap does not exist,\nthe keybindings will be deferred until the keymap is defined, so\n`with-eval-after-load' is not necessary. TRANSLATIONS corresponds to a list of\nkey replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to\n\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a\nkey. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial\ninvocation, and future invocations will always look up keys in the backup\nkeymap. When no TRANSLATIONS are given, this function will only create the\nbackup keymap without making any translations. On the other hand, if DESTRUCTIVE\nis non-nil, the keymap will be destructively altered without creating a backup.\nFor example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"\nwould continue to swap and unswap the definitions of these keys. This means that\nwhen DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\ninvocation.\n\n(fn STATES KEYMAPS &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)")(function-put 'evil-collection-translate-key 'lisp-indent-function 'defun)(autoload 'evil-collection-swap-key "evil-collection" "Wrapper around `evil-collection-translate-key' for swapping keys.\nSTATES, KEYMAPS, and ARGS are passed to `evil-collection-translate-key'. ARGS\nshould consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\"\n\"a\" with `evil-collection-translate-key') and optionally keyword arguments for\n`evil-collection-translate-key'.\n\n(fn STATES KEYMAPS &rest ARGS)" nil t)(function-put 'evil-collection-swap-key 'lisp-indent-function 'defun)(autoload 'evil-collection-swap-minor-mode-key "evil-collection" "Wrapper around `evil-collection-translate-minor-mode-key' for swapping keys.\nSTATES, MODES, and ARGS are passed to\n`evil-collection-translate-minor-mode-key'. ARGS should consist of key swaps\n(e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"\nwith `evil-collection-translate-minor-mode-key') and optionally keyword\narguments for `evil-collection-translate-minor-mode-key'.\n\n(fn STATES MODES &rest ARGS)" nil t)(function-put 'evil-collection-swap-minor-mode-key 'lisp-indent-function 'defun)(autoload 'evil-collection-require "evil-collection" "Require the evil-collection-MODE file, but do not activate it.\n\nMODE should be a symbol. This requires the evil-collection-MODE\nfeature without needing to manipulate `load-path'. NOERROR is\nforwarded to `require'.\n\n(fn MODE &optional NOERROR)")(autoload 'evil-collection-init "evil-collection" "Register the Evil bindings for all modes in `evil-collection-mode-list'.\n\nAlternatively, you may register select bindings manually, for\ninstance:\n\n  (with-eval-after-load ='calendar\n    (evil-collection-calendar-setup))\n\nIf MODES is specified (as either one mode or a list of modes), use those modes\ninstead of the modes in `evil-collection-mode-list'.\n\n(fn &optional MODES)" t)(autoload 'annalist-record "annalist" "In the store for ANNALIST, TYPE, and LOCAL, record RECORD.\nANNALIST should correspond to the package/user recording this information (e.g.\n'general, 'me, etc.). TYPE is the type of information being recorded (e.g.\n'keybindings). LOCAL corresponds to whether to store RECORD only for the current\nbuffer. This information together is used to select where RECORD should be\nstored in and later retrieved from with `annalist-describe'. RECORD should be a\nlist of items to record and later print as org headings and column entries in a\nsingle row. If PLIST is non-nil, RECORD should be a plist instead of an ordered\nlist (e.g. '(keymap org-mode-map key \"C-c a\" ...)). The plist keys should be\nthe symbols used for the definition of TYPE.\n\n(fn ANNALIST TYPE RECORD &key LOCAL PLIST)")(autoload 'annalist-describe "annalist" "Describe information recorded by ANNALIST for TYPE.\nFor example: (annalist-describe 'general 'keybindings) If VIEW is non-nil, use\nthose settings for displaying recorded information instead of the defaults.\n\n(fn ANNALIST TYPE &optional VIEW)")(autoload 'evil-quick-diff "evil-quick-diff" "Ediff two regions with evil motion." t)(autoload 'evil-quick-diff-cancel "evil-quick-diff-cancel" "Cancel evil-quick-diff and remove selections." t)(autoload 'evil-quick-diff-install "evil-quick-diff" "Setting evil-quick-diff key bindings.")(autoload 'evil-visualstar-mode "evil-visualstar" "Minor mode for visual star selection.\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Visualstar mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-visualstar-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-evil-visualstar-mode 'globalized-minor-mode t)(defvar global-evil-visualstar-mode nil "Non-nil if Global Evil-Visualstar mode is enabled.\nSee the `global-evil-visualstar-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-evil-visualstar-mode'.")(autoload 'global-evil-visualstar-mode "evil-visualstar" "Toggle Evil-Visualstar mode in all buffers.\nWith prefix ARG, enable Global Evil-Visualstar mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nEvil-Visualstar mode is enabled in all buffers where\n`turn-on-evil-visualstar-mode' would do it.\n\nSee `evil-visualstar-mode' for more information on Evil-Visualstar\nmode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-evil-visualstar-mode "evil-visualstar" "Turns on visual star selection." t)(autoload 'turn-off-evil-visualstar-mode "evil-visualstar" "Turns off visual star selection." t)(defvar evil-traces-mode nil "Non-nil if Evil-Traces mode is enabled.\nSee the `evil-traces-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-traces-mode'.")(autoload 'evil-traces-mode "evil-traces" "Global minor mode for evil-traces.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Evil-Traces mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='evil-traces-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-textobj-anyblock-inner-block "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-a-block "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-open-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-open-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-close-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-close-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-open-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-open-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-close-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-close-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-any-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-forward-any-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-any-block-start "evil-textobj-anyblock" nil t)(autoload 'evil-textobj-anyblock-backward-any-block-end "evil-textobj-anyblock" nil t)(autoload 'evil-surround-delete "evil-surround" "Delete the surrounding delimiters represented by CHAR.\nAlternatively, the text to delete can be represented with\nthe overlays OUTER and INNER, where OUTER includes the delimiters\nand INNER excludes them. The intersection (i.e., difference)\nbetween these overlays is what is deleted.\n\n(fn CHAR &optional OUTER INNER)" t)(autoload 'evil-surround-change "evil-surround" "Change the surrounding delimiters represented by CHAR.\nAlternatively, the text to delete can be represented with the\noverlays OUTER and INNER, which are passed to `evil-surround-delete'.\n\n(fn CHAR &optional OUTER INNER)" t)(autoload 'evil-surround-mode "evil-surround" "Buffer-local minor mode to emulate surround.vim.\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Surround mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-surround-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'turn-on-evil-surround-mode "evil-surround" "Enable evil-surround-mode in the current buffer.")(autoload 'turn-off-evil-surround-mode "evil-surround" "Disable evil-surround-mode in the current buffer.")(put 'global-evil-surround-mode 'globalized-minor-mode t)(defvar global-evil-surround-mode nil "Non-nil if Global Evil-Surround mode is enabled.\nSee the `global-evil-surround-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-evil-surround-mode'.")(autoload 'global-evil-surround-mode "evil-surround" "Toggle Evil-Surround mode in all buffers.\nWith prefix ARG, enable Global Evil-Surround mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nEvil-Surround mode is enabled in all buffers where\n`turn-on-evil-surround-mode' would do it.\n\nSee `evil-surround-mode' for more information on Evil-Surround mode.\n\n(fn &optional ARG)" t)(autoload 'evil-snipe-def "evil-snipe" "Define a N char snipe and bind it to FORWARD-KEY and BACKWARD-KEY.\nTYPE can be inclusive or exclusive. Specify FORWARD-FN and/or BACKWARD-FN to\nexplicitly choose the function names.\n\n(fn N TYPE FORWARD-KEY BACKWARD-KEY &key FORWARD-FN BACKWARD-FN)" nil t)(autoload 'evil-snipe-s "evil-snipe" nil t)(autoload 'evil-snipe-S "evil-snipe" nil t)(autoload 'evil-snipe-x "evil-snipe" nil t)(autoload 'evil-snipe-X "evil-snipe" nil t)(autoload 'evil-snipe-f "evil-snipe" nil t)(autoload 'evil-snipe-F "evil-snipe" nil t)(autoload 'evil-snipe-t "evil-snipe" nil t)(autoload 'evil-snipe-T "evil-snipe" nil t)(autoload 'turn-on-evil-snipe-mode "evil-snipe" "Enable evil-snipe-mode in the current buffer.")(autoload 'turn-on-evil-snipe-override-mode "evil-snipe" "Enable evil-snipe-mode in the current buffer.")(autoload 'turn-off-evil-snipe-mode "evil-snipe" "Disable `evil-snipe-local-mode' in the current buffer.")(autoload 'turn-off-evil-snipe-override-mode "evil-snipe" "Disable evil-snipe-override-mode in the current buffer.")(autoload 'evil-snipe-local-mode "evil-snipe" "Enable `evil-snipe' in the current buffer.\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-snipe-Local mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-snipe-local-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-snipe-override-local-mode "evil-snipe" "Override evil-mode's f/F/t/T/;/, motions.\n\nThis is a minor mode.  If called interactively, toggle the\n`Evil-Snipe-Override-Local mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `evil-snipe-override-local-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'evil-snipe-mode 'globalized-minor-mode t)(defvar evil-snipe-mode nil "Non-nil if Evil-Snipe mode is enabled.\nSee the `evil-snipe-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-snipe-mode'.")(autoload 'evil-snipe-mode "evil-snipe" "Toggle Evil-Snipe-Local mode in all buffers.\nWith prefix ARG, enable Evil-Snipe mode if ARG is positive; otherwise,\ndisable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nEvil-Snipe-Local mode is enabled in all buffers where\n`turn-on-evil-snipe-mode' would do it.\n\nSee `evil-snipe-local-mode' for more information on Evil-Snipe-Local\nmode.\n\n(fn &optional ARG)" t)(put 'evil-snipe-override-mode 'globalized-minor-mode t)(defvar evil-snipe-override-mode nil "Non-nil if Evil-Snipe-Override mode is enabled.\nSee the `evil-snipe-override-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-snipe-override-mode'.")(autoload 'evil-snipe-override-mode "evil-snipe" "Toggle Evil-Snipe-Override-Local mode in all buffers.\nWith prefix ARG, enable Evil-Snipe-Override mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nEvil-Snipe-Override-Local mode is enabled in all buffers where\n`turn-on-evil-snipe-override-mode' would do it.\n\nSee `evil-snipe-override-local-mode' for more information on\nEvil-Snipe-Override-Local mode.\n\n(fn &optional ARG)" t)(autoload 'evil-numbers/inc-at-pt "evil-numbers" nil t)(autoload 'evil-numbers/dec-at-pt "evil-numbers" nil t)(autoload 'evil-numbers/inc-at-pt-incremental "evil-numbers" nil t)(autoload 'evil-numbers/dec-at-pt-incremental "evil-numbers" nil t)(autoload 'evilnc-comment-or-uncomment-region-internal "evil-nerd-commenter" "Comment or uncomment region from START to END.\n\n(fn START END)")(autoload 'evilnc-comment-or-uncomment-region "evil-nerd-commenter" "Comment or uncomment region from START to END.\n\n(fn START END)")(autoload 'evilnc-comment-or-uncomment-paragraphs "evil-nerd-commenter" "Comment or uncomment NUM paragraph(s).\nA paragraph is a continuation non-empty lines.\nParagraphs are separated by empty lines.\n\n(fn &optional NUM)" t)(autoload 'evilnc-comment-or-uncomment-to-the-line "evil-nerd-commenter" "Comment or uncomment from current line to LINE-NUM line.\n\n(fn &optional LINE-NUM)" t)(autoload 'evilnc-quick-comment-or-uncomment-to-the-line "evil-nerd-commenter" "Comment/uncomment to line number by LAST-DIGITS.\nFor example, you can use either \\<M-53>\\[evilnc-quick-comment-or-uncomment-to-the-line] or \\<M-3>\\[evilnc-quick-comment-or-uncomment-to-the-line] to comment to the line 6453\n\n(fn &optional LAST-DIGITS)" t)(autoload 'evilnc-toggle-invert-comment-line-by-line "evil-nerd-commenter" "Please note this command may NOT work on complex evil text objects." t)(autoload 'evilnc-toggle-comment-empty-lines "evil-nerd-commenter" "Toggle the flag which decide if empty line will be commented." t)(autoload 'evilnc-comment-or-uncomment-lines "evil-nerd-commenter" "Comment or uncomment NUM lines.  NUM could be negative.\n\nCase 1: If no region selected, comment/uncomment on current line.\nIf NUM>1, comment/uncomment extra N-1 lines from next line.\n\nCase 2: Selected region is expanded to make it contain whole lines.\nThen we comment/uncomment the expanded region.  NUM is ignored.\n\nCase 3: If a region inside of ONE line is selected,\nwe comment/uncomment that region.\nCORRECT comment syntax will be used for C++/Java/Javascript.\n\n(fn &optional NUM)" t)(autoload 'evilnc-copy-and-comment-lines "evil-nerd-commenter" "Copy&paste NUM lines and comment out original lines.\nNUM could be negative.\n\nCase 1: If no region selected, operate on current line.\nif NUM>1, comment/uncomment extra N-1 lines from next line\n\nCase 2: Selected region is expanded to make it contain whole lines.\nThen we operate the expanded region.  NUM is ignored.\n\n(fn &optional NUM)" t)(autoload 'evilnc-comment-and-kill-ring-save "evil-nerd-commenter" "Comment lines save origin lines into `kill-ring'.\nNUM could be negative.\n\nCase 1: If no region selected, operate on current line.\n;; if NUM>1, comment/uncomment extra N-1 lines from next line\n\nCase 2: Selected region is expanded to make it contain whole lines.\nThen we operate the expanded region.  NUM is ignored.\n\n(fn &optional NUM)" t)(autoload 'evilnc-copy-to-line "evil-nerd-commenter" "Copy from current line to LINENUM line.  For non-evil user only.\n\n(fn &optional LINENUM)" t)(autoload 'evilnc-kill-to-line "evil-nerd-commenter" "Kill from the current line to the LINENUM line.  For non-evil user only.\n\n(fn &optional LINENUM)" t)(autoload 'evilnc-version "evil-nerd-commenter" "The version number." t)(autoload 'evilnc-default-hotkeys "evil-nerd-commenter" "Setup the key bindings of evil-nerd-comment.\nIf NO-EVIL-KEYBINDINGS is t, we don't define keybindings in EVIL,\nif NO-EMACS-KEYBINDINGS is t, we don't define keybindings in EMACS mode.\n\n(fn &optional NO-EVIL-KEYBINDINGS NO-EMACS-KEYBINDINGS)" t)(autoload 'evilnc-imenu-create-index-function "evil-nerd-commenter" "Imenu function find comments.")(autoload 'evilnc-comment-or-uncomment-html-tag "evil-nerd-commenter" "Comment or uncomment html tag(s).\nIf no region is selected, current tag under focus is automatically selected.\nIn this case, only one tag is selected.\nIf users manually select region, the region could cross multiple sibling tags\nand automatically expands to include complete tags.\nUsers can press \"v\" key in evil mode to select multiple tags.\nThis command is not dependent on any 3rd party package." t)(autoload 'evilnc-comment-or-uncomment-html-paragraphs "evil-nerd-commenter" "Comment or uncomment NUM paragraphs contain html tag.\nA paragraph is a continuation non-empty lines.\nParagraphs are separated by empty lines.\n\n(fn &optional NUM)" t)(autoload 'evil-lion-left "evil-lion" nil t)(autoload 'evil-lion-right "evil-lion" nil t)(defvar evil-lion-mode nil "Non-nil if Evil-Lion mode is enabled.\nSee the `evil-lion-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-lion-mode'.")(autoload 'evil-lion-mode "evil-lion" "evil-lion global mode, defines align operators 'gl' and 'gL'.\n\n  Align with `gl MOTION CHAR` or right-align with `gL MOTION CHAR`.\n\n  If CHAR is `/` you will be prompted for a regular expression instead\n  of a plain character.\n\n  If CHAR is `RET` alignment will be performed with align.el's rules\n  specific for the current major mode.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Evil-Lion mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='evil-lion-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-indent-plus-i-indent "evil-indent-plus" nil t)(autoload 'evil-indent-plus-a-indent "evil-indent-plus" nil t)(autoload 'evil-indent-plus-i-indent-up "evil-indent-plus" nil t)(autoload 'evil-indent-plus-a-indent-up "evil-indent-plus" nil t)(autoload 'evil-indent-plus-i-indent-up-down "evil-indent-plus" nil t)(autoload 'evil-indent-plus-a-indent-up-down "evil-indent-plus" nil t)(autoload 'evil-indent-plus-default-bindings "evil-indent-plus" "Set the default evil-indent-plus keybindings.")(autoload 'evil-exchange "evil-exchange" "Exchange two regions with evil motion." t)(autoload 'evil-exchange-cancel "evil-exchange" "Cancel current pending exchange." t)(autoload 'evil-exchange-install "evil-exchange" "Setting evil-exchange key bindings.")(autoload 'evil-exchange-cx-install "evil-exchange" "Setting evil-exchange key bindings in a vim-compatible way" t)(defvar evil-escape-mode nil "Non-nil if Evil-Escape mode is enabled.\nSee the `evil-escape-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-escape-mode'.")(autoload 'evil-escape-mode "evil-escape" "Buffer-local minor mode to escape insert state and everything else\n\nwith a key sequence.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Evil-Escape mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='evil-escape-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'evil-embrace-enable-evil-surround-integration "evil-embrace" nil t)(autoload 'evil-embrace-disable-evil-surround-integration "evil-embrace" nil t)(autoload 'embrace-delete "embrace" nil t)(autoload 'embrace-change "embrace" nil t)(autoload 'embrace-add "embrace" nil t)(autoload 'embrace-commander "embrace" nil t)(autoload 'embrace-LaTeX-mode-hook "embrace")(autoload 'embrace-org-mode-hook "embrace")(autoload 'embrace-ruby-mode-hook "embrace")(autoload 'embrace-emacs-lisp-mode-hook "embrace")(autoload 'er/expand-region "expand-region" "Increase selected region by semantic units.\n\nWith prefix argument expands the region that many times.\nIf prefix argument is negative calls `er/contract-region'.\nIf prefix argument is 0 it resets point and mark to their state\nbefore calling `er/expand-region' for the first time.\n\n(fn ARG)" t)(autoload 'er/contract-region "expand-region-core" "Contract the selected region to its previous size.\nWith prefix argument contracts that many times.\nIf prefix argument is negative calls `er/expand-region'.\nIf prefix argument is 0 it resets point and mark to their state\nbefore calling `er/expand-region' for the first time.\n\n(fn ARG)" t)(let ((loads (get 'expand-region 'custom-loads))) (if (member '"expand-region-custom" loads) nil (put 'expand-region 'custom-loads (cons '"expand-region-custom" loads)) (put 'tools 'custom-loads (cons 'expand-region (get 'tools 'custom-loads)))))(defvar expand-region-preferred-python-mode 'python "The name of your preferred python mode")(defvar expand-region-guess-python-mode t "If expand-region should attempt to guess your preferred python mode")(defvar expand-region-autocopy-register "" "If set to a string of a single character (try \"e\"), then the\ncontents of the most recent expand or contract command will\nalways be copied to the register named after that character.")(defvar expand-region-skip-whitespace t "If expand-region should skip past whitespace on initial expansion")(defvar expand-region-fast-keys-enabled t "If expand-region should bind fast keys after initial expand/contract")(defvar expand-region-contract-fast-key "-" "Key to use after an initial expand/contract to contract once more.")(defvar expand-region-reset-fast-key "0" "Key to use after an initial expand/contract to undo.")(defvar expand-region-exclude-text-mode-expansions '(html-mode nxml-mode) "List of modes which derive from `text-mode' for which text mode expansions are not appropriate.")(defvar expand-region-smart-cursor nil "Defines whether the cursor should be placed intelligently after expansion.\n\nIf set to t, and the cursor is already at the beginning of the new region,\nkeep it there; otherwise, put it at the end of the region.\n\nIf set to nil, always place the cursor at the beginning of the region.")(define-obsolete-variable-alias 'er/enable-subword-mode? 'expand-region-subword-enabled "2019-03-23")(defvar expand-region-subword-enabled nil "Whether expand-region should use subword expansions.")(autoload 'evilem--collect "evil-easymotion" "Repeatedly execute func, and collect the cursor positions into a list\n\n(fn FUNC &optional SCOPE ALL-WINDOWS INITIAL-POINT SORT-KEY COLLECT-POSTPROCESS INCLUDE-INVISIBLE)")(autoload 'evilem-motion-forward-word-begin "evil-easymotion" nil t)(autoload 'evilem-motion-forward-WORD-begin "evil-easymotion" nil t)(autoload 'evilem-motion-forward-word-end "evil-easymotion" nil t)(autoload 'evilem-motion-forward-WORD-end "evil-easymotion" nil t)(autoload 'evilem-motion-backward-word-begin "evil-easymotion" nil t)(autoload 'evilem-motion-backward-WORD-begin "evil-easymotion" nil t)(autoload 'evilem-motion-backward-word-end "evil-easymotion" nil t)(autoload 'evilem-motion-backward-WORD-end "evil-easymotion" nil t)(autoload 'evilem-motion-next-line "evil-easymotion" nil t)(autoload 'evilem-motion-previous-line "evil-easymotion" nil t)(autoload 'evilem-motion-next-visual-line "evil-easymotion" nil t)(autoload 'evilem-motion-previous-visual-line "evil-easymotion" nil t)(autoload 'evilem-motion-find-char-to "evil-easymotion" nil t)(autoload 'evilem-motion-find-char-to-backward "evil-easymotion" nil t)(autoload 'evilem-motion-find-char "evil-easymotion" nil t)(autoload 'evilem-motion-find-char-backward "evil-easymotion" nil t)(autoload 'evilem-motion-backward-section-begin "evil-easymotion" nil t)(autoload 'evilem-motion-backward-section-end "evil-easymotion" nil t)(autoload 'evilem-motion-forward-section-begin "evil-easymotion" nil t)(autoload 'evilem-motion-forward-section-end "evil-easymotion" nil t)(autoload 'evilem-motion-backward-sentence-begin "evil-easymotion" nil t)(autoload 'evilem-motion-forward-sentence-begin "evil-easymotion" nil t)(autoload 'evilem-motion-search-next "evil-easymotion" nil t)(autoload 'evilem-motion-search-previous "evil-easymotion" nil t)(autoload 'evilem-motion-search-word-forward "evil-easymotion" nil t)(autoload 'evilem-motion-search-word-backward "evil-easymotion" nil t)(autoload 'evilem-motion-previous-line-first-non-blank "evil-easymotion" nil t)(autoload 'evilem-motion-next-line-first-non-blank "evil-easymotion" nil t)(autoload 'evilem-default-keybindings "evil-easymotion" "Define easymotions for all motions evil defines by default\n\n(fn PREFIX)")(autoload 'evil-backward-arg "evil-args" "Move the cursor backward COUNT arguments.\n\n(fn COUNT)" t)(autoload 'evil-forward-arg "evil-args" "Move the cursor forward COUNT arguments.\n\n(fn COUNT)" t)(autoload 'evil-inner-arg "evil-args")(autoload 'evil-outer-arg "evil-args")(autoload 'evil-jump-out-args "evil-args" "Move the cursor out of the nearest enclosing matching pairs.\n\n(fn COUNT)" t)(autoload 'persp-def-auto-persp "persp-mode" "\n\n(fn NAME &rest KEYARGS &key BUFFER-NAME FILE-NAME MODE MODE-NAME MINOR-MODE MINOR-MODE-NAME PREDICATE HOOKS DYN-ENV GET-NAME GET-BUFFER GET-PERSP SWITCH PARAMETERS NOAUTO WEAK USER-DATA ON-MATCH AFTER-MATCH DONT-PICK-UP-BUFFERS DELETE)")(define-obsolete-function-alias 'def-auto-persp 'persp-def-auto-persp "persp-mode 2.9.6")(autoload 'persp-def-buffer-save/load "persp-mode" "\n\n(fn &rest KEYARGS &key BUFFER-NAME FILE-NAME MODE MODE-NAME MINOR-MODE MINOR-MODE-NAME PREDICATE TAG-SYMBOL SAVE-VARS SAVE-FUNCTION LOAD-FUNCTION AFTER-LOAD-FUNCTION MODE-RESTORE-FUNCTION APPEND)")(define-obsolete-function-alias 'def-persp-buffer-save/load 'persp-def-buffer-save/load "persp-mode 2.9.6")(defvar persp-mode nil "Non-nil if Persp mode is enabled.\nSee the `persp-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `persp-mode'.")(autoload 'persp-mode "persp-mode" "Toggle the persp-mode.\n\nWhen active, keeps track of multiple \\='perspectives\\=',\nnamed collections of buffers and window configurations.\nHere is a keymap of this minor mode:\n\\{persp-mode-map}\n\nThis is a global minor mode.  If called interactively, toggle the\n`Persp mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='persp-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'vi-tilde-fringe-mode "vi-tilde-fringe" "Buffer-local minor mode to display tildes in the fringe when the line is\n\nempty.\n\nThis is a minor mode.  If called interactively, toggle the\n`Vi-Tilde-Fringe mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `vi-tilde-fringe-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-vi-tilde-fringe-mode 'globalized-minor-mode t)(defvar global-vi-tilde-fringe-mode nil "Non-nil if Global Vi-Tilde-Fringe mode is enabled.\nSee the `global-vi-tilde-fringe-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-vi-tilde-fringe-mode'.")(autoload 'global-vi-tilde-fringe-mode "vi-tilde-fringe" "Toggle Vi-Tilde-Fringe mode in all buffers.\nWith prefix ARG, enable Global Vi-Tilde-Fringe mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nVi-Tilde-Fringe mode is enabled in all buffers where\n`vi-tilde-fringe-mode--turn-on' would do it.\n\nSee `vi-tilde-fringe-mode' for more information on Vi-Tilde-Fringe\nmode.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-mode "diff-hl" "Toggle VC diff highlighting.\n\nThis is a minor mode.  If called interactively, toggle the\n`Diff-Hl mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diff-hl-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'turn-on-diff-hl-mode "diff-hl" "Turn on `diff-hl-mode' or `diff-hl-dir-mode' in a buffer if appropriate.")(autoload 'diff-hl--global-turn-on "diff-hl" "Call `turn-on-diff-hl-mode' if the current major mode is applicable.")(autoload 'diff-hl-set-reference-rev "diff-hl" "Set the reference revision globally to REV.\nWhen called interactively, REV read with completion.\n\nThe default value chosen using one of methods below:\n\n- In a log view buffer, it uses the revision of current entry.\nCall `vc-print-log' or `vc-print-root-log' first to open a log\nview buffer.\n- In a VC annotate buffer, it uses the revision of current line.\n- In other situations, it uses the symbol at point.\n\nNotice that this sets the reference revision globally, so in\nfiles from other repositories, `diff-hl-mode' will not highlight\nchanges correctly, until you run `diff-hl-reset-reference-rev'.\n\nAlso notice that this will disable `diff-hl-amend-mode' in\nbuffers that enables it, since `diff-hl-amend-mode' overrides its\neffect.\n\n(fn REV)" t)(autoload 'diff-hl-reset-reference-rev "diff-hl" "Reset the reference revision globally to the most recent one." t)(put 'global-diff-hl-mode 'globalized-minor-mode t)(defvar global-diff-hl-mode nil "Non-nil if Global Diff-Hl mode is enabled.\nSee the `global-diff-hl-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-diff-hl-mode'.")(autoload 'global-diff-hl-mode "diff-hl" "Toggle Diff-Hl mode in all buffers.\nWith prefix ARG, enable Global Diff-Hl mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDiff-Hl mode is enabled in all buffers where `diff-hl--global-turn-on'\nwould do it.\n\nSee `diff-hl-mode' for more information on Diff-Hl mode.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-amend-mode "diff-hl-amend" "Show changes against the second-last revision in `diff-hl-mode'.\n\nMost useful with backends that support rewriting local commits,\nand most importantly, \"amending\" the most recent one.\nCurrently only supports Git, Mercurial and Bazaar.\n\nThis is a minor mode.  If called interactively, toggle the\n`Diff-Hl-Amend mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diff-hl-amend-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-diff-hl-amend-mode 'globalized-minor-mode t)(defvar global-diff-hl-amend-mode nil "Non-nil if Global Diff-Hl-Amend mode is enabled.\nSee the `global-diff-hl-amend-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-diff-hl-amend-mode'.")(autoload 'global-diff-hl-amend-mode "diff-hl-amend" "Toggle Diff-Hl-Amend mode in all buffers.\nWith prefix ARG, enable Global Diff-Hl-Amend mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDiff-Hl-Amend mode is enabled in all buffers where\n`turn-on-diff-hl-amend-mode' would do it.\n\nSee `diff-hl-amend-mode' for more information on Diff-Hl-Amend mode.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-dired-mode "diff-hl-dired" "Toggle VC diff highlighting on the side of a Dired window.\n\nThis is a minor mode.  If called interactively, toggle the\n`Diff-Hl-Dired mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diff-hl-dired-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-dired-mode-unless-remote "diff-hl-dired")(defvar diff-hl-flydiff-mode nil "Non-nil if Diff-Hl-Flydiff mode is enabled.\nSee the `diff-hl-flydiff-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `diff-hl-flydiff-mode'.")(autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" "Perform highlighting on-the-fly.\n\nThis is a global minor mode.  It alters how `diff-hl-mode' works.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Diff-Hl-Flydiff mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='diff-hl-flydiff-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-inline-popup-hide "diff-hl-inline-popup" "Hide the current inline popup." t)(autoload 'diff-hl-inline-popup-show "diff-hl-inline-popup" "Create a phantom overlay to show the inline popup, with some\ncontent LINES, and a HEADER and a FOOTER, at POINT.  KEYMAP is\nadded to the current keymaps.  CLOSE-HOOK is called when the popup\nis closed.\n\n(fn LINES &optional HEADER FOOTER KEYMAP CLOSE-HOOK POINT HEIGHT)")(defvar diff-hl-margin-mode nil "Non-nil if Diff-Hl-Margin mode is enabled.\nSee the `diff-hl-margin-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `diff-hl-margin-mode'.")(autoload 'diff-hl-margin-mode "diff-hl-margin" "Toggle displaying `diff-hl-mode' highlights on the margin.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Diff-Hl-Margin mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='diff-hl-margin-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-margin-local-mode "diff-hl-margin" "Toggle displaying `diff-hl-mode' highlights on the margin locally.\n\nYou probably shouldn't use this function directly.\n\nThis is a minor mode.  If called interactively, toggle the\n`Diff-Hl-Margin-Local mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diff-hl-margin-local-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-show-hunk-inline-popup "diff-hl-show-hunk" "Implementation to show the hunk in a inline popup.\nBUFFER is a buffer with the hunk.\n\n(fn BUFFER &optional IGNORED-LINE)")(autoload 'diff-hl-show-hunk-previous "diff-hl-show-hunk" "Go to previous hunk/change and show it." t)(autoload 'diff-hl-show-hunk-next "diff-hl-show-hunk" "Go to next hunk/change and show it." t)(autoload 'diff-hl-show-hunk "diff-hl-show-hunk" "Show the VC diff hunk at point.\nThe backend is determined by `diff-hl-show-hunk-function'." t)(autoload 'diff-hl-show-hunk-mouse-mode "diff-hl-show-hunk" "Enable margin and fringe to show a posframe/popup with vc diffs when clicked.\n\nBy default, the popup shows only the current hunk, and\nthe line of the hunk that matches the current position is\nhighlighted.  The face, border and other visual preferences are\ncustomizable.  It can be also invoked with the command\n`diff-hl-show-hunk'\n\\{diff-hl-show-hunk-mouse-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`Diff-Hl-Show-Hunk-Mouse mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `diff-hl-show-hunk-mouse-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-diff-hl-show-hunk-mouse-mode 'globalized-minor-mode t)(defvar global-diff-hl-show-hunk-mouse-mode nil "Non-nil if Global Diff-Hl-Show-Hunk-Mouse mode is enabled.\nSee the `global-diff-hl-show-hunk-mouse-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-diff-hl-show-hunk-mouse-mode'.")(autoload 'global-diff-hl-show-hunk-mouse-mode "diff-hl-show-hunk" "Toggle Diff-Hl-Show-Hunk-Mouse mode in all buffers.\nWith prefix ARG, enable Global Diff-Hl-Show-Hunk-Mouse mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDiff-Hl-Show-Hunk-Mouse mode is enabled in all buffers where\n`diff-hl-show-hunk-mouse-mode' would do it.\n\nSee `diff-hl-show-hunk-mouse-mode' for more information on\nDiff-Hl-Show-Hunk-Mouse mode.\n\n(fn &optional ARG)" t)(autoload 'diff-hl-show-hunk-posframe "diff-hl-show-hunk-posframe" "Implementation to show the hunk in a posframe.\n\n(fn BUFFER &optional LINE)")(defvar evil-goggles-mode nil "Non-nil if Evil-Goggles mode is enabled.\nSee the `evil-goggles-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `evil-goggles-mode'.")(autoload 'evil-goggles-mode "evil-goggles" "evil-goggles global minor mode.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Evil-Goggles mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='evil-goggles-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'anzu-mode "anzu" "minor-mode which display search information in mode-line.\n\nThis is a minor mode.  If called interactively, toggle the `Anzu\nmode' mode.  If the prefix argument is positive, enable the mode,\nand if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `anzu-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-anzu-mode 'globalized-minor-mode t)(defvar global-anzu-mode nil "Non-nil if Global Anzu mode is enabled.\nSee the `global-anzu-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-anzu-mode'.")(autoload 'global-anzu-mode "anzu" "Toggle Anzu mode in all buffers.\nWith prefix ARG, enable Global Anzu mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nAnzu mode is enabled in all buffers where `anzu--turn-on' would do\nit.\n\nSee `anzu-mode' for more information on Anzu mode.\n\n(fn &optional ARG)" t)(autoload 'anzu-query-replace-at-cursor "anzu" "Replace symbol at cursor with to-string." t)(autoload 'anzu-query-replace-at-cursor-thing "anzu" "Replace symbol at cursor within `anzu-replace-at-cursor-thing' area." t)(autoload 'anzu-query-replace "anzu" "anzu version of `query-replace'.\n\n(fn ARG)" t)(autoload 'anzu-query-replace-regexp "anzu" "anzu version of `query-replace-regexp'.\n\n(fn ARG)" t)(autoload 'anzu-replace-at-cursor-thing "anzu" "anzu-query-replace-at-cursor-thing without query." t)(autoload 'anzu-isearch-query-replace "anzu" "anzu version of `isearch-query-replace'.\n\n(fn ARG)" t)(autoload 'anzu-isearch-query-replace-regexp "anzu" "anzu version of `isearch-query-replace-regexp'.\n\n(fn ARG)" t)(autoload 'doom-modeline-set-main-modeline "doom-modeline" "Set main mode-line.\nIf DEFAULT is non-nil, set the default mode-line for all buffers.\n\n(fn &optional DEFAULT)")(defvar doom-modeline-mode nil "Non-nil if Doom-Modeline mode is enabled.\nSee the `doom-modeline-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `doom-modeline-mode'.")(autoload 'doom-modeline-mode "doom-modeline" "Toggle `doom-modeline' on or off.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Doom-Modeline mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='doom-modeline-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'doom-modeline-env-setup-python "doom-modeline-env")(autoload 'doom-modeline-env-setup-ruby "doom-modeline-env")(autoload 'doom-modeline-env-setup-perl "doom-modeline-env")(autoload 'doom-modeline-env-setup-go "doom-modeline-env")(autoload 'doom-modeline-env-setup-elixir "doom-modeline-env")(autoload 'doom-modeline-env-setup-rust "doom-modeline-env")(autoload 'nerd-icons-install-fonts "nerd-icons" "Helper function to download and install the latests fonts based on OS.\nThe provided Nerd Font is Symbols Nerd Font Mono.\nWhen PFX is non-nil, ignore the prompt and just install\n\n(fn &optional PFX)" t)(autoload 'nerd-icons-insert "nerd-icons" "Interactive icon insertion function.\nWhen Prefix ARG is non-nil, insert the propertized icon.\nWhen GLYPH-SET is non-nil, limit the candidates to the icon set matching it.\n\n(fn &optional ARG GLYPH-SET)" t)(autoload 'nerd-icons-icon-for-dir "nerd-icons" "Get the formatted icon for DIR.\nARG-OVERRIDES should be a plist containining `:height',\n`:v-adjust' or `:face' properties like in the normal icon\ninserting functions.\n\n(fn DIR &rest ARG-OVERRIDES)")(autoload 'nerd-icons-icon-for-file "nerd-icons" "Get the formatted icon for FILE.\nARG-OVERRIDES should be a plist containining `:height',\n`:v-adjust' or `:face' properties like in the normal icon\ninserting functions.\n\n(fn FILE &rest ARG-OVERRIDES)")(autoload 'nerd-icons-icon-for-extension "nerd-icons" "Get the formatted icon for EXT.\nARG-OVERRIDES should be a plist containining `:height',\n`:v-adjust' or `:face' properties like in the normal icon\ninserting functions.\n\n(fn EXT &rest ARG-OVERRIDES)")(autoload 'nerd-icons-icon-for-mode "nerd-icons" "Get the formatted icon for MODE.\nARG-OVERRIDES should be a plist containining `:height',\n`:v-adjust' or `:face' properties like in the normal icon\ninserting functions.\n\n(fn MODE &rest ARG-OVERRIDES)")(autoload 'nerd-icons-icon-for-url "nerd-icons" "Get the formatted icon for URL.\nIf an icon for URL isn't found in `nerd-icons-url-alist', a globe is used.\nARG-OVERRIDES should be a plist containining `:height',\n`:v-adjust' or `:face' properties like in the normal icon\ninserting functions.\n\n(fn URL &rest ARG-OVERRIDES)")(autoload 'nerd-icons-icon-for-buffer "nerd-icons" "Get the formatted icon for the current buffer.\n\nThis function prioritises the use of the buffers file extension to\ndiscern the icon when its `major-mode' matches its auto mode,\notherwise it will use the buffers `major-mode' to decide its\nicon.")(autoload 'hl-todo-mode "hl-todo" "Highlight TODO and similar keywords in comments and strings.\n\nThis is a minor mode.  If called interactively, toggle the\n`Hl-Todo mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `hl-todo-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-hl-todo-mode 'globalized-minor-mode t)(defvar global-hl-todo-mode nil "Non-nil if Global Hl-Todo mode is enabled.\nSee the `global-hl-todo-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-hl-todo-mode'.")(autoload 'global-hl-todo-mode "hl-todo" "Toggle Hl-Todo mode in all buffers.\nWith prefix ARG, enable Global Hl-Todo mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nHl-Todo mode is enabled in all buffers where\n`hl-todo--turn-on-mode-if-desired' would do it.\n\nSee `hl-todo-mode' for more information on Hl-Todo mode.\n\n(fn &optional ARG)" t)(autoload 'hl-todo-next "hl-todo" "Jump to the next TODO or similar keyword.\nThe prefix argument ARG specifies how many keywords to move.\nA negative argument means move backward that many keywords.\n\n(fn ARG)" t)(autoload 'hl-todo-previous "hl-todo" "Jump to the previous TODO or similar keyword.\nThe prefix argument ARG specifies how many keywords to move.\nA negative argument means move forward that many keywords.\n\n(fn ARG)" t)(autoload 'hl-todo-occur "hl-todo" "Use `occur' to find all TODO or similar keywords.\nThis actually finds a superset of the highlighted keywords,\nbecause it uses a regexp instead of a more sophisticated\nmatcher.  It also finds occurrences that are not within a\nstring or comment." t)(autoload 'hl-todo-rgrep "hl-todo" "Use `rgrep' to find all TODO or similar keywords.\nThis actually finds a superset of the highlighted keywords,\nbecause it uses a regexp instead of a more sophisticated\nmatcher.  It also finds occurrences that are not within a\nstring or comment.  See `rgrep' for the meaning of REGEXP,\nFILES, DIR and CONFIRM, except that the type of prefix\nargument does not matter; with any prefix you can edit the\nconstructed shell command line before it is executed.\nAlso see option `hl-todo-keyword-faces'.\n\n(fn REGEXP &optional FILES DIR CONFIRM)" t)(autoload 'hl-todo-flymake "hl-todo" "Flymake backend for `hl-todo-mode'.\nDiagnostics are reported to REPORT-FN.  Use `add-hook' to\nregister this function in `flymake-diagnostic-functions' before\nenabling `flymake-mode'.\n\n(fn REPORT-FN &rest PLIST)")(autoload 'hl-todo-insert "hl-todo" "Read a TODO or similar keyword and insert it at point.\n\nIf point is not inside a string or comment, then insert a new\ncomment.  If point is at the end of the line, then insert the\ncomment there, otherwise insert it as a new line before the\ncurrent line.  When called interactively the KEYWORD is read\nvia `completing-read'.\n\nIf `hl-todo-require-punctuation' is non-nil and\n`hl-todo-highlight-punctuation' contains a single character,\nthen append that character to the inserted string.\n\n(fn KEYWORD)" t)(defface solaire-default-face '((t :inherit default)) "Alternative version of the `default' face." :group 'solaire-mode)(autoload 'solaire-mode "solaire-mode" "Make current buffer a different color so others can be grossly incandescent.\n\nRemaps faces in `solaire-mode-remap-alist', then runs `solaire-mode-hook', where\nadditional mode-specific fixes may live. Lastly, adjusts the fringes for the\ncurrent frame.\n\nThis is a minor mode.  If called interactively, toggle the\n`Solaire mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `solaire-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'solaire-global-mode 'globalized-minor-mode t)(defvar solaire-global-mode nil "Non-nil if Solaire-Global mode is enabled.\nSee the `solaire-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `solaire-global-mode'.")(autoload 'solaire-global-mode "solaire-mode" "Toggle Solaire mode in all buffers.\nWith prefix ARG, enable Solaire-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nSolaire mode is enabled in all buffers where `turn-on-solaire-mode'\nwould do it.\n\nSee `solaire-mode' for more information on Solaire mode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-solaire-mode "solaire-mode" "Conditionally enable `solaire-mode' in the current buffer.\n\nDoes nothing if the current buffer doesn't satisfy the function in\n`solaire-mode-real-buffer-fn'.\n\n(fn &rest _)" t)(autoload 'turn-off-solaire-mode "solaire-mode" "Disable `solaire-mode' in the current buffer.\n\n(fn &rest _)" t)(autoload 'solaire-mode-reset "solaire-mode" "Reset `solaire-mode' in all buffers where it is enabled.\n\nUse this in case solaire-mode has caused some sort of problem, e.g. after\nchanging themes.  are more prelevant in Emacs 25 and 26, but far less so in 27+;\nparticularly where the fringe is concerned.\n\n(fn &rest _)" t)(autoload 'solaire-mode-reset-buffer "solaire-mode" "Reset `solaire-mode' incurrent buffer.\n\nSee `solaire-mode-reset' for details.")(defun solaire-mode--prepare-for-theme-a (theme &rest _) "Prepare solaire-mode for THEME.\nMeant to be used as a `load-theme' advice." (when (and (get theme 'theme-feature) (memq theme custom-enabled-themes)) (setq solaire-mode--supported-p (cl-loop for spec in (get theme 'theme-settings) if (eq (nth 1 spec) 'solaire-default-face) return t) solaire-mode--swapped-p nil solaire-mode--theme theme) (when (bound-and-true-p solaire-global-mode) (if solaire-mode--supported-p (solaire-mode-swap-faces-maybe) (solaire-global-mode -1)))))(advice-add #'load-theme :after #'solaire-mode--prepare-for-theme-a)(autoload 'doom-name-to-rgb "doom-themes" "Retrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")\nfor FRAME (defaults to the current frame).\n\n(fn COLOR)")(autoload 'doom-blend "doom-themes" "Blend two colors (hexidecimal strings) together by a coefficient ALPHA (a\nfloat between 0 and 1)\n\n(fn COLOR1 COLOR2 ALPHA)")(autoload 'doom-darken "doom-themes" "Darken a COLOR (a hexidecimal string) by a coefficient ALPHA (a float between\n0 and 1).\n\n(fn COLOR ALPHA)")(autoload 'doom-lighten "doom-themes" "Brighten a COLOR (a hexidecimal string) by a coefficient ALPHA (a float\nbetween 0 and 1).\n\n(fn COLOR ALPHA)")(autoload 'doom-color "doom-themes" "Retrieve a specific color named NAME (a symbol) from the current theme.\n\n(fn NAME &optional TYPE)")(autoload 'doom-ref "doom-themes" "TODO\n\n(fn FACE PROP &optional CLASS)")(autoload 'doom-themes-set-faces "doom-themes" "Customize THEME (a symbol) with FACES.\n\nIf THEME is nil, it applies to all themes you load. FACES is a list of Doom\ntheme face specs. These is a simplified spec. For example:\n\n  (doom-themes-set-faces \\='user\n    \\='(default :background red :foreground blue)\n    \\='(doom-modeline-bar :background (if -modeline-bright modeline-bg highlight))\n    \\='(doom-modeline-buffer-file :inherit \\='mode-line-buffer-id :weight \\='bold)\n    \\='(doom-modeline-buffer-path :inherit \\='mode-line-emphasis :weight \\='bold)\n    \\='(doom-modeline-buffer-project-root :foreground green :weight \\='bold))\n\n(fn THEME &rest FACES)")(function-put 'doom-themes-set-faces 'lisp-indent-function 'defun)(when (and (boundp 'custom-theme-load-path) "~/.config/emacs/.local/straight/build-29.3/doom-themes/doom-themes-autoloads.el") (let* ((base (file-name-directory "~/.config/emacs/.local/straight/build-29.3/doom-themes/doom-themes-autoloads.el")) (dir (expand-file-name "themes/" base))) (add-to-list 'custom-theme-load-path (or (and (file-directory-p dir) dir) base))))(autoload 'doom-themes-neotree-config "doom-themes-ext-neotree" "Install doom-themes' neotree configuration.\n\nIncludes an Atom-esque icon theme and highlighting based on filetype.")(autoload 'doom-themes-org-config "doom-themes-ext-org" "Load `doom-themes-ext-org'.")(autoload 'doom-themes-treemacs-config "doom-themes-ext-treemacs" "Install doom-themes' treemacs configuration.\n\nIncludes an Atom-esque icon theme and highlighting based on filetype.")(autoload 'doom-themes-visual-bell-fn "doom-themes-ext-visual-bell" "Blink the mode-line red briefly. Set `ring-bell-function' to this to use it.")(autoload 'doom-themes-visual-bell-config "doom-themes-ext-visual-bell" "Enable flashing the mode-line on error.")(autoload 'consult-yasnippet-visit-snippet-file "consult-yasnippet" "Visit the snippet file associated with TEMPLATE.\nWhen called interactively this command previews snippet completions in\nthe current buffer, and then opens the selected snippets template file\nusing `yas--visit-snippet-file-1'.\n\n(fn TEMPLATE)" t)(autoload 'consult-yasnippet "consult-yasnippet" "Interactively select and expand a yasnippet template.\nThis command presents a completing read interface containing all currently\navailable snippet expansions, with live previews for each snippet. Once\nselected a chosen snippet will be expanded at point using\n`yas-expand-snippet'.\n\nWith ARG select snippets from all snippet tables, not just the current one.\n\n(fn ARG)" t)(autoload 'consult-completion-in-region "consult" "Use minibuffer completion as the UI for `completion-at-point'.\n\nThe function is called with 4 arguments: START END COLLECTION\nPREDICATE.  The arguments and expected return value are as\nspecified for `completion-in-region'.  Use this function as a\nvalue for `completion-in-region-function'.\n\n(fn START END COLLECTION &optional PREDICATE)")(autoload 'consult-outline "consult" "Jump to an outline heading, obtained by matching against `outline-regexp'.\n\nThis command supports narrowing to a heading level and candidate\npreview.  The initial narrowing LEVEL can be given as prefix\nargument.  The symbol at point is added to the future history.\n\n(fn &optional LEVEL)" t)(autoload 'consult-mark "consult" "Jump to a marker in MARKERS list (defaults to buffer-local `mark-ring').\n\nThe command supports preview of the currently selected marker position.\nThe symbol at point is added to the future history.\n\n(fn &optional MARKERS)" t)(autoload 'consult-global-mark "consult" "Jump to a marker in MARKERS list (defaults to `global-mark-ring').\n\nThe command supports preview of the currently selected marker position.\nThe symbol at point is added to the future history.\n\n(fn &optional MARKERS)" t)(autoload 'consult-line "consult" "Search for a matching line.\n\nDepending on the setting `consult-point-placement' the command\njumps to the beginning or the end of the first match on the line\nor the line beginning.  The default candidate is the non-empty\nline next to point.  This command obeys narrowing.  Optional\nINITIAL input can be provided.  The search starting point is\nchanged if the START prefix argument is set.  The symbol at point\nand the last `isearch-string' is added to the future history.\n\n(fn &optional INITIAL START)" t)(autoload 'consult-line-multi "consult" "Search for a matching line in multiple buffers.\n\nBy default search across all project buffers.  If the prefix\nargument QUERY is non-nil, all buffers are searched.  Optional\nINITIAL input can be provided.  The symbol at point and the last\n`isearch-string' is added to the future history.  In order to\nsearch a subset of buffers, QUERY can be set to a plist according\nto `consult--buffer-query'.\n\n(fn QUERY &optional INITIAL)" t)(autoload 'consult-keep-lines "consult" "Select a subset of the lines in the current buffer with live preview.\n\nThe selected lines are kept and the other lines are deleted.  When called\ninteractively, the lines selected are those that match the minibuffer input.  In\norder to match the inverse of the input, prefix the input with `! '.  When\ncalled from Elisp, the filtering is performed by a FILTER function.  This\ncommand obeys narrowing.\n\nFILTER is the filter function.\nINITIAL is the initial input.\n\n(fn FILTER &optional INITIAL)" t)(autoload 'consult-focus-lines "consult" "Hide or show lines using overlays.\n\nThe selected lines are shown and the other lines hidden.  When called\ninteractively, the lines selected are those that match the minibuffer input.  In\norder to match the inverse of the input, prefix the input with `! '.  With\noptional prefix argument SHOW reveal the hidden lines.  Alternatively the\ncommand can be restarted to reveal the lines.  When called from Elisp, the\nfiltering is performed by a FILTER function.  This command obeys narrowing.\n\nFILTER is the filter function.\nINITIAL is the initial input.\n\n(fn FILTER &optional SHOW INITIAL)" t)(autoload 'consult-goto-line "consult" "Read line number and jump to the line with preview.\n\nEnter either a line number to jump to the first column of the\ngiven line or line:column in order to jump to a specific column.\nJump directly if a line number is given as prefix ARG.  The\ncommand respects narrowing and the settings\n`consult-goto-line-numbers' and `consult-line-numbers-widen'.\n\n(fn &optional ARG)" t)(autoload 'consult-recent-file "consult" "Find recent file using `completing-read'." t)(autoload 'consult-mode-command "consult" "Run a command from any of the given MODES.\n\nIf no MODES are specified, use currently active major and minor modes.\n\n(fn &rest MODES)" t)(autoload 'consult-yank-from-kill-ring "consult" "Select STRING from the kill ring and insert it.\nWith prefix ARG, put point at beginning, and mark at end, like `yank' does.\n\nThis command behaves like `yank-from-kill-ring' in Emacs 28, which also offers\na `completing-read' interface to the `kill-ring'.  Additionally the Consult\nversion supports preview of the selected string.\n\n(fn STRING &optional ARG)" t)(autoload 'consult-yank-pop "consult" "If there is a recent yank act like `yank-pop'.\n\nOtherwise select string from the kill ring and insert it.\nSee `yank-pop' for the meaning of ARG.\n\nThis command behaves like `yank-pop' in Emacs 28, which also offers a\n`completing-read' interface to the `kill-ring'.  Additionally the Consult\nversion supports preview of the selected string.\n\n(fn &optional ARG)" t)(autoload 'consult-yank-replace "consult" "Select STRING from the kill ring.\n\nIf there was no recent yank, insert the string.\nOtherwise replace the just-yanked string with the selected string.\n\nThere exists no equivalent of this command in Emacs 28.\n\n(fn STRING)" t)(autoload 'consult-bookmark "consult" "If bookmark NAME exists, open it, otherwise create a new bookmark with NAME.\n\nThe command supports preview of file bookmarks and narrowing.  See the\nvariable `consult-bookmark-narrow' for the narrowing configuration.\n\n(fn NAME)" t)(autoload 'consult-complex-command "consult" "Select and evaluate command from the command history.\n\nThis command can act as a drop-in replacement for `repeat-complex-command'." t)(autoload 'consult-history "consult" "Insert string from HISTORY of current buffer.\nIn order to select from a specific HISTORY, pass the history\nvariable as argument.  INDEX is the name of the index variable to\nupdate, if any.  BOL is the function which jumps to the beginning\nof the prompt.  See also `cape-history' from the Cape package.\n\n(fn &optional HISTORY INDEX BOL)" t)(autoload 'consult-isearch-history "consult" "Read a search string with completion from the Isearch history.\n\nThis replaces the current search string if Isearch is active, and\nstarts a new Isearch session otherwise." t)(autoload 'consult-minor-mode-menu "consult" "Enable or disable minor mode.\n\nThis is an alternative to `minor-mode-menu-from-indicator'." t)(autoload 'consult-theme "consult" "Disable current themes and enable THEME from `consult-themes'.\n\nThe command supports previewing the currently selected theme.\n\n(fn THEME)" t)(autoload 'consult-buffer "consult" "Enhanced `switch-to-buffer' command with support for virtual buffers.\n\nThe command supports recent files, bookmarks, views and project files as\nvirtual buffers.  Buffers are previewed.  Narrowing to buffers (b), files (f),\nbookmarks (m) and project files (p) is supported via the corresponding\nkeys.  In order to determine the project-specific files and buffers, the\n`consult-project-function' is used.  The virtual buffer SOURCES\ndefault to `consult-buffer-sources'.  See `consult--multi' for the\nconfiguration of the virtual buffer sources.\n\n(fn &optional SOURCES)" t)(autoload 'consult-project-buffer "consult" "Enhanced `project-switch-to-buffer' command with support for virtual buffers.\nThe command may prompt you for a project directory if it is invoked from\noutside a project.  See `consult-buffer' for more details." t)(autoload 'consult-buffer-other-window "consult" "Variant of `consult-buffer', switching to a buffer in another window." t)(autoload 'consult-buffer-other-frame "consult" "Variant of `consult-buffer', switching to a buffer in another frame." t)(autoload 'consult-buffer-other-tab "consult" "Variant of `consult-buffer', switching to a buffer in another tab." t)(autoload 'consult-grep "consult" "Search with `grep' for files in DIR where the content matches a regexp.\n\nThe initial input is given by the INITIAL argument.  DIR can be nil, a\ndirectory string or a list of file/directory paths.  If `consult-grep'\nis called interactively with a prefix argument, the user can specify the\ndirectories or files to search in.  Multiple directories or files must\nbe separated by comma in the minibuffer, since they are read via\n`completing-read-multiple'.  By default the project directory is used if\n`consult-project-function' is defined and returns non-nil.  Otherwise\nthe `default-directory' is searched.  If the command is invoked with a\ndouble prefix argument (twice `C-u') the user is asked for a project, if\nnot yet inside a project, or the current project is searched.\n\nThe input string is split, the first part of the string (grep input) is\npassed to the asynchronous grep process and the second part of the\nstring is passed to the completion-style filtering.\n\nThe input string is split at a punctuation character, which is given as\nthe first character of the input string.  The format is similar to\nPerl-style regular expressions, e.g., /regexp/.  Furthermore command\nline options can be passed to grep, specified behind --.  The overall\nprompt input has the form `#async-input -- grep-opts#filter-string'.\n\nNote that the grep input string is transformed from Emacs regular\nexpressions to Posix regular expressions.  Always enter Emacs regular\nexpressions at the prompt.  `consult-grep' behaves like builtin Emacs\nsearch commands, e.g., Isearch, which take Emacs regular expressions.\nFurthermore the asynchronous input split into words, each word must\nmatch separately and in any order.  See `consult--regexp-compiler' for\nthe inner workings.  In order to disable transformations of the grep\ninput, adjust `consult--regexp-compiler' accordingly.\n\nHere we give a few example inputs:\n\n#alpha beta         : Search for alpha and beta in any order.\n#alpha.*beta        : Search for alpha before beta.\n#\\(alpha\\|beta\\) : Search for alpha or beta (Note Emacs syntax!)\n#word -- -C3        : Search for word, include 3 lines as context\n#first#second       : Search for first, quick filter for second.\n\nThe symbol at point is added to the future history.\n\n(fn &optional DIR INITIAL)" t)(autoload 'consult-git-grep "consult" "Search with `git grep' for files in DIR with INITIAL input.\nSee `consult-grep' for details.\n\n(fn &optional DIR INITIAL)" t)(autoload 'consult-ripgrep "consult" "Search with `rg' for files in DIR with INITIAL input.\nSee `consult-grep' for details.\n\n(fn &optional DIR INITIAL)" t)(autoload 'consult-find "consult" "Search for files with `find' in DIR.\nThe file names must match the input regexp.  INITIAL is the\ninitial minibuffer input.  See `consult-grep' for details\nregarding the asynchronous search and the arguments.\n\n(fn &optional DIR INITIAL)" t)(autoload 'consult-fd "consult" "Search for files with `fd' in DIR.\nThe file names must match the input regexp.  INITIAL is the\ninitial minibuffer input.  See `consult-grep' for details\nregarding the asynchronous search and the arguments.\n\n(fn &optional DIR INITIAL)" t)(autoload 'consult-locate "consult" "Search with `locate' for files which match input given INITIAL input.\n\nThe input is treated literally such that locate can take advantage of\nthe locate database index.  Regular expressions would often force a slow\nlinear search through the entire database.  The locate process is started\nasynchronously, similar to `consult-grep'.  See `consult-grep' for more\ndetails regarding the asynchronous search.\n\n(fn &optional INITIAL)" t)(autoload 'consult-man "consult" "Search for man page given INITIAL input.\n\nThe input string is not preprocessed and passed literally to the\nunderlying man commands.  The man process is started asynchronously,\nsimilar to `consult-grep'.  See `consult-grep' for more details regarding\nthe asynchronous search.\n\n(fn &optional INITIAL)" t)(autoload 'consult-compile-error "consult-compile" "Jump to a compilation error in the current buffer.\n\nThis command collects entries from compilation buffers and grep\nbuffers related to the current buffer.  The command supports\npreview of the currently selected error." t)(autoload 'consult-flymake "consult-flymake" "Jump to Flymake diagnostic.\nWhen PROJECT is non-nil then prompt with diagnostics from all\nbuffers in the current project instead of just the current buffer.\n\n(fn &optional PROJECT)" t)(autoload 'consult-imenu "consult-imenu" "Select item from flattened `imenu' using `completing-read' with preview.\n\nThe command supports preview and narrowing.  See the variable\n`consult-imenu-config', which configures the narrowing.\nThe symbol at point is added to the future history.\n\nSee also `consult-imenu-multi'." t)(autoload 'consult-imenu-multi "consult-imenu" "Select item from the imenus of all buffers from the same project.\n\nIn order to determine the buffers belonging to the same project, the\n`consult-project-function' is used.  Only the buffers with the\nsame major mode as the current buffer are used.  See also\n`consult-imenu' for more details.  In order to search a subset of buffers,\nQUERY can be set to a plist according to `consult--buffer-query'.\n\n(fn &optional QUERY)" t)(autoload 'consult-info "consult-info" "Full text search through info MANUALS.\n\n(fn &rest MANUALS)" t)(autoload 'consult-kmacro "consult-kmacro" "Run a chosen keyboard macro.\n\nWith prefix ARG, run the macro that many times.\nMacros containing mouse clicks are omitted.\n\n(fn ARG)" t)(autoload 'consult-org-heading "consult-org" "Jump to an Org heading.\n\nMATCH and SCOPE are as in `org-map-entries' and determine which\nentries are offered.  By default, all entries of the current\nbuffer are offered.\n\n(fn &optional MATCH SCOPE)" t)(autoload 'consult-org-agenda "consult-org" "Jump to an Org agenda heading.\n\nBy default, all agenda entries are offered.  MATCH is as in\n`org-map-entries' and can used to refine this.\n\n(fn &optional MATCH)" t)(autoload 'consult-register-window "consult-register" "Enhanced drop-in replacement for `register-preview'.\n\nBUFFER is the window buffer.\nSHOW-EMPTY must be t if the window should be shown for an empty register list.\n\n(fn BUFFER &optional SHOW-EMPTY)")(autoload 'consult-register-format "consult-register" "Enhanced preview of register REG.\nThis function can be used as `register-preview-function'.\nIf COMPLETION is non-nil format the register for completion.\n\n(fn REG &optional COMPLETION)")(autoload 'consult-register "consult-register" "Load register and either jump to location or insert the stored text.\n\nThis command is useful to search the register contents.  For quick access\nto registers it is still recommended to use the register functions\n`consult-register-load' and `consult-register-store' or the built-in\nbuilt-in register access functions.  The command supports narrowing, see\n`consult-register--narrow'.  Marker positions are previewed.  See\n`jump-to-register' and `insert-register' for the meaning of prefix ARG.\n\n(fn &optional ARG)" t)(autoload 'consult-register-load "consult-register" "Do what I mean with a REG.\n\nFor a window configuration, restore it.  For a number or text, insert it.\nFor a location, jump to it.  See `jump-to-register' and `insert-register'\nfor the meaning of prefix ARG.\n\n(fn REG &optional ARG)" t)(autoload 'consult-register-store "consult-register" "Store register dependent on current context, showing an action menu.\n\nWith an active region, store/append/prepend the contents, optionally\ndeleting the region when a prefix ARG is given.  With a numeric prefix\nARG, store or add the number.  Otherwise store point, frameset, window or\nkmacro.\n\n(fn ARG)" t)(autoload 'consult-xref "consult-xref" "Show xrefs with preview in the minibuffer.\n\nThis function can be used for `xref-show-xrefs-function'.\nSee `xref-show-xrefs-function' for the description of the\nFETCHER and ALIST arguments.\n\n(fn FETCHER &optional ALIST)")(autoload 'wgrep-setup "wgrep" "Setup wgrep preparation.")(add-hook 'grep-setup-hook 'wgrep-setup)(defvar marginalia-mode nil "Non-nil if Marginalia mode is enabled.\nSee the `marginalia-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `marginalia-mode'.")(autoload 'marginalia-mode "marginalia" "Annotate completion candidates with richer information.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Marginalia mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='marginalia-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'marginalia-cycle "marginalia" "Cycle between annotators in `marginalia-annotator-registry'." t)(defun embark--record-this-command nil "Record command which opened the minibuffer.\nWe record this because it will be the default action.\nThis function is meant to be added to `minibuffer-setup-hook'." (setq-local embark--command this-command))(add-hook 'minibuffer-setup-hook #'embark--record-this-command)(autoload 'embark-eldoc-first-target "embark" "Eldoc function reporting the first Embark target at point.\nThis function uses the eldoc REPORT callback and is meant to be\nadded to `eldoc-documentation-functions'.\n\n(fn REPORT &rest _)")(autoload 'embark-eldoc-target-types "embark" "Eldoc function reporting the types of all Embark targets at point.\nThis function uses the eldoc REPORT callback and is meant to be\nadded to `eldoc-documentation-functions'.\n\n(fn REPORT &rest _)")(autoload 'embark-bindings-in-keymap "embark" "Explore command key bindings in KEYMAP with `completing-read'.\nThe selected command will be executed.  Interactively, prompt the\nuser for a KEYMAP variable.\n\n(fn KEYMAP)" t)(autoload 'embark-bindings "embark" "Explore current command key bindings with `completing-read'.\nThe selected command will be executed.\n\nThis shows key bindings from minor mode maps and the local\nmap (usually set by the major mode), but also less common keymaps\nsuch as those from a text property or overlay, or the overriding\nmaps: `overriding-terminal-local-map' and `overriding-local-map'.\n\nAdditionally, if GLOBAL is non-nil (interactively, if called with\na prefix argument), this command includes global key bindings.\n\n(fn GLOBAL)" t)(autoload 'embark-bindings-at-point "embark" "Explore all key bindings at point with `completing-read'.\nThe selected command will be executed.\n\nThis command lists key bindings found in keymaps specified by the\ntext properties `keymap' or `local-map', from either buffer text\nor an overlay.  These are not widely used in Emacs, and when they\nare used can be somewhat hard to discover.  Examples of locations\nthat have such a keymap are links and images in `eww' buffers,\nattachment links in `gnus' article buffers, and the stash line\nin a `vc-dir' buffer." t)(autoload 'embark-prefix-help-command "embark" "Prompt for and run a command bound in the prefix used for this command.\nThe prefix described consists of all but the last event of the\nkey sequence that ran this command.  This function is intended to\nbe used as a value for `prefix-help-command'.\n\nIn addition to using completion to select a command, you can also\ntype @ and the key binding (without the prefix)." t)(autoload 'embark-act "embark" "Prompt the user for an action and perform it.\nThe targets of the action are chosen by `embark-target-finders'.\nBy default, if called from a minibuffer the target is the top\ncompletion candidate.  When called from a non-minibuffer buffer\nthere can multiple targets and you can cycle among them by using\n`embark-cycle' (which is bound by default to the same key\nbinding `embark-act' is, but see `embark-cycle-key').\n\nThis command uses `embark-prompter' to ask the user to specify an\naction, and calls it injecting the target at the first minibuffer\nprompt.\n\nIf you call this from the minibuffer, it can optionally quit the\nminibuffer.  The variable `embark-quit-after-action' controls\nwhether calling `embark-act' with nil ARG quits the minibuffer,\nand if ARG is non-nil it will do the opposite.  Interactively,\nARG is the prefix argument.\n\nIf instead you call this from outside the minibuffer, the first\nARG targets are skipped over (if ARG is negative the skipping is\ndone by cycling backwards) and cycling starts from the following\ntarget.\n\n(fn &optional ARG)" t)(autoload 'embark-act-all "embark" "Prompt the user for an action and perform it on each candidate.\nThe candidates are chosen by `embark-candidate-collectors'.  By\ndefault, if `embark-select' has been used to select some\ncandidates, then `embark-act-all' will act on those candidates;\notherwise, if the selection is empty and `embark-act-all' is\ncalled from a minibuffer, then the candidates are the completion\ncandidates.\n\nThis command uses `embark-prompter' to ask the user to specify an\naction, and calls it injecting the target at the first minibuffer\nprompt.\n\nIf you call this from the minibuffer, it can optionally quit the\nminibuffer.  The variable `embark-quit-after-action' controls\nwhether calling `embark-act' with nil ARG quits the minibuffer,\nand if ARG is non-nil it will do the opposite.  Interactively,\nARG is the prefix argument.\n\n(fn &optional ARG)" t)(autoload 'embark-dwim "embark" "Run the default action on the current target.\nThe target of the action is chosen by `embark-target-finders'.\n\nIf the target comes from minibuffer completion, then the default\naction is the command that opened the minibuffer in the first\nplace, unless overridden by `embark-default-action-overrides'.\n\nFor targets that do not come from minibuffer completion\n(typically some thing at point in a regular buffer) and whose\ntype is not listed in `embark-default-action-overrides', the\ndefault action is given by whatever binding RET has in the action\nkeymap for the target's type.\n\nSee `embark-act' for the meaning of the prefix ARG.\n\n(fn &optional ARG)" t)(autoload 'embark-become "embark" "Make current command become a different command.\nTake the current minibuffer input as initial input for new\ncommand.  The new command can be run normally using key bindings or\n\\[execute-extended-command], but if the current command is found in a keymap in\n`embark-become-keymaps', that keymap is activated to provide\nconvenient access to the other commands in it.\n\nIf FULL is non-nil (interactively, if called with a prefix\nargument), the entire minibuffer contents are used as the initial\ninput of the new command.  By default only the part of the\nminibuffer contents between the current completion boundaries is\ntaken.  What this means is fairly technical, but (1) usually\nthere is no difference: the completion boundaries include the\nentire minibuffer contents, and (2) the most common case where\nthese notions differ is file completion, in which case the\ncompletion boundaries single out the path component containing\npoint.\n\n(fn &optional FULL)" t)(autoload 'embark-collect "embark" "Create an Embark Collect buffer.\n\nTo control the display, add an entry to `display-buffer-alist'\nwith key \"Embark Collect\".\n\nIn Embark Collect buffers `revert-buffer' is remapped to\n`embark-rerun-collect-or-export', which has slightly unusual\nbehavior if the buffer was obtained by running `embark-collect'\nfrom within a minibuffer completion session.  In that case\nrerunning just restarts the completion session, that is, the\ncommand that opened the minibuffer is run again and the\nminibuffer contents restored.  You can then interact normally with\nthe command, perhaps editing the minibuffer contents, and, if you\nwish, you can rerun `embark-collect' to get an updated buffer." t)(autoload 'embark-live "embark" "Create a live-updating Embark Collect buffer.\n\nTo control the display, add an entry to `display-buffer-alist'\nwith key \"Embark Live\"." t)(autoload 'embark-export "embark" "Create a type-specific buffer to manage current candidates.\nThe variable `embark-exporters-alist' controls how to make the\nbuffer for each type of completion.\n\nIn Embark Export buffers `revert-buffer' is remapped to\n`embark-rerun-collect-or-export', which has slightly unusual\nbehavior if the buffer was obtained by running `embark-export'\nfrom within a minibuffer completion session.  In that case\nreverting just restarts the completion session, that is, the\ncommand that opened the minibuffer is run again and the\nminibuffer contents restored.  You can then interact normally\nwith the command, perhaps editing the minibuffer contents, and,\nif you wish, you can rerun `embark-export' to get an updated\nbuffer." t)(autoload 'embark-select "embark" "Add or remove the target from the current buffer's selection.\nYou can act on all selected targets at once with `embark-act-all'.\nWhen called from outside `embark-act' this command will select\nthe first target at point." t)(autoload 'consult-flycheck "consult-flycheck" "Jump to flycheck error." t)(autoload 'consult-dir-jump-file "consult-dir" "Jump to file from the directory in the minibuffer prompt." t)(autoload 'consult-dir "consult-dir" "Choose a directory and act on it.\n\nThe action taken on the directory is the value of\n`consult-dir-default-command'. The default is to call\n`find-file' starting at this directory.\n\nWhen called from the minibuffer, insert the directory into the\nminibuffer prompt instead. Existing minibuffer contents will be\nshadowed or deleted depending on the value of\n`consult-dir-shadow-filenames'.\n\nThe list of sources for directory paths is\n`consult-dir-sources', which can be customized." t)(autoload 'orderless-all-completions "orderless" "Split STRING into components and find entries TABLE matching all.\nThe predicate PRED is used to constrain the entries in TABLE.  The\nmatching portions of each candidate are highlighted.\nThis function is part of the `orderless' completion style.\n\n(fn STRING TABLE PRED POINT)")(autoload 'orderless-try-completion "orderless" "Complete STRING to unique matching entry in TABLE.\nThis uses `orderless-all-completions' to find matches for STRING\nin TABLE among entries satisfying PRED.  If there is only one\nmatch, it completes to that match.  If there are no matches, it\nreturns nil.  In any other case it \"completes\" STRING to\nitself, without moving POINT.\nThis function is part of the `orderless' completion style.\n\n(fn STRING TABLE PRED POINT)")(add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions "Completion of multiple components, in any order."))(autoload 'orderless-ivy-re-builder "orderless" "Convert STR into regexps for use with ivy.\nThis function is for integration of orderless with ivy, use it as\na value in `ivy-re-builders-alist'.\n\n(fn STR)")(autoload 'orderless-kwd-dispatch "orderless-kwd" "Match COMPONENT against the keywords in `orderless-kwd-alist'.\n\n(fn COMPONENT INDEX TOTAL)")(defvar vertico-mode nil "Non-nil if Vertico mode is enabled.\nSee the `vertico-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-mode'.")(autoload 'vertico-mode "vertico" "VERTical Interactive COmpletion.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar vertico-buffer-mode nil "Non-nil if Vertico-Buffer mode is enabled.\nSee the `vertico-buffer-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-buffer-mode'.")(autoload 'vertico-buffer-mode "vertico-buffer" "Display Vertico like a regular buffer in a large window.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Buffer mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-buffer-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'vertico-directory-enter "vertico-directory" "Enter directory or exit completion with current candidate.\nExit with current input if prefix ARG is given.\n\n(fn &optional ARG)" t)(autoload 'vertico-directory-up "vertico-directory" "Delete N names before point.\n\n(fn &optional N)" t)(autoload 'vertico-directory-delete-char "vertico-directory" "Delete N directories or chars before point.\n\n(fn &optional N)" t)(autoload 'vertico-directory-delete-word "vertico-directory" "Delete N directories or words before point.\n\n(fn &optional N)" t)(autoload 'vertico-directory-tidy "vertico-directory" "Tidy shadowed file name, see `rfn-eshadow-overlay'.")(defvar vertico-flat-mode nil "Non-nil if Vertico-Flat mode is enabled.\nSee the `vertico-flat-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-flat-mode'.")(autoload 'vertico-flat-mode "vertico-flat" "Flat, horizontal display for Vertico.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Flat mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-flat-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar vertico-grid-mode nil "Non-nil if Vertico-Grid mode is enabled.\nSee the `vertico-grid-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-grid-mode'.")(autoload 'vertico-grid-mode "vertico-grid" "Grid display for Vertico.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Grid mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-grid-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar vertico-indexed-mode nil "Non-nil if Vertico-Indexed mode is enabled.\nSee the `vertico-indexed-mode' command\nfor a description of this minor mode.")(autoload 'vertico-indexed-mode "vertico-indexed" "Prefix candidates with indices.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Indexed mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-indexed-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar vertico-mouse-mode nil "Non-nil if Vertico-Mouse mode is enabled.\nSee the `vertico-mouse-mode' command\nfor a description of this minor mode.")(autoload 'vertico-mouse-mode "vertico-mouse" "Mouse support for Vertico.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Mouse mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-mouse-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar vertico-multiform-mode nil "Non-nil if Vertico-Multiform mode is enabled.\nSee the `vertico-multiform-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-multiform-mode'.")(autoload 'vertico-multiform-mode "vertico-multiform" "Configure Vertico in various forms per command.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Multiform mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-multiform-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'vertico-quick-jump "vertico-quick" "Jump to candidate using quick keys." t)(autoload 'vertico-quick-exit "vertico-quick" "Exit with candidate using quick keys." t)(autoload 'vertico-quick-insert "vertico-quick" "Insert candidate using quick keys." t)(autoload 'vertico-repeat-save "vertico-repeat" "Save Vertico session for `vertico-repeat'.\nThis function must be registered as `minibuffer-setup-hook'.")(autoload 'vertico-repeat-next "vertico-repeat" "Repeat Nth next Vertico completion session.\nThis command must be called from an existing Vertico session\nafter `vertico-repeat-previous'.\n\n(fn N)" t)(autoload 'vertico-repeat-previous "vertico-repeat" "Repeat Nth previous Vertico completion session.\nIf called from an existing Vertico session, restore the input and\nselected candidate for the current command.\n\n(fn N)" t)(autoload 'vertico-repeat-select "vertico-repeat" "Select a Vertico session from the session history and repeat it.\nIf called from an existing Vertico session, you can select among\nprevious sessions for the current command." t)(autoload 'vertico-repeat "vertico-repeat" "Repeat last Vertico session.\nIf prefix ARG is non-nil, offer completion menu to select from session history.\n\n(fn &optional ARG)" t)(defvar vertico-reverse-mode nil "Non-nil if Vertico-Reverse mode is enabled.\nSee the `vertico-reverse-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-reverse-mode'.")(autoload 'vertico-reverse-mode "vertico-reverse" "Reverse the Vertico display.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Reverse mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-reverse-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'vertico-suspend "vertico-suspend" "Suspend the current completion session.\nIf the command is invoked from within the Vertico minibuffer, the\ncurrent session is suspended.  If the command is invoked from\noutside the minibuffer, the active minibuffer is either selected\nor the latest completion session is restored." t)(defvar vertico-unobtrusive-mode nil "Non-nil if Vertico-Unobtrusive mode is enabled.\nSee the `vertico-unobtrusive-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `vertico-unobtrusive-mode'.")(autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" "Unobtrusive display for Vertico.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Vertico-Unobtrusive mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='vertico-unobtrusive-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'yasnippet-capf "yasnippet-capf" "Complete with yasnippet at point.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-history "cape" "Complete from Eshell, Comint or minibuffer history.\nSee also `consult-history' for a more flexible variant based on\n`completing-read'.  If INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-file "cape" "Complete file name at point.\nSee the user option `cape-file-directory-must-exist'.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-elisp-symbol "cape" "Complete Elisp symbol at point.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-elisp-block "cape" "Complete Elisp in Org or Markdown code block.\nThis Capf is particularly useful for literate Emacs configurations.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-dabbrev "cape" "Complete with Dabbrev at point.\n\nIf INTERACTIVE is nil the function acts like a Capf.  In case you\nobserve a performance issue with auto-completion and `cape-dabbrev'\nit is strongly recommended to disable scanning in other buffers.\nSee the user options `cape-dabbrev-min-length' and\n`cape-dabbrev-check-other-buffers'.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-dict "cape" "Complete word from dictionary at point.\nThis completion function works best if the dictionary is sorted\nby frequency.  See the custom option `cape-dict-file'.  If\nINTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-abbrev "cape" "Complete abbreviation at point.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-line "cape" "Complete current line from other lines.\nThe buffers returned by `cape-line-buffer-function' are scanned for lines.\nIf INTERACTIVE is nil the function acts like a Capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'cape-company-to-capf "cape" "Convert Company BACKEND function to Capf.\nVALID is a function taking the old and new input string.  It should\nreturn nil if the cached candidates became invalid.  The default value\nfor VALID is `string-prefix-p' such that the candidates are only fetched\nagain if the input prefix changed.\n\n(fn BACKEND &optional VALID)")(autoload 'cape-interactive "cape" "Complete interactively with the given CAPFS.\n\n(fn &rest CAPFS)")(autoload 'cape-capf-interactive "cape" "Create interactive completion function from CAPF.\n\n(fn CAPF)")(autoload 'cape-wrap-super "cape" "Call CAPFS and return merged completion result.\nThe CAPFS list can contain the keyword `:with' to mark the Capfs\nafterwards as auxiliary One of the non-auxiliary Capfs before\n`:with' must return non-nil for the super Capf to set in and\nreturn a non-nil result.  Such behavior is useful when listing\nmultiple super Capfs in the `completion-at-point-functions':\n\n  (setq completion-at-point-functions\n        (list (cape-capf-super \\='eglot-completion-at-point\n                               :with \\='tempel-complete)\n              (cape-capf-super \\='cape-dabbrev\n                               :with \\='tempel-complete)))\n\n(fn &rest CAPFS)")(autoload 'cape-wrap-debug "cape" "Call CAPF and return a completion table which prints trace messages.\nIf CAPF is an anonymous lambda, pass the Capf NAME explicitly for\nmeaningful debugging output.\n\n(fn CAPF &optional NAME)")(autoload 'cape-wrap-buster "cape" "Call CAPF and return a completion table with cache busting.\nThis function can be used as an advice around an existing Capf.\nThe cache is busted when the input changes.  The argument VALID\ncan be a function taking the old and new input string.  It should\nreturn nil if the new input requires that the completion table is\nrefreshed.  The default value for VALID is `equal', such that the\ncompletion table is refreshed on every input change.\n\n(fn CAPF &optional VALID)")(autoload 'cape-wrap-passthrough "cape" "Call CAPF and make sure that no completion style filtering takes place.\n\n(fn CAPF)")(autoload 'cape-wrap-properties "cape" "Call CAPF and add additional completion PROPERTIES.\nCompletion properties include for example :exclusive, :annotation-function and\nthe various :company-* extensions.  Furthermore a boolean :sort flag and a\ncompletion :category symbol can be specified.\n\n(fn CAPF &rest PROPERTIES)")(autoload 'cape-wrap-nonexclusive "cape" "Call CAPF and ensure that it is marked as non-exclusive.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-predicate "cape" "Call CAPF and add an additional candidate PREDICATE.\nThe PREDICATE is passed the candidate symbol or string.\n\n(fn CAPF PREDICATE)")(autoload 'cape-wrap-silent "cape" "Call CAPF and silence it (no messages, no errors).\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-case-fold "cape" "Call CAPF and return a case-insensitive completion table.\nIf NOFOLD is non-nil return a case sensitive table instead.  This\nfunction can be used as an advice around an existing Capf.\n\n(fn CAPF &optional NOFOLD)")(autoload 'cape-wrap-noninterruptible "cape" "Call CAPF and return a non-interruptible completion table.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-prefix-length "cape" "Call CAPF and ensure that prefix length is greater or equal than LENGTH.\nIf the prefix is long enough, enforce auto completion.\n\n(fn CAPF LENGTH)")(autoload 'cape-wrap-inside-faces "cape" "Call CAPF only if inside FACES.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF &rest FACES)")(autoload 'cape-wrap-inside-code "cape" "Call CAPF only if inside code, not inside a comment or string.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-inside-comment "cape" "Call CAPF only if inside comment.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-inside-string "cape" "Call CAPF only if inside string.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-wrap-purify "cape" "Call CAPF and ensure that it does not illegally modify the buffer.\nThis function can be used as an advice around an existing\nCapf.  It has been introduced mainly to fix the broken\n`pcomplete-completions-at-point' function in Emacs versions < 29.\n\n(fn CAPF)")(autoload 'cape-wrap-accept-all "cape" "Call CAPF and return a completion table which accepts every input.\nThis function can be used as an advice around an existing Capf.\n\n(fn CAPF)")(autoload 'cape-capf-accept-all "cape")(autoload 'cape-capf-buster "cape")(autoload 'cape-capf-case-fold "cape")(autoload 'cape-capf-debug "cape")(autoload 'cape-capf-inside-code "cape")(autoload 'cape-capf-inside-comment "cape")(autoload 'cape-capf-inside-faces "cape")(autoload 'cape-capf-inside-string "cape")(autoload 'cape-capf-nonexclusive "cape")(autoload 'cape-capf-noninterruptible "cape")(autoload 'cape-capf-passthrough "cape")(autoload 'cape-capf-predicate "cape")(autoload 'cape-capf-prefix-length "cape")(autoload 'cape-capf-properties "cape")(autoload 'cape-capf-purify "cape")(autoload 'cape-capf-silent "cape")(autoload 'cape-capf-super "cape")(autoload 'cape-prefix-map "cape" nil t 'keymap)(autoload 'cape-tex "cape-char" nil t)(autoload 'cape-sgml "cape-char" nil t)(autoload 'cape-rfc1345 "cape-char" nil t)(when (> emacs-major-version 28) (autoload 'cape-emoji "cape-char" nil t))(autoload 'cape-keyword "cape-keyword" "Complete programming language keyword at point.\nSee the variable `cape-keyword-list'.\nIf INTERACTIVE is nil the function acts like a capf.\n\n(fn &optional INTERACTIVE)" t)(autoload 'corfu-mode "corfu" "COmpletion in Region FUnction.\n\nThis is a minor mode.  If called interactively, toggle the `Corfu\nmode' mode.  If the prefix argument is positive, enable the mode,\nand if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `corfu-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-corfu-mode 'globalized-minor-mode t)(defvar global-corfu-mode nil "Non-nil if Global Corfu mode is enabled.\nSee the `global-corfu-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-corfu-mode'.")(autoload 'global-corfu-mode "corfu" "Toggle Corfu mode in all buffers.\nWith prefix ARG, enable Global Corfu mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nCorfu mode is enabled in all buffers where `corfu--on' would do it.\n\nSee `corfu-mode' for more information on Corfu mode.\n\n(fn &optional ARG)" t)(defvar corfu-echo-mode nil "Non-nil if Corfu-Echo mode is enabled.\nSee the `corfu-echo-mode' command\nfor a description of this minor mode.")(autoload 'corfu-echo-mode "corfu-echo" "Show candidate documentation in echo area.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Corfu-Echo mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='corfu-echo-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar corfu-history-mode nil "Non-nil if Corfu-History mode is enabled.\nSee the `corfu-history-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `corfu-history-mode'.")(autoload 'corfu-history-mode "corfu-history" "Update Corfu history and sort completions by history.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Corfu-History mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='corfu-history-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar corfu-indexed-mode nil "Non-nil if Corfu-Indexed mode is enabled.\nSee the `corfu-indexed-mode' command\nfor a description of this minor mode.")(autoload 'corfu-indexed-mode "corfu-indexed" "Prefix candidates with indices.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Corfu-Indexed mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='corfu-indexed-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'corfu-info-documentation "corfu-info" "Show documentation of current candidate.\nIf called with a prefix ARG, the buffer is persistent.\n\n(fn &optional ARG)" t)(autoload 'corfu-info-location "corfu-info" "Show location of current candidate.\nIf called with a prefix ARG, the buffer is persistent.\n\n(fn &optional ARG)" t)(defvar corfu-popupinfo-mode nil "Non-nil if Corfu-Popupinfo mode is enabled.\nSee the `corfu-popupinfo-mode' command\nfor a description of this minor mode.")(autoload 'corfu-popupinfo-mode "corfu-popupinfo" "Corfu info popup minor mode.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Corfu-Popupinfo mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='corfu-popupinfo-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'corfu-quick-jump "corfu-quick" "Jump to candidate using quick keys." t)(autoload 'corfu-quick-insert "corfu-quick" "Insert candidate using quick keys." t)(autoload 'corfu-quick-complete "corfu-quick" "Complete candidate using quick keys." t)(defvar which-key-mode nil "Non-nil if Which-Key mode is enabled.\nSee the `which-key-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `which-key-mode'.")(autoload 'which-key-mode "which-key" "Toggle `which-key-mode'.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Which-Key mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='which-key-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'which-key-setup-side-window-right "which-key" "Set up side-window on right." t)(autoload 'which-key-setup-side-window-right-bottom "which-key" "Set up side-window on right if space allows.\nOtherwise, use bottom." t)(autoload 'which-key-setup-side-window-bottom "which-key" "Set up side-window that opens on bottom." t)(autoload 'which-key-setup-minibuffer "which-key" "Set up minibuffer display.\nDo not use this setup if you use the paging commands.  Instead use\n`which-key-setup-side-window-bottom', which is nearly identical\nbut more functional." t)(autoload 'which-key-add-keymap-based-replacements "which-key" "Replace the description of KEY using REPLACEMENT in KEYMAP.\nKEY should take a format suitable for use in `kbd'.  REPLACEMENT\nshould be a cons cell of the form (STRING . COMMAND) for each\nREPLACEMENT, where STRING is the replacement string and COMMAND\nis a symbol corresponding to the intended command to be\nreplaced.  COMMAND can be nil if the binding corresponds to a key\nprefix.  An example is\n\n(which-key-add-keymap-based-replacements global-map\n  \"C-x w\" \\='(\"Save as\" . write-file)).\n\nFor backwards compatibility, REPLACEMENT can also be a string,\nbut the above format is preferred, and the option to use a string\nfor REPLACEMENT will eventually be removed.\n\n(fn KEYMAP KEY REPLACEMENT &rest MORE)")(function-put 'which-key-add-keymap-based-replacements 'lisp-indent-function 'defun)(autoload 'which-key-add-key-based-replacements "which-key" "Replace the description of KEY-SEQUENCE with REPLACEMENT.\nKEY-SEQUENCE is a string suitable for use in `kbd'.\nREPLACEMENT may either be a string, as in\n\n(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")\n\na cons of two strings as in\n\n(which-key-add-key-based-replacements \"C-x 8\"\n                                        \\='(\"unicode\" . \"Unicode keys\"))\n\nor a function that takes a (KEY . BINDING) cons and returns a\nreplacement.\n\nIn the second case, the second string is used to provide a longer\nname for the keys under a prefix.\n\nMORE allows you to specifcy additional KEY REPLACEMENT pairs.  All\nreplacements are added to `which-key-replacement-alist'.\n\n(fn KEY-SEQUENCE REPLACEMENT &rest MORE)")(autoload 'which-key-add-major-mode-key-based-replacements "which-key" "Functions like `which-key-add-key-based-replacements'.\nThe difference is that MODE specifies the `major-mode' that must\nbe active for KEY-SEQUENCE and REPLACEMENT (MORE contains\naddition KEY-SEQUENCE REPLACEMENT pairs) to apply.\n\n(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)")(function-put 'which-key-add-major-mode-key-based-replacements 'lisp-indent-function 'defun)(autoload 'which-key-reload-key-sequence "which-key" "Simulate entering the key sequence KEY-SEQ.\nKEY-SEQ should be a list of events as produced by\n`listify-key-sequence'.  If nil, KEY-SEQ defaults to\n`which-key--current-key-list'.  Any prefix arguments that were\nused are reapplied to the new key sequence.\n\n(fn &optional KEY-SEQ)")(autoload 'which-key-show-standard-help "which-key" "Call the command in `which-key--prefix-help-cmd-backup'.\nUsually this is `describe-prefix-bindings'.\n\n(fn &optional _)" t)(autoload 'which-key-show-next-page-no-cycle "which-key" "Show next page of keys or `which-key-show-standard-help'." t)(autoload 'which-key-show-previous-page-no-cycle "which-key" "Show previous page of keys if one exists." t)(autoload 'which-key-show-next-page-cycle "which-key" "Show the next page of keys, cycling from end to beginning.\n\n(fn &optional _)" t)(autoload 'which-key-show-previous-page-cycle "which-key" "Show the previous page of keys, cycling from beginning to end.\n\n(fn &optional _)" t)(autoload 'which-key-show-top-level "which-key" "Show top-level bindings.\n\n(fn &optional _)" t)(autoload 'which-key-show-major-mode "which-key" "Show top-level bindings in the map of the current major mode.\nThis function will also detect evil bindings made using\n`evil-define-key' in this map.  These bindings will depend on the\ncurrent evil state.\n\n(fn &optional ALL)" t)(autoload 'which-key-show-full-major-mode "which-key" "Show all bindings in the map of the current major mode.\nThis function will also detect evil bindings made using\n`evil-define-key' in this map.  These bindings will depend on the\ncurrent evil state." t)(autoload 'which-key-dump-bindings "which-key" "Dump bindings from PREFIX into buffer named BUFFER-NAME.\nPREFIX should be a string suitable for `kbd'.\n\n(fn PREFIX BUFFER-NAME)" t)(autoload 'which-key-undo-key "which-key" "Undo last keypress and force which-key update.\n\n(fn &optional _)" t)(autoload 'which-key-C-h-dispatch "which-key" "Dispatch \\`C-h' commands by looking up key in `which-key-C-h-map'.\nThis command is always accessible (from any prefix) if\n`which-key-use-C-h-commands' is non nil." t)(autoload 'which-key-show-keymap "which-key" "Show the top-level bindings in KEYMAP using which-key.\nKEYMAP is selected interactively from all available keymaps.\n\nIf NO-PAGING is non-nil, which-key will not intercept subsequent\nkeypresses for the paging functionality.\n\n(fn KEYMAP &optional NO-PAGING)" t)(autoload 'which-key-show-full-keymap "which-key" "Show all bindings in KEYMAP using which-key.\nKEYMAP is selected interactively from all available keymaps.\n\n(fn KEYMAP)" t)(autoload 'which-key-show-minor-mode-keymap "which-key" "Show the top-level bindings in KEYMAP using which-key.\nKEYMAP is selected interactively by mode in\n`minor-mode-map-alist'.\n\n(fn &optional ALL)" t)(autoload 'which-key-show-full-minor-mode-keymap "which-key" "Show all bindings in KEYMAP using which-key.\nKEYMAP is selected interactively by mode in\n`minor-mode-map-alist'." t)(autoload 'general-define-key "general" "The primary key definition function provided by general.el.\n\nDefine MAPS, optionally using DEFINER, in the keymap(s) corresponding to STATES\nand KEYMAPS.\n\nMAPS consists of paired keys (vectors or strings; also see\n`general-implicit-kbd') and definitions (those mentioned in `define-key''s\ndocstring and general.el's \"extended\" definitions). All pairs (when not\nignored) will be recorded and can be later displayed with\n`general-describe-keybindings'.\n\nIf DEFINER is specified, a custom key definer will be used to bind MAPS. See\ngeneral.el's documentation/README for more information.\n\nUnlike with normal key definitions functions, the keymaps in KEYMAPS should be\nquoted (this allows using the keymap name for other purposes, e.g. deferring\nkeybindings if the keymap symbol is not bound, optionally inferring the\ncorresponding major mode for a symbol by removing \"-map\" for :which-key,\neasily storing the keymap name for use with `general-describe-keybindings',\netc.). Note that general.el provides other key definer macros that do not\nrequire quoting keymaps.\n\nSTATES corresponds to the evil state(s) to bind the keys in. Non-evil users\nshould not set STATES. When STATES is non-nil, `evil-define-key*' will be\nused (the evil auxiliary keymaps corresponding STATES and KEYMAPS will be used);\notherwise `define-key' will be used (unless DEFINER is specified). KEYMAPS\ndefaults to 'global. There is also 'local, which create buffer-local\nkeybindings for both evil and non-evil keybindings. There are other special,\nuser-alterable \"shorthand\" symbols for keymaps and states (see\n`general-keymap-aliases' and `general-state-aliases').\n\nNote that STATES and KEYMAPS can either be lists or single symbols. If any\nkeymap does not exist, those keybindings will be deferred until the keymap does\nexist, so using `eval-after-load' is not necessary with this function.\n\nPREFIX corresponds to a key to prefix keys in MAPS with and defaults to none. To\nbind/unbind a key specified with PREFIX, \"\" can be specified as a key in\nMAPS (e.g. ...:prefix \"SPC\" \"\" nil... will unbind space).\n\nThe keywords in this paragraph are only useful for evil users. If\nNON-NORMAL-PREFIX is specified, this prefix will be used instead of PREFIX for\nstates in `general-non-normal-states' (e.g. the emacs and insert states). This\nargument will only have an effect if one of these states is in STATES or if\ncorresponding global keymap (e.g. `evil-insert-state-map') is in KEYMAPS.\nAlternatively, GLOBAL-PREFIX can be used with PREFIX and/or NON-NORMAL-PREFIX to\nbind keys in all states under the specified prefix. Like with NON-NORMAL-PREFIX,\nGLOBAL-PREFIX will prevent PREFIX from applying to `general-non-normal-states'.\nINFIX can be used to append a string to all of the specified prefixes. This is\npotentially useful when you are using GLOBAL-PREFIX and/or NON-NORMAL-PREFIX so\nthat you can sandwich keys in between all the prefixes and the specified keys in\nMAPS. This may be particularly useful if you are using default prefixes in a\nwrapper function/macro so that you can add to them without needing to re-specify\nall of them. If none of the other prefix keyword arguments are specified, INFIX\nwill have no effect.\n\nIf PREFIX-COMMAND or PREFIX-MAP is specified, a prefix command and/or keymap\nwill be created. PREFIX-NAME can be additionally specified to set the keymap\nmenu name/prompt. If PREFIX-COMMAND is specified, `define-prefix-command' will\nbe used. Otherwise, only a prefix keymap will be created. Previously created\nprefix commands/keymaps will never be redefined/cleared. All prefixes (including\nthe INFIX key, if specified) will then be bound to PREFIX-COMMAND or PREFIX-MAP.\nIf the user did not specify any PREFIX or manually specify any KEYMAPS, general\nwill bind all MAPS in the prefix keymap corresponding to either PREFIX-MAP or\nPREFIX-COMMAND instead of in the default keymap.\n\nPREDICATE corresponds to a predicate to check to determine whether a definition\nshould be active (e.g. \":predicate '(eobp)\"). Definitions created with a\npredicate will only be active when the predicate is true. When the predicate is\nfalse, key lookup will continue to search for a match in lower-precedence\nkeymaps.\n\nIn addition to the normal definitions supported by `define-key', general.el also\nprovides \"extended\" definitions, which are plists containing the normal\ndefinition as well as other keywords. For example, PREDICATE can be specified\nglobally or locally in an extended definition. New global (~general-define-key~)\nand local (extended definition) keywords can be added by the user. See\n`general-extended-def-keywords' and general.el's documentation/README for more\ninformation.\n\nPACKAGE is the global version of the extended definition keyword that specifies\nthe package a keymap is defined in (used for \"autoloading\" keymaps)\n\nPROPERTIES, REPEAT, and JUMP are the global versions of the extended definition\nkeywords used for adding evil command properties to commands.\n\nMAJOR-MODES, WK-MATCH-KEYS, WK-MATCH-BINDINGS, and WK-FULL-KEYS are the\ncorresponding global versions of which-key extended definition keywords. They\nwill only have an effect for extended definitions that specify :which-key or\n:wk. See the section on extended definitions in the general.el\ndocumentation/README for more information.\n\nLISPY-PLIST and WORF-PLIST are the global versions of extended definition\nkeywords that are used for each corresponding custom DEFINER.\n\n(fn &rest MAPS &key DEFINER (STATES general-default-states) (KEYMAPS general-default-keymaps KEYMAPS-SPECIFIED-P) (PREFIX general-default-prefix) (NON-NORMAL-PREFIX general-default-non-normal-prefix) (GLOBAL-PREFIX general-default-global-prefix) INFIX PREFIX-COMMAND PREFIX-MAP PREFIX-NAME PREDICATE PACKAGE PROPERTIES REPEAT JUMP MAJOR-MODES (WK-MATCH-KEYS t) (WK-MATCH-BINDING t) (WK-FULL-KEYS t) LISPY-PLIST WORF-PLIST &allow-other-keys)")(autoload 'general-emacs-define-key "general" "A wrapper for `general-define-key' that is similar to `define-key'.\nIt has a positional argument for KEYMAPS (that will not be overridden by a later\n:keymaps argument). Besides this, it acts the same as `general-define-key', and\nARGS can contain keyword arguments in addition to keybindings. This can\nbasically act as a drop-in replacement for `define-key', and unlike with\n`general-define-key', KEYMAPS does not need to be quoted.\n\n(fn KEYMAPS &rest ARGS)" nil t)(function-put 'general-emacs-define-key 'lisp-indent-function 1)(autoload 'general-evil-define-key "general" "A wrapper for `general-define-key' that is similar to `evil-define-key'.\nIt has positional arguments for STATES and KEYMAPS (that will not be overridden\nby a later :keymaps or :states argument). Besides this, it acts the same as\n`general-define-key', and ARGS can contain keyword arguments in addition to\nkeybindings. This can basically act as a drop-in replacement for\n`evil-define-key', and unlike with `general-define-key', KEYMAPS does not need\nto be quoted.\n\n(fn STATES KEYMAPS &rest ARGS)" nil t)(function-put 'general-evil-define-key 'lisp-indent-function 2)(autoload 'general-def "general" "General definer that takes a variable number of positional arguments in ARGS.\nThis macro will act as `general-define-key', `general-emacs-define-key', or\n`general-evil-define-key' based on how many of the initial arguments do not\ncorrespond to keybindings. All quoted and non-quoted lists and symbols before\nthe first string, vector, or keyword are considered to be positional arguments.\nThis means that you cannot use a function or variable for a key that starts\nimmediately after the positional arguments. If you need to do this, you should\nuse one of the definers that `general-def' dispatches to or explicitly separate\nthe positional arguments from the maps with a bogus keyword pair like\n\":start-maps t\"\n\n(fn &rest ARGS)" nil t)(function-put 'general-def 'lisp-indent-function 'defun)(autoload 'general-create-definer "general" "A helper macro to create wrappers for `general-def'.\nThis can be used to create key definers that will use a certain keymap, evil\nstate, prefix key, etc. by default. NAME is the wrapper name and DEFAULTS are\nthe default arguments. WRAPPING can also be optionally specified to use a\ndifferent definer than `general-def'. It should not be quoted.\n\n(fn NAME &rest DEFAULTS &key WRAPPING &allow-other-keys)" nil t)(function-put 'general-create-definer 'lisp-indent-function 'defun)(autoload 'general-defs "general" "A wrapper that splits into multiple `general-def's.\nEach consecutive grouping of positional argument followed by keyword/argument\npairs (having only one or the other is fine) marks the start of a new section.\nEach section corresponds to one use of `general-def'. This means that settings\nonly apply to the keybindings that directly follow.\n\nSince positional arguments can appear at any point, unqouted symbols are always\nconsidered to be positional arguments (e.g. a keymap). This means that variables\ncan never be used for keys with `general-defs'. Variables can still be used for\ndefinitions or as arguments to keywords.\n\n(fn &rest ARGS)" nil t)(function-put 'general-defs 'lisp-indent-function 'defun)(autoload 'general-unbind "general" "A wrapper for `general-def' to unbind multiple keys simultaneously.\nInsert after all keys in ARGS before passing ARGS to `general-def.' \":with\n #'func\" can optionally specified to use a custom function instead (e.g.\n `ignore').\n\n(fn &rest ARGS)" nil t)(function-put 'general-unbind 'lisp-indent-function 'defun)(autoload 'general-describe-keybindings "general" "Show all keys that have been bound with general in an org buffer.\nAny local keybindings will be shown first followed by global keybindings.\nWith a non-nil prefix ARG only show bindings in active maps.\n\n(fn &optional ARG)" t)(autoload 'general-key "general" "Act as KEY's definition in the current context.\nThis uses an extended menu item's capability of dynamically computing a\ndefinition. It is recommended over `general-simulate-key' wherever possible. See\nthe docstring of `general-simulate-key' and the readme for information about the\nbenefits and downsides of `general-key'.\n\nKEY should be a string given in `kbd' notation and should correspond to a single\ndefinition (as opposed to a sequence of commands). When STATE is specified, look\nup KEY with STATE as the current evil state. When specified, DOCSTRING will be\nthe menu item's name/description.\n\nLet can be used to bind variables around key lookup. For example:\n(general-key \"some key\"\n  :let ((some-var some-val)))\n\nSETUP and TEARDOWN can be used to run certain functions before and after key\nlookup. For example, something similar to using :state 'emacs would be:\n(general-key \"some key\"\n  :setup (evil-local-mode -1)\n  :teardown (evil-local-mode))\n\nACCEPT-DEFAULT, NO-REMAP, and POSITION are passed to `key-binding'.\n\n(fn KEY &key STATE DOCSTRING LET SETUP TEARDOWN ACCEPT-DEFAULT NO-REMAP POSITION)" nil t)(function-put 'general-key 'lisp-indent-function 1)(autoload 'general-simulate-keys "general" "Deprecated. Please use `general-simulate-key' instead.\n\n(fn KEYS &optional STATE KEYMAP (LOOKUP t) DOCSTRING NAME)" nil t)(autoload 'general-simulate-key "general" "Create and return a command that simulates KEYS in STATE and KEYMAP.\n\n`general-key' should be prefered over this whenever possible as it is simpler\nand has saner functionality in many cases because it does not rely on\n`unread-command-events' (e.g. \"C-h k\" will show the docstring of the command\nto be simulated ; see the readme for more information). The main downsides of\n`general-key' are that it cannot simulate a command followed by keys or\nsubsequent commands, and which-key does not currently work well with it when\nsimulating a prefix key/incomplete key sequence.\n\nKEYS should be a string given in `kbd' notation. It can also be a list of a\nsingle command followed by a string of the key(s) to simulate after calling that\ncommand. STATE should only be specified by evil users and should be a quoted\nevil state. KEYMAP should not be quoted. Both STATE and KEYMAP aliases are\nsupported (but they have to be set when the macro is expanded). When neither\nSTATE or KEYMAP are specified, the key(s) will be simulated in the current\ncontext.\n\nIf NAME is specified, it will replace the automatically generated function name.\nNAME should not be quoted. If DOCSTRING is specified, it will replace the\nautomatically generated docstring.\n\nNormally the generated function will look up KEY in the correct context to try\nto match a command. To prevent this lookup, LOOKUP can be specified as nil.\nGenerally, you will want to keep LOOKUP non-nil because this will allow checking\nthe evil repeat property of matched commands to determine whether or not they\nshould be recorded. See the docstring for `general--simulate-keys' for more\ninformation about LOOKUP.\n\nWhen a WHICH-KEY description is specified, it will replace the command name in\nthe which-key popup.\n\nWhen a command name is specified and that command has been remapped (i.e. [remap\ncommand] is currently bound), the remapped version will be used instead of the\noriginal command unless REMAP is specified as nil (it is true by default).\n\nThe advantages of this over a keyboard macro are as follows:\n- Prefix arguments are supported\n- The user can control the context in which the keys are simulated\n- The user can simulate both a named command and keys\n- The user can simulate an incomplete key sequence (e.g. for a keymap)\n\n(fn KEYS &key STATE KEYMAP NAME DOCSTRING (LOOKUP t) WHICH-KEY (REMAP t))" nil t)(function-put 'general-simulate-key 'lisp-indent-function 'defun)(autoload 'general-key-dispatch "general" "Create and return a command that runs FALLBACK-COMMAND or a command in MAPS.\nMAPS consists of <key> <command> pairs. If a key in MAPS is matched, the\ncorresponding command will be run. Otherwise FALLBACK-COMMAND will be run with\nthe unmatched keys. So, for example, if \"ab\" was pressed, and \"ab\" is not\none of the key sequences from MAPS, the FALLBACK-COMMAND will be run followed by\nthe simulated keypresses of \"ab\". Prefix arguments will still work regardless\nof which command is run. This is useful for binding under non-prefix keys. For\nexample, this can be used to redefine a sequence like \"cw\" or \"cow\" in evil\nbut still have \"c\" work as `evil-change'. If TIMEOUT is specified,\nFALLBACK-COMMAND will also be run in the case that the user does not press the\nnext key within the TIMEOUT (e.g. 0.5).\n\nNAME and DOCSTRING are optional keyword arguments. They can be used to replace\nthe automatically generated name and docstring for the created function. By\ndefault, `cl-gensym' is used to prevent name clashes (e.g. allows the user to\ncreate multiple different commands using `self-insert-command' as the\nFALLBACK-COMMAND without explicitly specifying NAME to manually prevent\nclashes).\n\nWhen INHERIT-KEYMAP is specified, all the keybindings from that keymap will be\ninherited in MAPS.\n\nWhen a WHICH-KEY description is specified, it will replace the command name in\nthe which-key popup.\n\nWhen command to be executed has been remapped (i.e. [remap command] is currently\nbound), the remapped version will be used instead of the original command unless\nREMAP is specified as nil (it is true by default).\n\n(fn FALLBACK-COMMAND &rest MAPS &key TIMEOUT INHERIT-KEYMAP NAME DOCSTRING WHICH-KEY (REMAP t) &allow-other-keys)" nil t)(function-put 'general-key-dispatch 'lisp-indent-function 1)(autoload 'general-predicate-dispatch "general" "\n\n(fn FALLBACK-DEF &rest DEFS &key DOCSTRING &allow-other-keys)" nil t)(function-put 'general-predicate-dispatch 'lisp-indent-function 1)(autoload 'general-translate-key "general" "Translate keys in the keymap(s) corresponding to STATES and KEYMAPS.\nSTATES should be the name of an evil state, a list of states, or nil. KEYMAPS\nshould be a symbol corresponding to the keymap to make the translations in or a\nlist of keymap names. Keymap and state aliases are supported (as well as 'local\nand 'global for KEYMAPS).\n\nMAPS corresponds to a list of translations (key replacement pairs). For example,\nspecifying \"a\" \"b\" will bind \"a\" to \"b\"'s definition in the keymap.\nSpecifying nil as a replacement will unbind a key.\n\nIf DESTRUCTIVE is non-nil, the keymap will be destructively altered without\ncreating a backup. If DESTRUCTIVE is nil, store a backup of the keymap on the\ninitial invocation, and for future invocations always look up keys in the\noriginal/backup keymap. On the other hand, if DESTRUCTIVE is non-nil, calling\nthis function multiple times with \"a\" \"b\" \"b\" \"a\", for example, would\ncontinue to swap and unswap the definitions of these keys. This means that when\nDESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\ninvocation.\n\nIf both MAPS and DESCTRUCTIVE are nil, only create the backup keymap.\n\n(fn STATES KEYMAPS &rest MAPS &key DESTRUCTIVE &allow-other-keys)")(function-put 'general-translate-key 'lisp-indent-function 'defun)(autoload 'general-swap-key "general" "Wrapper around `general-translate-key' for swapping keys.\nSTATES, KEYMAPS, and ARGS are passed to `general-translate-key'. ARGS should\nconsist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"\nwith `general-translate-key') and optionally keyword arguments for\n`general-translate-key'.\n\n(fn STATES KEYMAPS &rest ARGS)" nil t)(function-put 'general-swap-key 'lisp-indent-function 'defun)(autoload 'general-auto-unbind-keys "general" "Advise `define-key' to automatically unbind keys when necessary.\nThis will prevent errors when a sub-sequence of a key is already bound (e.g. the\nuser attempts to bind \"SPC a\" when \"SPC\" is bound, resulting in a \"Key\nsequnce starts with non-prefix key\" error). When UNDO is non-nil, remove\nadvice.\n\n(fn &optional UNDO)")(autoload 'general-add-hook "general" "A drop-in replacement for `add-hook'.\nUnlike `add-hook', HOOKS and FUNCTIONS can be single items or lists. APPEND and\nLOCAL are passed directly to `add-hook'. When TRANSIENT is non-nil, each\nfunction will remove itself from the hook it is in after it is run once. If\nTRANSIENT is a function, call it on the return value in order to determine\nwhether to remove a function from the hook. For example, if TRANSIENT is\n#'identity, remove each function only if it returns non-nil. TRANSIENT could\nalternatively check something external and ignore the function's return value.\n\n(fn HOOKS FUNCTIONS &optional APPEND LOCAL TRANSIENT)")(autoload 'general-remove-hook "general" "A drop-in replacement for `remove-hook'.\nUnlike `remove-hook', HOOKS and FUNCTIONS can be single items or lists. LOCAL is\npassed directly to `remove-hook'.\n\n(fn HOOKS FUNCTIONS &optional LOCAL)")(autoload 'general-advice-add "general" "A drop-in replacement for `advice-add'.\nSYMBOLS, WHERE, FUNCTIONS, and PROPS correspond to the arguments for\n`advice-add'. Unlike `advice-add', SYMBOLS and FUNCTIONS can be single items or\nlists. When TRANSIENT is non-nil, each function will remove itself as advice\nafter it is run once. If TRANSIENT is a function, call it on the return value in\norder to determine whether to remove a function as advice. For example, if\nTRANSIENT is #'identity, remove each function only if it returns non-nil.\nTRANSIENT could alternatively check something external and ignore the function's\nreturn value.\n\n(fn SYMBOLS WHERE FUNCTIONS &optional PROPS TRANSIENT)")(autoload 'general-add-advice "general")(autoload 'general-advice-remove "general" "A drop-in replacement for `advice-remove'.\nUnlike `advice-remove', SYMBOLS and FUNCTIONS can be single items or lists.\n\n(fn SYMBOLS FUNCTIONS)")(autoload 'general-remove-advice "general")(autoload 'general-evil-setup "general" "Set up some basic equivalents for vim mapping functions.\nThis creates global key definition functions for the evil states.\nSpecifying SHORT-NAMES as non-nil will create non-prefixed function\naliases such as `nmap' for `general-nmap'.\n\n(fn &optional SHORT-NAMES _)")(autoload 'project-current "project" "Return the project instance in DIRECTORY, defaulting to `default-directory'.\n\nWhen no project is found in that directory, the result depends on\nthe value of MAYBE-PROMPT: if it is nil or omitted, return nil,\nelse prompt the user for the project to use.  To prompt for a\nproject, call the function specified by `project-prompter', which\nreturns the directory in which to look for the project.  If no\nproject is found in that directory, return a \"transient\"\nproject instance.\n\nThe \"transient\" project instance is a special kind of value\nwhich denotes a project rooted in that directory and includes all\nthe files under the directory except for those that match entries\nin `vc-directory-exclusion-list' or `grep-find-ignored-files'.\n\nSee the doc string of `project-find-functions' for the general form\nof the project instance object.\n\n(fn &optional MAYBE-PROMPT DIRECTORY)")(put 'project-vc-ignores 'safe-local-variable (lambda (val) (and (listp val) (not (memq nil (mapcar #'stringp val))))))(put 'project-vc-merge-submodules 'safe-local-variable #'booleanp)(put 'project-vc-include-untracked 'safe-local-variable #'booleanp)(put 'project-vc-name 'safe-local-variable #'stringp)(put 'project-vc-extra-root-markers 'safe-local-variable (lambda (val) (and (listp val) (not (memq nil (mapcar #'stringp val))))))(defvar project-prefix-map (let ((map (make-sparse-keymap))) (define-key map "!" 'project-shell-command) (define-key map "&" 'project-async-shell-command) (define-key map "f" 'project-find-file) (define-key map "F" 'project-or-external-find-file) (define-key map "b" 'project-switch-to-buffer) (define-key map "s" 'project-shell) (define-key map "d" 'project-find-dir) (define-key map "D" 'project-dired) (define-key map "v" 'project-vc-dir) (define-key map "c" 'project-compile) (define-key map "e" 'project-eshell) (define-key map "k" 'project-kill-buffers) (define-key map "p" 'project-switch-project) (define-key map "g" 'project-find-regexp) (define-key map "G" 'project-or-external-find-regexp) (define-key map "r" 'project-query-replace-regexp) (define-key map "x" 'project-execute-extended-command) (define-key map "o" 'project-any-command) (define-key map "\2" 'project-list-buffers) map) "Keymap for project commands.")(define-key ctl-x-map "p" project-prefix-map)(autoload 'project-other-window-command "project" "Run project command, displaying resultant buffer in another window.\n\nThe following commands are available:\n\n\\{project-prefix-map}\n\\{project-other-window-map}" t)(define-key ctl-x-4-map "p" #'project-other-window-command)(autoload 'project-other-frame-command "project" "Run project command, displaying resultant buffer in another frame.\n\nThe following commands are available:\n\n\\{project-prefix-map}\n\\{project-other-frame-map}" t)(define-key ctl-x-5-map "p" #'project-other-frame-command)(autoload 'project-other-tab-command "project" "Run project command, displaying resultant buffer in a new tab.\n\nThe following commands are available:\n\n\\{project-prefix-map}" t)(when (bound-and-true-p tab-prefix-map) (define-key tab-prefix-map "p" #'project-other-tab-command))(autoload 'project-find-regexp "project" "Find all matches for REGEXP in the current project's roots.\nWith \\[universal-argument] prefix, you can specify the directory\nto search in, and the file name pattern to search for.  The\npattern may use abbreviations defined in `grep-files-aliases',\ne.g. entering `ch' is equivalent to `*.[ch]'.  As whitespace\ntriggers completion when entering a pattern, including it\nrequires quoting, e.g. `\\[quoted-insert]<space>'.\n\n(fn REGEXP)" t)(autoload 'project-or-external-find-regexp "project" "Find all matches for REGEXP in the project roots or external roots.\n\n(fn REGEXP)" t)(autoload 'project-find-file "project" "Visit a file (with completion) in the current project.\n\nThe filename at point (determined by `thing-at-point'), if any,\nis available as part of \"future history\".  If none, the current\nbuffer's file name is used.\n\nIf INCLUDE-ALL is non-nil, or with prefix argument when called\ninteractively, include all files under the project root, except\nfor VCS directories listed in `vc-directory-exclusion-list'.\n\n(fn &optional INCLUDE-ALL)" t)(autoload 'project-or-external-find-file "project" "Visit a file (with completion) in the current project or external roots.\n\nThe filename at point (determined by `thing-at-point'), if any,\nis available as part of \"future history\".  If none, the current\nbuffer's file name is used.\n\nIf INCLUDE-ALL is non-nil, or with prefix argument when called\ninteractively, include all files under the project root, except\nfor VCS directories listed in `vc-directory-exclusion-list'.\n\n(fn &optional INCLUDE-ALL)" t)(autoload 'project-find-dir "project" "Start Dired in a directory inside the current project.\n\nThe current buffer's `default-directory' is available as part of\n\"future history\"." t)(autoload 'project-dired "project" "Start Dired in the current project's root." t)(autoload 'project-vc-dir "project" "Run VC-Dir in the current project's root." t)(autoload 'project-shell "project" "Start an inferior shell in the current project's root directory.\nIf a buffer already exists for running a shell in the project's root,\nswitch to it.  Otherwise, create a new shell buffer.\nWith \\[universal-argument] prefix arg, create a new inferior shell buffer even\nif one already exists." t)(autoload 'project-eshell "project" "Start Eshell in the current project's root directory.\nIf a buffer already exists for running Eshell in the project's root,\nswitch to it.  Otherwise, create a new Eshell buffer.\nWith \\[universal-argument] prefix arg, create a new Eshell buffer even\nif one already exists." t)(autoload 'project-async-shell-command "project" "Run `async-shell-command' in the current project's root directory." t)(function-put 'project-async-shell-command 'interactive-only 'async-shell-command)(autoload 'project-shell-command "project" "Run `shell-command' in the current project's root directory." t)(function-put 'project-shell-command 'interactive-only 'shell-command)(autoload 'project-search "project" "Search for REGEXP in all the files of the project.\nStops when a match is found.\nTo continue searching for the next match, use the\ncommand \\[fileloop-continue].\n\n(fn REGEXP)" t)(autoload 'project-query-replace-regexp "project" "Query-replace REGEXP in all the files of the project.\nStops when a match is found and prompts for whether to replace it.\nAt that prompt, the user must type a character saying what to do\nwith the match.  Type SPC or `y' to replace the match,\nDEL or `n' to skip and go to the next match.  For more directions,\ntype \\[help-command] at that time.\nIf you exit the `query-replace', you can later continue the\n`query-replace' loop using the command \\[fileloop-continue].\n\n(fn FROM TO)" t)(autoload 'project-compile "project" "Run `compile' in the project root." t)(function-put 'project-compile 'interactive-only 'compile)(autoload 'project-switch-to-buffer "project" "Display buffer BUFFER-OR-NAME in the selected window.\nWhen called interactively, prompts for a buffer belonging to the\ncurrent project.  Two buffers belong to the same project if their\nproject instances, as reported by `project-current' in each\nbuffer, are identical.\n\n(fn BUFFER-OR-NAME)" t)(autoload 'project-display-buffer "project" "Display BUFFER-OR-NAME in some window, without selecting it.\nWhen called interactively, prompts for a buffer belonging to the\ncurrent project.  Two buffers belong to the same project if their\nproject instances, as reported by `project-current' in each\nbuffer, are identical.\n\nThis function uses `display-buffer' as a subroutine, which see\nfor how it is determined where the buffer will be displayed.\n\n(fn BUFFER-OR-NAME)" t)(autoload 'project-display-buffer-other-frame "project" "Display BUFFER-OR-NAME preferably in another frame.\nWhen called interactively, prompts for a buffer belonging to the\ncurrent project.  Two buffers belong to the same project if their\nproject instances, as reported by `project-current' in each\nbuffer, are identical.\n\nThis function uses `display-buffer-other-frame' as a subroutine,\nwhich see for how it is determined where the buffer will be\ndisplayed.\n\n(fn BUFFER-OR-NAME)" t)(autoload 'project-list-buffers "project" "Display a list of project buffers.\nThe list is displayed in a buffer named \"*Buffer List*\".\n\nBy default, all project buffers are listed except those whose names\nstart with a space (which are for internal use).  With prefix argument\nARG, show only buffers that are visiting files.\n\n(fn &optional ARG)" t)(put 'project-kill-buffers-display-buffer-list 'safe-local-variable #'booleanp)(autoload 'project-kill-buffers "project" "Kill the buffers belonging to the current project.\nTwo buffers belong to the same project if their project\ninstances, as reported by `project-current' in each buffer, are\nidentical.  Only the buffers that match a condition in\n`project-kill-buffer-conditions' will be killed.  If NO-CONFIRM\nis non-nil, the command will not ask the user for confirmation.\nNO-CONFIRM is always nil when the command is invoked\ninteractively.\n\nIf PROJECT is non-nil, kill buffers for that project instead.\n\nAlso see the `project-kill-buffers-display-buffer-list' variable.\n\n(fn &optional NO-CONFIRM PROJECT)" t)(autoload 'project-remember-project "project" "Add project PR to the front of the project list.\nSave the result in `project-list-file' if the list of projects\nhas changed, and NO-WRITE is nil.\n\n(fn PR &optional NO-WRITE)")(autoload 'project-forget-project "project" "Remove directory PROJECT-ROOT from the project list.\nPROJECT-ROOT is the root directory of a known project listed in\nthe project list.\n\n(fn PROJECT-ROOT)" t)(autoload 'project-known-project-roots "project" "Return the list of root directories of all known projects.")(autoload 'project-execute-extended-command "project" "Execute an extended command in project root." t)(function-put 'project-execute-extended-command 'interactive-only 'command-execute)(autoload 'project-any-command "project" "Run the next command in the current project.\n\nIf the command name starts with `project-', or its symbol has\nproperty `project-aware', it gets passed the project to use\nwith the variable `project-current-directory-override'.\nOtherwise, `default-directory' is temporarily set to the current\nproject's root.\n\nIf OVERRIDING-MAP is non-nil, it will be used as\n`overriding-terminal-local-map' to provide shorter bindings\nfrom that map which will take priority over the global ones.\n\n(fn &optional OVERRIDING-MAP PROMPT-FORMAT)" t)(autoload 'project-prefix-or-any-command "project" "Run the next command in the current project.\nWorks like `project-any-command', but also mixes in the shorter\nbindings from `project-prefix-map'." t)(autoload 'project-switch-project "project" "\"Switch\" to another project by running an Emacs command.\nThe available commands are presented as a dispatch menu\nmade from `project-switch-commands'.\n\nWhen called in a program, it will use the project corresponding\nto directory DIR.\n\n(fn DIR)" t)(autoload 'project-uniquify-dirname-transform "project" "Uniquify name of directory DIRNAME using `project-name', if in a project.\n\nIf you set `uniquify-dirname-transform' to this function,\nslash-separated components from `project-name' will be appended to\nthe buffer's directory name when buffers from two different projects\nwould otherwise have the same name.\n\n(fn DIRNAME)")(defvar project-mode-line nil "Whether to show current project name and Project menu on the mode line.\nThis feature requires the presence of the following item in\n`mode-line-format': `(project-mode-line project-mode-line-format)'; it\nis part of the default mode line beginning with Emacs 30.")(autoload 'xref-find-backend "xref")(define-obsolete-function-alias 'xref-pop-marker-stack #'xref-go-back "29.1")(autoload 'xref-go-back "xref" "Go back to the previous position in xref history.\nTo undo, use \\[xref-go-forward]." t)(autoload 'xref-go-forward "xref" "Go to the point where a previous \\[xref-go-back] was invoked." t)(autoload 'xref-marker-stack-empty-p "xref" "Whether the xref back-history is empty.")(autoload 'xref-forward-history-empty-p "xref" "Whether the xref forward-history is empty.")(autoload 'xref-show-xrefs "xref" "Display some Xref values produced by FETCHER using DISPLAY-ACTION.\nThe meanings of both arguments are the same as documented in\n`xref-show-xrefs-function'.\n\n(fn FETCHER DISPLAY-ACTION)")(autoload 'xref-find-definitions "xref" "Find the definition of the identifier at point.\nWith prefix argument or when there's no identifier at point,\nprompt for it.\n\nIf sufficient information is available to determine a unique\ndefinition for IDENTIFIER, display it in the selected window.\nOtherwise, display the list of the possible definitions in a\nbuffer where the user can select from the list.\n\nUse \\[xref-go-back] to return back to where you invoked this command.\n\n(fn IDENTIFIER)" t)(autoload 'xref-find-definitions-other-window "xref" "Like `xref-find-definitions' but switch to the other window.\n\n(fn IDENTIFIER)" t)(autoload 'xref-find-definitions-other-frame "xref" "Like `xref-find-definitions' but switch to the other frame.\n\n(fn IDENTIFIER)" t)(autoload 'xref-find-references "xref" "Find references to the identifier at point.\nThis command might prompt for the identifier as needed, perhaps\noffering the symbol at point as the default.\nWith prefix argument, or if `xref-prompt-for-identifier' is t,\nalways prompt for the identifier.  If `xref-prompt-for-identifier'\nis nil, prompt only if there's no usable symbol at point.\n\n(fn IDENTIFIER)" t)(autoload 'xref-find-definitions-at-mouse "xref" "Find the definition of identifier at or around mouse click.\nThis command is intended to be bound to a mouse event.\n\n(fn EVENT)" t)(autoload 'xref-find-references-at-mouse "xref" "Find references to the identifier at or around mouse click.\nThis command is intended to be bound to a mouse event.\n\n(fn EVENT)" t)(autoload 'xref-find-apropos "xref" "Find all meaningful symbols that match PATTERN.\nThe argument has the same meaning as in `apropos'.\nSee `tags-apropos-additional-actions' for how to augment the\noutput of this command when the backend is etags.\n\n(fn PATTERN)" t)(define-key esc-map "." #'xref-find-definitions)(define-key esc-map "," #'xref-go-back)(define-key esc-map [67108908] #'xref-go-forward)(define-key esc-map "?" #'xref-find-references)(define-key esc-map [67108910] #'xref-find-apropos)(define-key ctl-x-4-map "." #'xref-find-definitions-other-window)(define-key ctl-x-5-map "." #'xref-find-definitions-other-frame)(autoload 'xref-references-in-directory "xref" "Find all references to SYMBOL in directory DIR.\nReturn a list of xref values.\n\nThis function uses the Semantic Symbol Reference API, see\n`semantic-symref-tool-alist' for details on which tools are used,\nand when.\n\n(fn SYMBOL DIR)")(autoload 'xref-matches-in-directory "xref" "Find all matches for REGEXP in directory DIR.\nReturn a list of xref values.\nOnly files matching some of FILES and none of IGNORES are searched.\nFILES is a string with glob patterns separated by spaces.\nIGNORES is a list of glob patterns for files to ignore.\n\n(fn REGEXP FILES DIR IGNORES)")(autoload 'xref-matches-in-files "xref" "Find all matches for REGEXP in FILES.\nReturn a list of xref values.\nFILES must be a list of absolute file names.\n\nSee `xref-search-program' and `xref-search-program-alist' for how\nto control which program to use when looking for matches.\n\n(fn REGEXP FILES)")(autoload 'projectile-version "projectile" "Get the Projectile version as string.\n\nIf called interactively or if SHOW-VERSION is non-nil, show the\nversion in the echo area and the messages buffer.\n\nThe returned string includes both, the version from package.el\nand the library version, if both a present and different.\n\nIf the version number could not be determined, signal an error,\nif called interactively, or if SHOW-VERSION is non-nil, otherwise\njust return nil.\n\n(fn &optional SHOW-VERSION)" t)(autoload 'projectile-invalidate-cache "projectile" "Remove the current project's files from `projectile-projects-cache'.\n\nWith a prefix argument PROMPT prompts for the name of the project whose cache\nto invalidate.\n\n(fn PROMPT)" t)(autoload 'projectile-purge-file-from-cache "projectile" "Purge FILE from the cache of the current project.\n\n(fn FILE)" t)(autoload 'projectile-purge-dir-from-cache "projectile" "Purge DIR from the cache of the current project.\n\n(fn DIR)" t)(autoload 'projectile-cache-current-file "projectile" "Add the currently visited file to the cache." t)(autoload 'projectile-discover-projects-in-directory "projectile" "Discover any projects in DIRECTORY and add them to the projectile cache.\n\nIf DEPTH is non-nil recursively descend exactly DEPTH levels below DIRECTORY and\ndiscover projects there.\n\n(fn DIRECTORY &optional DEPTH)" t)(autoload 'projectile-discover-projects-in-search-path "projectile" "Discover projects in `projectile-project-search-path'.\nInvoked automatically when `projectile-mode' is enabled." t)(autoload 'projectile-switch-to-buffer "projectile" "Switch to a project buffer." t)(autoload 'projectile-switch-to-buffer-other-window "projectile" "Switch to a project buffer and show it in another window." t)(autoload 'projectile-switch-to-buffer-other-frame "projectile" "Switch to a project buffer and show it in another frame." t)(autoload 'projectile-display-buffer "projectile" "Display a project buffer in another window without selecting it." t)(autoload 'projectile-project-buffers-other-buffer "projectile" "Switch to the most recently selected buffer project buffer.\nOnly buffers not visible in windows are returned." t)(autoload 'projectile-multi-occur "projectile" "Do a `multi-occur' in the project's buffers.\nWith a prefix argument, show NLINES of context.\n\n(fn &optional NLINES)" t)(autoload 'projectile-find-other-file "projectile" "Switch between files with the same name but different extensions.\nWith FLEX-MATCHING, match any file that contains the base name of current file.\nOther file extensions can be customized with the variable\n`projectile-other-file-alist'.\n\n(fn &optional FLEX-MATCHING)" t)(autoload 'projectile-find-other-file-other-window "projectile" "Switch between files with different extensions in other window.\nSwitch between files with the same name but different extensions in other\nwindow.  With FLEX-MATCHING, match any file that contains the base name of\ncurrent file.  Other file extensions can be customized with the variable\n`projectile-other-file-alist'.\n\n(fn &optional FLEX-MATCHING)" t)(autoload 'projectile-find-other-file-other-frame "projectile" "Switch between files with different extensions in other frame.\nSwitch between files with the same name but different extensions in other frame.\nWith FLEX-MATCHING, match any file that contains the base name of current\nfile.  Other file extensions can be customized with the variable\n`projectile-other-file-alist'.\n\n(fn &optional FLEX-MATCHING)" t)(autoload 'projectile-find-file-dwim "projectile" "Jump to a project's files using completion based on context.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\nIf point is on a filename, Projectile first tries to search for that\nfile in project:\n\n- If it finds just a file, it switches to that file instantly.  This works\neven if the filename is incomplete, but there's only a single file in the\ncurrent project that matches the filename at point.  For example, if\nthere's only a single file named \"projectile/projectile.el\" but the\ncurrent filename is \"projectile/proj\" (incomplete),\n`projectile-find-file-dwim' still switches to \"projectile/projectile.el\"\nimmediately because this is the only filename that matches.\n\n- If it finds a list of files, the list is displayed for selecting.  A list\nof files is displayed when a filename appears more than one in the project\nor the filename at point is a prefix of more than two files in a project.\nFor example, if `projectile-find-file-dwim' is executed on a filepath like\n\"projectile/\", it lists the content of that directory.  If it is executed\non a partial filename like \"projectile/a\", a list of files with character\n\"a\" in that directory is presented.\n\n- If it finds nothing, display a list of all files in project for selecting.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-file-dwim-other-window "projectile" "Jump to a project's files using completion based on context in other window.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\nIf point is on a filename, Projectile first tries to search for that\nfile in project:\n\n- If it finds just a file, it switches to that file instantly.  This works\neven if the filename is incomplete, but there's only a single file in the\ncurrent project that matches the filename at point.  For example, if\nthere's only a single file named \"projectile/projectile.el\" but the\ncurrent filename is \"projectile/proj\" (incomplete),\n`projectile-find-file-dwim-other-window' still switches to\n\"projectile/projectile.el\" immediately because this is the only filename\nthat matches.\n\n- If it finds a list of files, the list is displayed for selecting.  A list\nof files is displayed when a filename appears more than one in the project\nor the filename at point is a prefix of more than two files in a project.\nFor example, if `projectile-find-file-dwim-other-window' is executed on a\nfilepath like \"projectile/\", it lists the content of that directory.  If\nit is executed on a partial filename like \"projectile/a\", a list of files\nwith character \"a\" in that directory is presented.\n\n- If it finds nothing, display a list of all files in project for selecting.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-file-dwim-other-frame "projectile" "Jump to a project's files using completion based on context in other frame.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\nIf point is on a filename, Projectile first tries to search for that\nfile in project:\n\n- If it finds just a file, it switches to that file instantly.  This works\neven if the filename is incomplete, but there's only a single file in the\ncurrent project that matches the filename at point.  For example, if\nthere's only a single file named \"projectile/projectile.el\" but the\ncurrent filename is \"projectile/proj\" (incomplete),\n`projectile-find-file-dwim-other-frame' still switches to\n\"projectile/projectile.el\" immediately because this is the only filename\nthat matches.\n\n- If it finds a list of files, the list is displayed for selecting.  A list\nof files is displayed when a filename appears more than one in the project\nor the filename at point is a prefix of more than two files in a project.\nFor example, if `projectile-find-file-dwim-other-frame' is executed on a\nfilepath like \"projectile/\", it lists the content of that directory.  If\nit is executed on a partial filename like \"projectile/a\", a list of files\nwith character \"a\" in that directory is presented.\n\n- If it finds nothing, display a list of all files in project for selecting.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-file "projectile" "Jump to a project's file using completion.\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-file-other-window "projectile" "Jump to a project's file using completion and show it in another window.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-file-other-frame "projectile" "Jump to a project's file using completion and show it in another frame.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-toggle-project-read-only "projectile" "Toggle project read only." t)(autoload 'projectile-add-dir-local-variable "projectile" "Run `add-dir-local-variable' with .dir-locals.el in root of project.\n\nParameters MODE VARIABLE VALUE are passed directly to `add-dir-local-variable'.\n\n(fn MODE VARIABLE VALUE)")(autoload 'projectile-delete-dir-local-variable "projectile" "Run `delete-dir-local-variable' with .dir-locals.el in root of project.\n\nParameters MODE VARIABLE VALUE are passed directly to\n`delete-dir-local-variable'.\n\n(fn MODE VARIABLE)")(autoload 'projectile-find-dir "projectile" "Jump to a project's directory using completion.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-dir-other-window "projectile" "Jump to a project's directory in other window using completion.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-dir-other-frame "projectile" "Jump to a project's directory in other frame using completion.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-test-file "projectile" "Jump to a project's test file using completion.\n\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\n\n(fn &optional INVALIDATE-CACHE)" t)(autoload 'projectile-find-related-file-other-window "projectile" "Open related file in other window." t)(autoload 'projectile-find-related-file-other-frame "projectile" "Open related file in other frame." t)(autoload 'projectile-find-related-file "projectile" "Open related file." t)(autoload 'projectile-related-files-fn-groups "projectile" "Generate a related-files-fn which relates as KIND for files in each of GROUPS.\n\n(fn KIND GROUPS)")(autoload 'projectile-related-files-fn-extensions "projectile" "Generate a related-files-fn which relates as KIND for files having EXTENSIONS.\n\n(fn KIND EXTENSIONS)")(autoload 'projectile-related-files-fn-test-with-prefix "projectile" "Generate a related-files-fn which relates tests and impl.\nUse files with EXTENSION based on TEST-PREFIX.\n\n(fn EXTENSION TEST-PREFIX)")(autoload 'projectile-related-files-fn-test-with-suffix "projectile" "Generate a related-files-fn which relates tests and impl.\nUse files with EXTENSION based on TEST-SUFFIX.\n\n(fn EXTENSION TEST-SUFFIX)")(autoload 'projectile-project-info "projectile" "Display info for current project." t)(autoload 'projectile-find-implementation-or-test-other-window "projectile" "Open matching implementation or test file in other window.\n\nSee the documentation of `projectile--find-matching-file' and\n`projectile--find-matching-test' for how implementation and test files\nare determined." t)(autoload 'projectile-find-implementation-or-test-other-frame "projectile" "Open matching implementation or test file in other frame.\n\nSee the documentation of `projectile--find-matching-file' and\n`projectile--find-matching-test' for how implementation and test files\nare determined." t)(autoload 'projectile-toggle-between-implementation-and-test "projectile" "Toggle between an implementation file and its test file.\n\n\nSee the documentation of `projectile--find-matching-file' and\n`projectile--find-matching-test' for how implementation and test files\nare determined." t)(autoload 'projectile-grep "projectile" "Perform rgrep in the project.\n\nWith a prefix ARG asks for files (globbing-aware) which to grep in.\nWith prefix ARG of `-' (such as `M--'), default the files (without prompt),\nto `projectile-grep-default-files'.\n\nWith REGEXP given, don't query the user for a regexp.\n\n(fn &optional REGEXP ARG)" t)(autoload 'projectile-ag "projectile" "Run an ag search with SEARCH-TERM in the project.\n\nWith an optional prefix argument ARG SEARCH-TERM is interpreted as a\nregular expression.\n\n(fn SEARCH-TERM &optional ARG)" t)(autoload 'projectile-ripgrep "projectile" "Run a ripgrep (rg) search with `SEARCH-TERM' at current project root.\n\nWith an optional prefix argument ARG SEARCH-TERM is interpreted as a\nregular expression.\n\nThis command depends on of the Emacs packages ripgrep or rg being\ninstalled to work.\n\n(fn SEARCH-TERM &optional ARG)" t)(autoload 'projectile-regenerate-tags "projectile" "Regenerate the project's [e|g]tags." t)(autoload 'projectile-find-tag "projectile" "Find tag in project." t)(autoload 'projectile-run-command-in-root "projectile" "Invoke `execute-extended-command' in the project's root." t)(autoload 'projectile-run-shell-command-in-root "projectile" "Invoke `shell-command' in the project's root.\n\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)" t)(autoload 'projectile-run-async-shell-command-in-root "projectile" "Invoke `async-shell-command' in the project's root.\n\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)" t)(autoload 'projectile-run-gdb "projectile" "Invoke `gdb' in the project's root." t)(autoload 'projectile-run-shell "projectile" "Invoke `shell' in the project's root.\n\nSwitch to the project specific shell buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-run-eshell "projectile" "Invoke `eshell' in the project's root.\n\nSwitch to the project specific eshell buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-run-ielm "projectile" "Invoke `ielm' in the project's root.\n\nSwitch to the project specific ielm buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-run-term "projectile" "Invoke `term' in the project's root.\n\nSwitch to the project specific term buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-run-vterm "projectile" "Invoke `vterm' in the project's root.\n\nSwitch to the project specific term buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-run-vterm-other-window "projectile" "Invoke `vterm' in the project's root.\n\nSwitch to the project specific term buffer if it already exists.\n\nUse a prefix argument ARG to indicate creation of a new process instead.\n\n(fn &optional ARG)" t)(autoload 'projectile-replace "projectile" "Replace literal string in project using non-regexp `tags-query-replace'.\n\nWith a prefix argument ARG prompts you for a directory and file name patterns\non which to run the replacement.\n\n(fn &optional ARG)" t)(autoload 'projectile-replace-regexp "projectile" "Replace a regexp in the project using `tags-query-replace'.\n\nWith a prefix argument ARG prompts you for a directory on which\nto run the replacement.\n\n(fn &optional ARG)" t)(autoload 'projectile-kill-buffers "projectile" "Kill project buffers.\n\nThe buffer are killed according to the value of\n`projectile-kill-buffers-filter'." t)(autoload 'projectile-save-project-buffers "projectile" "Save all project buffers." t)(autoload 'projectile-dired "projectile" "Open `dired' at the root of the project." t)(autoload 'projectile-dired-other-window "projectile" "Open `dired'  at the root of the project in another window." t)(autoload 'projectile-dired-other-frame "projectile" "Open `dired' at the root of the project in another frame." t)(autoload 'projectile-vc "projectile" "Open `vc-dir' at the root of the project.\n\nFor git projects `magit-status-internal' is used if available.\nFor hg projects `monky-status' is used if available.\n\nIf PROJECT-ROOT is given, it is opened instead of the project\nroot directory of the current buffer file.  If interactively\ncalled with a prefix argument, the user is prompted for a project\ndirectory to open.\n\n(fn &optional PROJECT-ROOT)" t)(autoload 'projectile-recentf "projectile" "Show a list of recently visited files in a project." t)(autoload 'projectile-configure-project "projectile" "Run project configure command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.\n\n(fn ARG)" t)(autoload 'projectile-compile-project "projectile" "Run project compilation command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.  Per project default command can be set through\n`projectile-project-compilation-cmd'.\n\n(fn ARG)" t)(autoload 'projectile-test-project "projectile" "Run project test command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.\n\n(fn ARG)" t)(autoload 'projectile-install-project "projectile" "Run project install command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.\n\n(fn ARG)" t)(autoload 'projectile-package-project "projectile" "Run project package command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.\n\n(fn ARG)" t)(autoload 'projectile-run-project "projectile" "Run project run command.\n\nNormally you'll be prompted for a compilation command, unless\nvariable `compilation-read-command'.  You can force the prompt\nwith a prefix ARG.\n\n(fn ARG)" t)(autoload 'projectile-repeat-last-command "projectile" "Run last projectile external command.\n\nExternal commands are: `projectile-configure-project',\n`projectile-compile-project', `projectile-test-project',\n`projectile-install-project', `projectile-package-project',\nand `projectile-run-project'.\n\nIf the prefix argument SHOW-PROMPT is non nil, the command can be edited.\n\n(fn SHOW-PROMPT)" t)(autoload 'projectile-switch-project "projectile" "Switch to a project we have visited before.\nInvokes the command referenced by `projectile-switch-project-action' on switch.\nWith a prefix ARG invokes `projectile-commander' instead of\n`projectile-switch-project-action.'\n\n(fn &optional ARG)" t)(autoload 'projectile-switch-open-project "projectile" "Switch to a project we have currently opened.\nInvokes the command referenced by `projectile-switch-project-action' on switch.\nWith a prefix ARG invokes `projectile-commander' instead of\n`projectile-switch-project-action.'\n\n(fn &optional ARG)" t)(autoload 'projectile-find-file-in-directory "projectile" "Jump to a file in a (maybe regular) DIRECTORY.\n\nThis command will first prompt for the directory the file is in.\n\n(fn &optional DIRECTORY)" t)(autoload 'projectile-find-file-in-known-projects "projectile" "Jump to a file in any of the known projects." t)(autoload 'projectile-cleanup-known-projects "projectile" "Remove known projects that don't exist anymore." t)(autoload 'projectile-clear-known-projects "projectile" "Clear both `projectile-known-projects' and `projectile-known-projects-file'." t)(autoload 'projectile-reset-known-projects "projectile" "Clear known projects and rediscover." t)(autoload 'projectile-remove-known-project "projectile" "Remove PROJECT from the list of known projects.\n\n(fn &optional PROJECT)" t)(autoload 'projectile-remove-current-project-from-known-projects "projectile" "Remove the current project from the list of known projects." t)(autoload 'projectile-add-known-project "projectile" "Add PROJECT-ROOT to the list of known projects.\n\n(fn PROJECT-ROOT)" t)(autoload 'projectile-ibuffer "projectile" "Open an IBuffer window showing all buffers in the current project.\n\nLet user choose another project when PROMPT-FOR-PROJECT is supplied.\n\n(fn PROMPT-FOR-PROJECT)" t)(autoload 'projectile-commander "projectile" "Execute a Projectile command with a single letter.\nThe user is prompted for a single character indicating the action to invoke.\nThe `?' character describes then\navailable actions.\n\nSee `def-projectile-commander-method' for defining new methods." t)(autoload 'projectile-browse-dirty-projects "projectile" "Browse dirty version controlled projects.\n\nWith a prefix argument, or if CACHED is non-nil, try to use the cached\ndirty project list.\n\n(fn &optional CACHED)" t)(autoload 'projectile-edit-dir-locals "projectile" "Edit or create a .dir-locals.el file of the project." t)(defvar projectile-mode nil "Non-nil if Projectile mode is enabled.\nSee the `projectile-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `projectile-mode'.")(autoload 'projectile-mode "projectile" "Minor mode to assist project management and navigation.\n\nWhen called interactively, toggle `projectile-mode'.  With prefix\nARG, enable `projectile-mode' if ARG is positive, otherwise disable\nit.\n\nWhen called from Lisp, enable `projectile-mode' if ARG is omitted,\nnil or positive.  If ARG is `toggle', toggle `projectile-mode'.\nOtherwise behave as if called interactively.\n\n\\{projectile-mode-map}\n\n(fn &optional ARG)" t)(define-obsolete-function-alias 'projectile-global-mode 'projectile-mode "1.0")(autoload 'ws-butler-mode "ws-butler" "White space cleanup, without obtrusive white space removal.\n\nWhitespaces at EOL and EOF are trimmed upon file save, and only\nfor lines modified by you.\n\nThis is a minor mode.  If called interactively, toggle the\n`Ws-Butler mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `ws-butler-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'ws-butler-global-mode 'globalized-minor-mode t)(defvar ws-butler-global-mode nil "Non-nil if Ws-Butler-Global mode is enabled.\nSee the `ws-butler-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `ws-butler-global-mode'.")(autoload 'ws-butler-global-mode "ws-butler" "Toggle Ws-Butler mode in all buffers.\nWith prefix ARG, enable Ws-Butler-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nWs-Butler mode is enabled in all buffers where `(lambda nil (unless\n(apply #'derived-mode-p ws-butler-global-exempt-modes)\n(ws-butler-mode)))' would do it.\n\nSee `ws-butler-mode' for more information on Ws-Butler mode.\n\n(fn &optional ARG)" t)(autoload 'sp-cheat-sheet "smartparens" "Generate a cheat sheet of all the smartparens interactive functions.\n\nWithout a prefix argument, print only the short documentation and examples.\n\nWith non-nil prefix argument ARG, show the full documentation for each function.\n\nYou can follow the links to the function or variable help page.\nTo get back to the full list, use \\[help-go-back].\n\nYou can use `beginning-of-defun' and `end-of-defun' to jump to\nthe previous/next entry.\n\nExamples are fontified using the `font-lock-string-face' for\nbetter orientation.\n\n(fn &optional ARG)" t)(defvar smartparens-mode-map (make-sparse-keymap) "Keymap used for `smartparens-mode'.")(autoload 'sp-use-paredit-bindings "smartparens" "Initiate `smartparens-mode-map' with `sp-paredit-bindings'." t)(autoload 'sp-use-smartparens-bindings "smartparens" "Initiate `smartparens-mode-map' with `sp-smartparens-bindings'." t)(autoload 'smartparens-mode "smartparens" "Toggle smartparens mode.\n\nYou can enable pre-set bindings by customizing\n`sp-base-key-bindings' variable.  The current content of\n`smartparens-mode-map' is:\n\n \\{smartparens-mode-map}\n\nThis is a minor mode.  If called interactively, toggle the\n`Smartparens mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `smartparens-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'smartparens-strict-mode "smartparens" "Toggle the strict smartparens mode.\n\nWhen strict mode is active, `delete-char', `kill-word' and their\nbackward variants will skip over the pair delimiters in order to\nkeep the structure always valid (the same way as `paredit-mode'\ndoes).  This is accomplished by remapping them to\n`sp-delete-char' and `sp-kill-word'.  There is also function\n`sp-kill-symbol' that deletes symbols instead of words, otherwise\nworking exactly the same (it is not bound to any key by default).\n\nWhen strict mode is active, this is indicated with \"/s\"\nafter the smartparens indicator in the mode list.\n\nThis is a minor mode.  If called interactively, toggle the\n`Smartparens-Strict mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `smartparens-strict-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'smartparens-global-strict-mode 'globalized-minor-mode t)(defvar smartparens-global-strict-mode nil "Non-nil if Smartparens-Global-Strict mode is enabled.\nSee the `smartparens-global-strict-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `smartparens-global-strict-mode'.")(autoload 'smartparens-global-strict-mode "smartparens" "Toggle Smartparens-Strict mode in all buffers.\nWith prefix ARG, enable Smartparens-Global-Strict mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nSmartparens-Strict mode is enabled in all buffers where\n`turn-on-smartparens-strict-mode' would do it.\n\nSee `smartparens-strict-mode' for more information on\nSmartparens-Strict mode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-smartparens-strict-mode "smartparens" "Turn on `smartparens-strict-mode'." t)(autoload 'turn-off-smartparens-strict-mode "smartparens" "Turn off `smartparens-strict-mode'." t)(put 'smartparens-global-mode 'globalized-minor-mode t)(defvar smartparens-global-mode nil "Non-nil if Smartparens-Global mode is enabled.\nSee the `smartparens-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `smartparens-global-mode'.")(autoload 'smartparens-global-mode "smartparens" "Toggle Smartparens mode in all buffers.\nWith prefix ARG, enable Smartparens-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nSmartparens mode is enabled in all buffers where\n`turn-on-smartparens-mode' would do it.\n\nSee `smartparens-mode' for more information on Smartparens mode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-smartparens-mode "smartparens" "Turn on `smartparens-mode'.\n\nThis function is used to turn on `smartparens-global-mode'.\n\nBy default `smartparens-global-mode' ignores buffers with\n`mode-class' set to special, but only if they are also not comint\nbuffers.\n\nAdditionally, buffers on `sp-ignore-modes-list' are ignored.\n\nYou can still turn on smartparens in these mode manually (or\nin mode's startup-hook etc.) by calling `smartparens-mode'." t)(autoload 'turn-off-smartparens-mode "smartparens" "Turn off `smartparens-mode'." t)(autoload 'show-smartparens-mode "smartparens" "Toggle visualization of matching pairs.  When enabled, any\n\nmatching pair is highlighted after `sp-show-pair-delay' seconds\nof Emacs idle time if the point is immediately in front or after\na pair.  This mode works similarly to `show-paren-mode', but\nsupport custom pairs.\n\nThis is a minor mode.  If called interactively, toggle the\n`Show-Smartparens mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `show-smartparens-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'show-smartparens-global-mode 'globalized-minor-mode t)(defvar show-smartparens-global-mode nil "Non-nil if Show-Smartparens-Global mode is enabled.\nSee the `show-smartparens-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `show-smartparens-global-mode'.")(autoload 'show-smartparens-global-mode "smartparens" "Toggle Show-Smartparens mode in all buffers.\nWith prefix ARG, enable Show-Smartparens-Global mode if ARG is\npositive; otherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nShow-Smartparens mode is enabled in all buffers where\n`turn-on-show-smartparens-mode' would do it.\n\nSee `show-smartparens-mode' for more information on Show-Smartparens\nmode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-show-smartparens-mode "smartparens" "Turn on `show-smartparens-mode'.\n\nThis function is used to turn on `show-smartparens-global-mode'.\n\nMajor modes on `sp-ignore-modes-list' are ignored when turning on\nthe globalized mode.\n\nYou can still turn on `show-smartparens-mode' manually by calling\n\\[show-smartparens-mode.]" t)(autoload 'turn-off-show-smartparens-mode "smartparens" "Turn off `show-smartparens-mode'." t)(autoload 'dtrt-indent-mode "dtrt-indent" "Toggle dtrt-indent mode.\n\nWith no argument, this command toggles the mode.  Non-null prefix\nargument turns on the mode.  Null prefix argument turns off the\nmode.\n\nWhen dtrt-indent mode is enabled, the proper indentation offset\nand `indent-tabs-mode' will be guessed for newly opened files and\nadjusted transparently.\n\nThis is a minor mode.  If called interactively, toggle the\n`Dtrt-Indent mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `dtrt-indent-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'dtrt-indent-global-mode 'globalized-minor-mode t)(defvar dtrt-indent-global-mode nil "Non-nil if Dtrt-Indent-Global mode is enabled.\nSee the `dtrt-indent-global-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `dtrt-indent-global-mode'.")(autoload 'dtrt-indent-global-mode "dtrt-indent" "Toggle Dtrt-Indent mode in all buffers.\nWith prefix ARG, enable Dtrt-Indent-Global mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nDtrt-Indent mode is enabled in all buffers where `(lambda nil (when\n(derived-mode-p 'prog-mode 'text-mode 'javascript-mode)\n(dtrt-indent-mode)))' would do it.\n\nSee `dtrt-indent-mode' for more information on Dtrt-Indent mode.\n\n(fn &optional ARG)" t)(defvar dtrt-indent-mode nil "Toggle adaptive indentation mode.\nSetting this variable directly does not take effect;\nuse either \\[customize] or the function `dtrt-indent-mode'.")(autoload 'better-jumper-set-jump "better-jumper" "Set jump point at POS.\nPOS defaults to point.\n\n(fn &optional POS)" t)(autoload 'better-jumper-jump-backward "better-jumper" "Jump backward COUNT positions to previous location in jump list.\nIf COUNT is nil then defaults to 1.\n\n(fn &optional COUNT)" t)(autoload 'better-jumper-jump-forward "better-jumper" "Jump forward COUNT positions to location in jump list.\nIf COUNT is nil then defaults to 1.\n\n(fn &optional COUNT)" t)(autoload 'better-jumper-jump-newest "better-jumper" "Jump forward to newest entry in jump list." t)(autoload 'better-jumper-clear-jumps "better-jumper" "Clears jump list for WINDOW-OR-BUFFER.\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\ncontext and will default to current context if not provided.\n\n(fn &optional WINDOW-OR-BUFFER)" t)(autoload 'better-jumper-get-jumps "better-jumper" "Get jumps for WINDOW-OR-BUFFER.\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\ncontext and will default to current context if not provided.\n\n(fn &optional WINDOW-OR-BUFFER)")(autoload 'better-jumper-set-jumps "better-jumper" "Set jumps to JUMPS for WINDOW-OR-BUFFER.\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\ncontext and will default to current context if not provided.\n\n(fn JUMPS &optional WINDOW-OR-BUFFER)")(autoload 'turn-on-better-jumper-mode "better-jumper" "Enable better-jumper-mode in the current buffer.")(autoload 'turn-off-better-jumper-mode "better-jumper" "Disable `better-jumper-local-mode' in the current buffer.")(autoload 'better-jumper-local-mode "better-jumper" "better-jumper minor mode.\n\nThis is a minor mode.  If called interactively, toggle the\n`better-jumper-Local mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `better-jumper-local-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'better-jumper-mode 'globalized-minor-mode t)(defvar better-jumper-mode nil "Non-nil if Better-Jumper mode is enabled.\nSee the `better-jumper-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `better-jumper-mode'.")(autoload 'better-jumper-mode "better-jumper" "Toggle Better-Jumper-Local mode in all buffers.\nWith prefix ARG, enable Better-Jumper mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nBetter-Jumper-Local mode is enabled in all buffers where\n`turn-on-better-jumper-mode' would do it.\n\nSee `better-jumper-local-mode' for more information on\nBetter-Jumper-Local mode.\n\n(fn &optional ARG)" t)(autoload 'restart-emacs-handle-command-line-args "restart-emacs" "Handle the --restart-emacs-desktop command line argument.\n\nThe value of the argument is the desktop file from which the frames should be\nrestored.  IGNORED are ignored.\n\n(fn &rest IGNORED)")(add-to-list 'command-switch-alist '("--restart-emacs-desktop" . restart-emacs-handle-command-line-args))(autoload 'restart-emacs "restart-emacs" "Restart Emacs.\n\nWhen called interactively ARGS is interpreted as follows\n\n- with a single `universal-argument' (`C-u') Emacs is restarted\n  with `--debug-init' flag\n- with two `universal-argument' (`C-u') Emacs is restarted with\n  `-Q' flag\n- with three `universal-argument' (`C-u') the user prompted for\n  the arguments\n\nWhen called non-interactively ARGS should be a list of arguments\nwith which Emacs should be restarted.\n\n(fn &optional ARGS)" t)(autoload 'restart-emacs-start-new-emacs "restart-emacs" "Start a new instance of Emacs.\n\nWhen called interactively ARGS is interpreted as follows\n\n- with a single `universal-argument' (`C-u') the new Emacs is started\n  with `--debug-init' flag\n- with two `universal-argument' (`C-u') the new Emacs is started with\n  `-Q' flag\n- with three `universal-argument' (`C-u') the user prompted for\n  the arguments\n\nWhen called non-interactively ARGS should be a list of arguments\nwith which the new Emacs should be started.\n\n(fn &optional ARGS)" t)(autoload 'rainbow-delimiters-mode "rainbow-delimiters" "Highlight nested parentheses, brackets, and braces according to their depth.\n\nThis is a minor mode.  If called interactively, toggle the\n`Rainbow-Delimiters mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable\nthe mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `rainbow-delimiters-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(autoload 'rainbow-delimiters-mode-enable "rainbow-delimiters" "Enable `rainbow-delimiters-mode'.")(autoload 'rainbow-delimiters-mode-disable "rainbow-delimiters" "Disable `rainbow-delimiters-mode'.")(autoload 'highlight-numbers-mode "highlight-numbers" "Minor mode for highlighting numeric literals in source code.\n\nToggle Highlight Numbers mode on or off.\n\nWith a prefix argument ARG, enable Highlight Numbers mode if ARG is\npositive, and disable it otherwise. If called from Lisp, enable\nthe mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.\n\n(fn &optional ARG)" t)(autoload 'hide-mode-line-mode "hide-mode-line" "Minor mode to hide the mode-line in the current buffer.\n\nThis is a minor mode.  If called interactively, toggle the\n`Hide-Mode-Line mode' mode.  If the prefix argument is positive,\nenable the mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `hide-mode-line-mode'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(put 'global-hide-mode-line-mode 'globalized-minor-mode t)(defvar global-hide-mode-line-mode nil "Non-nil if Global Hide-Mode-Line mode is enabled.\nSee the `global-hide-mode-line-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `global-hide-mode-line-mode'.")(autoload 'global-hide-mode-line-mode "hide-mode-line" "Toggle Hide-Mode-Line mode in all buffers.\nWith prefix ARG, enable Global Hide-Mode-Line mode if ARG is positive;\notherwise, disable it.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.\nEnable the mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nHide-Mode-Line mode is enabled in all buffers where\n`turn-on-hide-mode-line-mode' would do it.\n\nSee `hide-mode-line-mode' for more information on Hide-Mode-Line\nmode.\n\n(fn &optional ARG)" t)(autoload 'turn-on-hide-mode-line-mode "hide-mode-line" "Turn on `hide-mode-line-mode'.\nUnless in `fundamental-mode' or `hide-mode-line-excluded-modes'.")(autoload 'turn-off-hide-mode-line-mode "hide-mode-line" "Turn off `hide-mode-line-mode'.")(defvar gcmh-mode nil "Non-nil if GCMH mode is enabled.\nSee the `gcmh-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `gcmh-mode'.")(autoload 'gcmh-mode "gcmh" "Minor mode to tweak Garbage Collection strategy.\n\nThis is a global minor mode.  If called interactively, toggle the\n`GCMH mode' mode.  If the prefix argument is positive, enable the\nmode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable\nthe mode if ARG is nil, omitted, or is a positive number.\nDisable the mode if ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='gcmh-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when\nit is disabled.\n\n(fn &optional ARG)" t)(defvar auto-minor-mode-alist nil "Alist of filename patterns vs corresponding minor mode functions.\n\nThis is an equivalent of \x2018\ auto-mode-alist\x2019, for minor modes.\n\nUnlike \x2018\ auto-mode-alist\x2019, matching is always case-folded.")(defvar auto-minor-mode-magic-alist nil "Alist of buffer beginnings vs corresponding minor mode functions.\n\nThis is an equivalent of \x2018magic-mode-alist\x2019, for minor modes.\n\nMagic minor modes are applied after \x2018set-auto-mode\x2019 enables any\nmajor mode, so it\x2019s possible to check for expected major modes in\nmatch functions.\n\nUnlike \x2018magic-mode-alist\x2019, matching is always case-folded.")(autoload 'auto-minor-mode-set "auto-minor-mode" "Enable all minor modes appropriate for the current buffer.\n\nIf the optional argument KEEP-MODE-IF-SAME is non-nil, then we\ndon\x2019t re-activate minor modes already enabled in the buffer.\n\n(fn &optional KEEP-MODE-IF-SAME)")(advice-add #'set-auto-mode :after #'auto-minor-mode-set)(autoload 'use-package-autoload-keymap "use-package-bind-key" "Load PACKAGE and bind key sequence invoking this function to KEYMAP-SYMBOL.\nThen simulate pressing the same key sequence a again, so that the\nnext key pressed is routed to the newly loaded keymap.\n\nThis function supports use-package's :bind-keymap keyword.  It\nworks by binding the given key sequence to an invocation of this\nfunction for a particular keymap.  The keymap is expected to be\ndefined by the package.  In this way, loading the package is\ndeferred until the prefix key sequence is pressed.\n\n(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)")(autoload 'use-package-normalize-binder "use-package-bind-key" "\n\n(fn NAME KEYWORD ARGS)")(defalias 'use-package-normalize/:bind 'use-package-normalize-binder)(defalias 'use-package-normalize/:bind* 'use-package-normalize-binder)(defalias 'use-package-autoloads/:bind 'use-package-autoloads-mode)(defalias 'use-package-autoloads/:bind* 'use-package-autoloads-mode)(autoload 'use-package-handler/:bind "use-package-bind-key" "\n\n(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)")(defalias 'use-package-normalize/:bind-keymap 'use-package-normalize-binder)(defalias 'use-package-normalize/:bind-keymap* 'use-package-normalize-binder)(autoload 'use-package-handler/:bind-keymap "use-package-bind-key" "\n\n(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)")(autoload 'use-package-handler/:bind-keymap* "use-package-bind-key" "\n\n(fn NAME KEYWORD ARG REST STATE)")(autoload 'use-package "use-package-core" "Declare an Emacs package by specifying a group of configuration options.\n\nFor the full documentation, see Info node `(use-package) top'.\nUsage:\n\n  (use-package package-name\n     [:keyword [option]]...)\n\n:init            Code to run before PACKAGE-NAME has been loaded.\n:config          Code to run after PACKAGE-NAME has been loaded.  Note that\n                 if loading is deferred for any reason, this code does not\n                 execute until the lazy load has occurred.\n:preface         Code to be run before everything except `:disabled'; this\n                 can be used to define functions for use in `:if', or that\n                 should be seen by the byte-compiler.\n\n:mode            Form to be added to `auto-mode-alist'.\n:magic           Form to be added to `magic-mode-alist'.\n:magic-fallback  Form to be added to `magic-fallback-mode-alist'.\n:interpreter     Form to be added to `interpreter-mode-alist'.\n\n:commands        Define autoloads for commands that will be defined by the\n                 package.  This is useful if the package is being lazily\n                 loaded, and you wish to conditionally call functions in your\n                 `:init' block that are defined in the package.\n:autoload        Similar to :commands, but it for no-interactive one.\n:hook            Specify hook(s) to attach this package to.\n\n:bind            Bind keys, and define autoloads for the bound commands.\n:bind*           Bind keys, and define autoloads for the bound commands,\n                 *overriding all minor mode bindings*.\n:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the\n                 package.  This is like `:bind', but for keymaps.\n:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings\n\n:defer           Defer loading of a package -- this is implied when using\n                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',\n                 `:magic-fallback', or `:interpreter'.  This can be an integer,\n                 to force loading after N seconds of idle time, if the package\n                 has not already been loaded.\n:demand          Prevent the automatic deferred loading introduced by constructs\n                 such as `:bind' (see `:defer' for the complete list).\n\n:after           Delay the effect of the use-package declaration\n                 until after the named libraries have loaded.\n                 Before they have been loaded, no other keyword\n                 has any effect at all, and once they have been\n                 loaded it is as if `:after' was not specified.\n\n:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.\n:disabled        The package is ignored completely if this keyword is present.\n:defines         Declare certain variables to silence the byte-compiler.\n:functions       Declare certain functions to silence the byte-compiler.\n:load-path       Add to the `load-path' before attempting to load the package.\n:diminish        Support for diminish.el (if installed).\n:delight         Support for delight.el (if installed).\n:custom          Call `Custom-set' or `set-default' with each variable\n                 definition without modifying the Emacs `custom-file'.\n                 (compare with `custom-set-variables').\n:custom-face     Call `custom-set-faces' with each face definition.\n:ensure          Loads the package using package.el if necessary.\n:pin             Pin the package to an archive.\n\n(fn NAME &rest ARGS)" nil t)(function-put 'use-package 'lisp-indent-function 'defun)(autoload 'use-package-normalize/:delight "use-package-delight" "Normalize arguments to delight.\n\n(fn NAME KEYWORD ARGS)")(autoload 'use-package-handler/:delight "use-package-delight" "\n\n(fn NAME KEYWORD ARGS REST STATE)")(autoload 'use-package-normalize/:diminish "use-package-diminish" "\n\n(fn NAME KEYWORD ARGS)")(autoload 'use-package-handler/:diminish "use-package-diminish" "\n\n(fn NAME KEYWORD ARG REST STATE)")(autoload 'use-package-normalize/:ensure "use-package-ensure" "\n\n(fn NAME KEYWORD ARGS)")(autoload 'use-package-handler/:ensure "use-package-ensure" "\n\n(fn NAME KEYWORD ENSURE REST STATE)")(autoload 'use-package-jump-to-package-form "use-package-jump" "Attempt to find and jump to the `use-package' form that loaded PACKAGE.\nThis will only find the form if that form actually required\nPACKAGE.  If PACKAGE was previously required then this function\nwill jump to the file that originally required PACKAGE instead.\n\n(fn PACKAGE)" t)(autoload 'use-package-lint "use-package-lint" "Check for errors in `use-package' declarations.\nFor example, if the module's `:if' condition is met, but even\nwith the specified `:load-path' the module cannot be found." t)(autoload 'bind-key "bind-key" "Bind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).\n\nKEY-NAME may be a vector, in which case it is passed straight to\n`define-key'.  Or it may be a string to be interpreted as\nspelled-out keystrokes, e.g., \"C-c C-z\".  See the documentation\nof `edmacro-mode' for details.\n\nCOMMAND must be an interactive function, lambda form, or a cons\n`(STRING . DEFN)'.\n\nKEYMAP, if present, should be a keymap variable or symbol.\nFor example:\n\n  (bind-key \"M-h\" #\\='some-interactive-function my-mode-map)\n\n  (bind-key \"M-h\" #\\='some-interactive-function \\='my-mode-map)\n\nIf PREDICATE is non-nil, it is a form evaluated to determine when\na key should be bound. It must return non-nil in such cases.\nEmacs can evaluate this form at any time that it does redisplay\nor operates on menu data structures, so you should write it so it\ncan safely be called at any time.\n\n(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t)(autoload 'unbind-key "bind-key" "Unbind the given KEY-NAME, within the KEYMAP (if specified).\nSee `bind-key' for more details.\n\n(fn KEY-NAME &optional KEYMAP)" nil t)(autoload 'bind-key* "bind-key" "Similar to `bind-key', but overrides any mode-specific bindings.\n\n(fn KEY-NAME COMMAND &optional PREDICATE)" nil t)(autoload 'bind-keys "bind-key" "Bind multiple keys at once.\n\nAccepts keyword arguments:\n:map MAP               - a keymap into which the keybindings should be\n                         added\n:prefix KEY            - prefix key for these bindings\n:prefix-map MAP        - name of the prefix map that should be created\n                         for these bindings\n:prefix-docstring STR  - docstring for the prefix-map variable\n:menu-name NAME        - optional menu string for prefix map\n:repeat-docstring STR  - docstring for the repeat-map variable\n:repeat-map MAP        - name of the repeat map that should be created\n                         for these bindings. If specified, the\n                         `repeat-map' property of each command bound\n                         (within the scope of the `:repeat-map' keyword)\n                         is set to this map.\n:exit BINDINGS         - Within the scope of `:repeat-map' will bind the\n                         key in the repeat map, but will not set the\n                         `repeat-map' property of the bound command.\n:continue BINDINGS     - Within the scope of `:repeat-map' forces the\n                         same behaviour as if no special keyword had\n                         been used (that is, the command is bound, and\n                         it's `repeat-map' property set)\n:filter FORM           - optional form to determine when bindings apply\n\nThe rest of the arguments are conses of keybinding string and a\nfunction symbol (unquoted).\n\n(fn &rest ARGS)" nil t)(autoload 'bind-keys* "bind-key" "Bind multiple keys at once, in `override-global-map'.\nAccepts the same keyword arguments as `bind-keys' (which see).\n\nThis binds keys in such a way that bindings are not overridden by\nother modes.  See `override-global-mode'.\n\n(fn &rest ARGS)" nil t)(autoload 'describe-personal-keybindings "bind-key" "Display all the personal keybindings defined by `bind-key'." t)